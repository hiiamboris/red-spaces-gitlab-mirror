TODOS
event handling system - standard way to react to clicks, clicks-and-holds, keypresses, etc.
keys binding to each UI item?
focused items should be highlighted using styles
+ decouple styles from the objects
+ demo+test of rotated scrollable space (mb rotate it with time and demo proper origin)
demo: chatlog with smooth scrolling and an interactive bot
	needs reversal of list items and a custom wrapper (sender/time+paragraph)
	also buttons to remove & edit messages
+ scrollbar should generate page events periodically until LMB is up
+ styles should be deep, e.g. paragraph! <> list-view!/paragraph!
need to try 2 types of KB navigation: tabbed and spatial, how they apply
	this navigation, at least tabbed, should be able to work across different *faces*
	so: mixed transparent tabbing across spaces and faces
if `map` is defined `into` should not be needed, when none is defined it is a final space (non-composite)
	or leave `into` always there? afraid of inheritance errors
draggability of spaces (e.g. table columns) - this will require temporary offsets in the map
disabled items, and they should not be focusable!
if an item gets hidden, it should not receive keyboard events even if it's still in focus
	(there will be no 'hidden', there will be 'not drawn')
+ how to decouple KB navigation from the dispatcher?
make content: 'a-word ! make `make` return a word with a style value!
how to compose styles from the old ones? need a clear mechanism
handler spec validation and auto addition of typesets - to help learning, minimize mistakes
list & doc ideas that improve over vid/view, key differences
debug func to list handlers for this or that space (with all path variants)
should events receive full paths (from `screen`) or relative to host (from it's `space`)??
in event handlers `self` =? `commands` right now, should be set to `space`? and get rid of `space` arg?
	this will be problematic as will require a `bind` before every handler call
can I externalize list-view's rolling logic to be able to utilize it in other spaces?
table demo with wavy animated layout: each row would slide left and right in a sine manner - will be a killer demo!
	and it's columns should be draggable! :D
high-level table that would extend minimal table with advanced features
maybe a plugin mechanism:
	each space would list possible features and each of them would be a separate code, that can be turned on/off
	or it's not worth it, even for the table?
demo templates for all useful styles, like small static table, huge table for csv, etc etc
	so others can take those and build upon
separate space for an icon+text combo -- very common thing nowadays
	or `list` will be enough?
VID extension for spaces:
	on-created (possible?) global event handler
	will scan each host face's worst actor and create a space tree from it's spec
rename host/space to host/content for consistency with scrollable?
	or make it host a scrollable always?
	or make separate faces for all spaces? - best idea to keep layout clean.. e.g. host.list, host.scrollable ..
decide on resize model (though ideally it should cover View wholly)
what if I devise a standard way child sizes can be propagated into parent sizes? (headers-list dilemma)
make multi-cell span
	how can cell span multiple rows vertically?
	perhaps separate grid style will be required
	or I just make a span: field and disable clipping everywhere (except scrollable)
	no, disabled clipping won't work as we need hittest to deliver events
	however disabled clipping may be useful for a different thing: casting wide outside shadows, but be able to click thru them
table cells should know their coordinate, to be able to modify original data
styles should be able to rearrange UI items 
	maybe by changing the map before it's rendered? but that's a bit limited
	e.g. we split `draw` into `draw` and `prep`, style would apply after prep, draw will read the map
	that complicates `space` design
	OTOH it will be possible to get the `size` without actually composing draw blocks
	like this!: if `prep` exists, it's called, if not then `draw` will do it's work
				and styles will be limited in their rearrange ability
	though then one will be unable to call prep to get the size.. maybe default prep will call draw?
+ click event should only be produced when pointer didn't travel long (i.e. it's not a drag event)
will it be possible to minimize style/event lookup time if I detect changes to the tree and to style/event tables
	and then just cache the lookup results?
optional scrollbars for infinite space:
	logarithmic, linear near the current offset
	cyclic, inertial, wheel-like in appearance
trooper-like zooming into infinite canvas? although it may take quite a time to prerender it... useless unless realtime
demo: interactive plot of some downloadable btc price
	will require a color picker (Red doesn't have one) - to edit colors, and also need to edit labels, width..
demo: neon text
demo: fractal explorer on infinite canvas
describe a set of challenges to invite other to play with it and learn
maybe scrollable should be the default container for everything layout creates? or at least for lists?
add inertia to scrollable to easier hunt the spider (maybe as a separate style or pluggable trick)
	otherwise it demonstrates how inefficient scrollbars are, as a UI element
this is a good idea though: easy way to make every scrollable area draggable with inertia
demo: jedi librarians betting game (assisted), to see how this all works in 2D games, and as a template
optimize `translate 0x0`
hints (tooltips) for everything, pluggable
demo: better console, extensible, paragraph-oriented
scrollbar should work as a separate space too (e.g. influence some external value)
demo: infinitely zoomable table, each cell is the table itself
	will require limiting rendering depth (or < 1 pixel size), so it won't stackoverflow
	and resetting the zoom, else we'll hit that depth sooner or later
	and rotating slowly, for total mind blow - gonna need `clip [circle ..]` to be the clipping region of rotor
truly rich text widget - where text is mixed with other (interactive) spaces
rename grid-view to data-grid?
demo: debugger, need to mark functions, store values of all words during last iteration or 2-3 last iterations,
	and be able to explore those (where spaces come to help)
demo: round lists (like in games or sketchbook) - showing the power of container/layout
splitters for UI panels
inspect https://nicepage.com/nicepage-review for anything useful
allow size to be an integer in `field` - so it will infer height automatically from font and adjust it on the fly
demo: very basic layout designer for simple webpage-like shite, one others should be able to build upon
    good example: https://discuss.streamlit.io/t/dynamic-grid-layout-ui/2097
multi level popup menus (probably on separate borderless windows)
demo: example of a glossy style sheet
`arrange` func based on flow layouts that will work with faces?
web preview component to preview the links in the chat
widget: markdown renderer (unless Bolek adds it)


key aspects: draggable columns, row span, rearrange by styles (and styling DSL?), sizing model

QUIRKS

`into` allows to twist coordinates in any way, e.g. meaningfully react to clicks on a rotated/flipped face
	it's also simpler than hittest, so only carries the space's own logic, without duplicating generics
`map` and `into-map`, as well as caching of coordinates in `map`:
	- avoids duplication of the most widely used logic in each space
	- makes hittesting faster because of the cached offsets/sizes
	however `map` shouldn't be relied upon! `into` is the proper way to translate coordinates
	(e.g. think of non-rectangular or rotated areas)
`map` can't be of type `map!` because it should be ordered (e.g. for tab navigation) (can be a hash though!)
map names don't have to be unique (e.g. list may have 1000s of `item`s), just traversable
	but each of it's names has to lead to a unique object
	(unique names help working with each map item though, using path notation)
map/space/size <> space/size -- 1st is in parent CS, 2nd is in child CS (and may also be rotated/translated/...)
name (in a map) is not an identifier (unique) of a space, it's the class! e.g. `hscroll` is a class of horizontal scrollbars
	(however since name is bound to an object it's also an identifier under the hood)
content is a word!
	we want 'content' to appear in styles (and consequently in 'path') so we can process events for 'content'
	but we also want the space it refers to to appear in styles, for that style must process it's own events
	e.g. table inside scrollable - both scrollable/content and table are focusable and handle keys differently
	it's a bit of a special case though.. but it guarantees that inner item name won't clash in map with other names
	(in other words, we can't just put style name into map)
	however, can we maybe just define the events block for each space?
	at least we won't have to look for it..
	but if we do, we'll have to wrap generic spaces and replace events inside
	no... content+name looks cleaner to me
since no space knows it's parent, same space can be used multiple times in the tree
scrollable-space supports `draw/only xy1 xy2` for it's content - to minimize rendering effort by preemptive clipping
lot of parts in space become valid only after it's drawn (couldn't be any other way), e.g. it's map
style! could easily have been a kind of space! that wraps any other space, but it shouldn't be as:
	- that would mix functionality with styling
	- will be harder to change styling
	- styles will appear in the path
	or not??? ok bigger problem:
	- will have to sync style size with content size all the time
	  (can't be done from inside content, so how else? manually? or we resize style that resizes content? stupid..)
there are 2 ways styling can be applied:
	1) each space applies it's own name
	2) parent space applies names from it's own map
	2 has a drawback: e.g. scrollable-space doesn't know the type of it's content, so generic style applies
	then if we put thing into scrollable-space this thing loses it's style, and this is shitty
	but 2 has a benefit too: we can change inner parts without worry, styles will still apply
	e.g. think of scrollbar's thumb - it's a rectangle under the hood but we wanna style it as thumb
	solution? allowing a `style: 'name` field for spaces, which would override `content` generic name
	dumb? or will work?
funny thing about paths: example - we have 3 list-views on a window (a, b and c)
	- from styling POV they should all be called `list-view`
	- from focusing POV they should be `a`, `b` and `c` (i.e. unique)
	  this distinction applies only to faces, not anything inside (yes? maps provide enough uniqueness?)
	  also `root` should be parent to them all
	  ps. solved: faces can carry the name of their type but they're unique objects
	  however, styling faces differently will require some understanding
why keyboard/focus has to be a *deep* path containing focused face along with *all* of its parents:
	tabbed navigation can be done in 2 ways:
	- geometrically by finding nearest item along the path (but this is so called spatial navigation)
	- by finding next/prev node in the space tree
	  but this requires us to be able to transcend limits of one container and traverse all that is shown
	  (even other faces, so we need a parent that holds all space-hostin faces)
	it doesn't have to bother with names though (like content vs list, etc)
	as we're using it to navigate the tree only, so as long as each item leads to an object it's good
	(it could be just an object but then we won't be able to mold this path, easily)
focus is not selection:
	multiple lists can be shown with a selection (maybe multiple) but only one list has a focused item
	so to minimize code duplication and simplify styles we need `focused?` and `selected?` flags in styles
	`selected?` will be a property of `list`, while `focused?` is a global flag (func or logic)
what is root?
	for tabbing, we need to be able to focus both faces and spaces
		so naturally screen is the root for windows, then faces, then spaces
		so keyboard/focus should begin with a screen object
		(need to wrap those objects into words as [screen window face only then spaces] for mold friendliness)
		for styling however, we don't need screens or faces, `root` may refer to the (any) host face
		or should we assign a name to each host face and root will be parent to them all?
		it depends if we wish to style each host differently? no reason so far..
		besides, when one needs it, one just creates a container space with a `style: name` and addresses as root/name/...
		@@ rename root to host? or to face? for clarity
		@@ describe in docs how to style each host face differently
		for hittesting we want coordinates obviously, but what names?
		hittest has to be forceable (repeatable) so wee choose names from maps
		but root? screen? for compatibility with focus? probably no other point, could just start with the host
		[host space space ...] + coordinates (besides we can't translate into screen coordinates w/o R/S, and it's unneeded work)
	do we want tabbing across different windows of the same app?
		I think we do
		that means `keyboard/focusable` has to start with screen or list of screens
	do we wanna tab and scroll to hidden items?
		I think not
		e.g. scrollable [ 
			edit-box
			..1M edit boxes..
		]
		if we (on Tab) show next edit box that's 1M of them to traverse to get out of the `content`
		one will sooner die than finish this quest
		if we just allow skipping to the scrollbar however,
		one can just scroll one page down and tab back into edit boxes and this just works
		partially clipped edit box is still a corner case: we may wanna show it fully
		also, we certainly don't wanna tab to hidden panes of a tab-panel
pros and cons of each styles layout:
	item/subitem another/subitem [style..]       -- currently chosen
	 - have to be traversed once for each item in the path (which is 5+ items long)
	   because absense of 'subitem' in table doesn't guarantee absense of 'item/subitem'
	 + allows style grouping
	 + faster than other styles despite the extra work done
	upper item subitem [style..]
	 - requires another inner loop to ensure that when we look for `item` we don't also find `item subitem`
	 - styles can't be grouped
	 + no confusion on words vs paths, no `to path` or `as path` conversion needed
	 + finding `subitem` automatically finds `item subitem` and upper layers, but still slow (2-5 times)
	   parse can be used but it's even slower still (4-10 times),
	   and parse requires escaping each word in path (as lit-word)
event handlers are separated from space objects for:
	- memory efficiency: one event handler can serve multiple spaces
	- cognitive convenience: separation of code from data and structure from behavior
	- ?unsure? ease of extension: one handler can easily pass data into another (e.g. one that's overridden)
events are passed to the topmost layer that can handle them
	because upper layers have the whole context of how they are using their inner spaces, but not vice versa
	and lower layers may be used with or without upper layers, so they can not produce to the point results
	(at best they can just provide some better abstraction over event data, but most likely it's just dead code)
trickiness of keyboard focus and tabbing:
	e.g. we have layout: scrollable-space [content = list [edit-box ...] hscroll vscroll]
	we want:
	- h/v scrolls to handle keys separately (up=left, down=right, meaning defined by each scroll bar)
	- whole space to react to keys (page down/up, up<>left, down<>right)
	- spaces inside the list can be focused too, e.g. edit-box would handle keys on it's own
	so, focusable face can be a parent to another focusable face
	and we need to consider that during tree traversal,
	and also when assigning the focus - last space in the path is the one focused
	also: for 'content' to be focusable it is imperative that `focus` uses proper style names
there is not space geometry before it's drawn, no size no nothing, because what isn't drawn isn't existing
	and it makes sense, as we want animations and space may be moving in a complex way
	each frame of such move determines different geometry and reacts to events (like clicks) differently
following REP#80, event handlers return values do not control event flow,
	but their bodies are bound to commands that do
iteration over spaces
	there are 2 directions:
	- top-down from the root to the leaves, or bottom-up
	- forward from one leaf to adjacent leaf, or backward
	for tabbing to work properly we want fully reversable order
	i.e. if tab iteration is top-down forward, then shift-tab is bottom-up backward
	for this, listing a tree seems like much easier approach than recursively visiting nodes
unsolved problems of `content: 'name` design:
	to get content/size: `cspace: get content  cspace/size` is a bit complicated
	name changes in the map itself, which may theoretically lead to name collision (and I'm using path access)
reasons not to define `style: ... events: ...` in every space:
	want styles to be an isolated layer, so who defines styles does not have to poke around objects
	want styles names to be composite, like `this-space/that-space`,
		which is harder to map onto objects (and way harder to track after)
	objects can be numerous (= numerous links), while style is defined only once, so it saves some RAM
we need to use fonts in styles, as well as any other thing that may affect space's `size`
	including setting size directly from the style..
	this is all fine when styles are shallow, but what about deep ones?
	we have to somehow apply the tree of styles before `size` is called
	tricky thing: what if size is random or depends on time?
	then whatever we do, `size` and `draw` will not align
	unless we make `size` only available after `draw`... until the next `draw`...
why event handlers should be referred to by paths:
	example:
		item/subitem has handler: sub-item/on-event: [..if path/-1 = 'item .. [do smth]]
	this handler can't be copied into a new style,
	because `path/-1 = 'item` will not produce anything good
	if we however copy the whole tree of handlers, `path/-1 = 'item` is not needed at all
	and we become able to copy handlers together with the space tree
	as such we probably should allow simpler, literal, copying of events:
		events/handlers/item/subitem: 'item2/subitem2
handlers extensibility
	we will want some handlers to control visual behavior and be embedded into the lib
	while other handlers will be written by the user and follow user's logic
	how do we allow both to coexist?
	and how to simplify the extension of one style by another?
	actors should be lists?
	if so, what defined first should fire first
	but how to override? do we want to override?
	there may be levels, like lib-level and user-level, both with multiple handlers..
dynamic size vs draw/only
	it makes little sense to redraw possibly infinite number of invisible items of a list
	however if their sizes change, we can't know until we draw them
	so what to do? obviously we can't draw all the items (performance-wise)
	so it should be advised to re-render those items which size changes, before showing the list
	(TODO: document this limitation)
pinning
	list-view should support some pinned items
	but list is who renders those
	yet list is refilled with items from some offset, not from the head
	so is this even worth it to make list and list-view logic so complicated?
	vs just creating 2 lists, one pinned, one normal?
	scrollbar will be different: will span either the whole height or only of normal items
	2nd option is preferred: more natural
table structure
	2 grids with pinned rows?
	4 grids?
	we want pinned columns to have pinned headers and scrollable
	we want scrolling to be synced vertically, and horizontal scrolling only for the unpinned columns
	how to sync col/row widths?
table column order
	we can rearrange columns by dragging the UI
	and we don't rearrange the data, nor we should expect user-defined data pickers to all support ordering
	we rearrange the visual representation only
	so we should have an order defined in the UI itself: e.g. [2 6 1 5 4 3] (indexes may or may not exist)
	order will act as a simple filter too: what isn't present - isn't shown
	rearranging rows OTOH should be a change in the data, so should not be covered by UI... I think
headers - data or special value?
	I think table should provide a generic interface,
	and picker function should decide if row=1,2..etc is a header string or part of original data array
funny observation about table long/infinite in both directions (x and y):
	it will be impossible to infer row height, because we'll have to scan the whole (infinite) row every time
	without it, rows height will depend on what items are actually shown right now (i.e. where the scrolling window is)
	and rows height will jump around while scrolling left and right
	so such layout is only possible for fixed-size cells, or at least fixed-size row heights
hittest design shows that inner spaces should be named by their styles, not as generic `content`
	though that means that map has to hold those proper names as well, otherwise `hittest/force` isn't going to work
	proper style name is also required for `focusable` block
map: block or hash?
	list style has numerous `item`s which is bad for hash
	and lookups in a map should only be useful for small maps anyway
	so block wins
events chain: still undecided
	e.g.
		list-view
		list-view/hscroll
		          hscroll
		list-view/hscroll/thumb
		          hscroll/thumb
		                  thumb
	if list-view/hscroll takes event, and calls `pass`, should `hscroll` also receive it or only `thumb` variants?
	I think it should, because if specific handler didn't eat the event, generic one still can
logarithmic scroller
	problem of infinite space is that to know it's size we need to render it fully at least once
	otherwise scrollbars won't know how big the current viewport is within the whole
	but since it's infinite, we can't render it
	this is solved by list-view which makes itself a finite view on an infinite space
	and list-view's scrollbar doesn't map to infinity because of that
	but can scrollbar map to infinity? is this possible?
window inside scrollable: how generic it has to be
	one of the applications (apart from chatlog & table) is plot f(t), e.g. timeline of some exchange rate
	it can be huge and instead of rendering it fully (and making scrollbar uselessly imprecise)
	it makes sense to render only a window
	it remains to be seen how to make the plot interactive though
how to contain infinite-scrollable within content limits?
	ideally should be animated: e.g. scroll up, show some empty space, then realign during 0.5sec
	suggestion: let window have some empty space, but scrollable will contain itself using some replaceable algorithm
	however, then scrollbars will not look like they're at the head..
	`available? <direction> <max-lookup>` query func before offsetting?
	then window stays within available limits, but scrollable can optionally scroll itself out then animate
in grid layout, should row/columns sizes be a map or a vector?
	map makes sense because human can only configure a limited set of sizes manually (and prefers it to be less)
	so if one resizes 100000-th row only, map is tiny
	OTOH, if we want fast access to any i-th size, map is a hash lookup, while vector is a direct access
	benchmarks to the rescue: vector access is 90ns, map - 110ns (map miss is 90ns), so given map's other benefits, it wins
	in the future when we have native `sum`, vectors may still win when we want to get continuous sum of sizes
is it possible to auto infer row height in grid mode?
	clearly this case is a problem:
		|  |  |  |  |
		|  |  |  |  |       <- what height is this row? (if all it's cells have vertical span)
		|__|  |  |  |
		|  |__|  |__|
		|  |  |__|  |       <- this row is bound by one cell's span ending at it
	the idea for the 1st is to either:
	- make such row 1/N if it's 1st cell span is MxN
	- use smallest span cell instead of 1st (but why?)
	so, inspecting row cells from left to right:
	- if a cell has Nx1 span - skip next N-1 cells, and add it's height to constraints list
	- if a cell has NxM span, but doesn't end vertically after this row - ignore it, and skip N-1 cells
	- if it does end vertically on this row - subtract all previous rows from it's height and add result to constraints
	- if constraint list is empty, use 1/R of the 1st cell, where R - cell vspan minus rows above
	  (not sure, 1st or the closest rowspan below..)
	  still an issue: can lead to 0-height rows if below cells are empty (content ended)
	- so instead of 1/R it would be better to have a min-height constraint (and simpler)
another problem with span
	how to know which cell occupies XxY row/col?
	have to traverse the whole span map to ensure no other cell above has span big enough to include this cell
	so spanned cells should have span=0x0 if they belong to other cells above or to the left
	or better if they have a link to the starting coordinate
	idea: use negative span to point to the beginning of the multi-cell
	it aligns with the rule that any cell can only be occupied by a single multi-cell
	and then we can occupy & deoccupy it using some helper functions
yet one more gotcha about height cache
	calling `draw/only xy1 xy2` it makes sense to leave rows out of the viewport cached
	that is - to only calculate the size of rows we're actually about to show
	yet, to locate on which row xy1 point maps, we have to use the cached height of that row (and all those before it)
	we could invalidate caches of visible rows in advance if we knew what their numbers are, but we don't
	so the only reasonable solution (not considering full cache invalidation) is..
	to not invalidate the cache at all and let data modifying functions take care of it
	this means that if styles affect the size of the cell on each render,
	it won't be reflected unless those styles also clear the cache
	(such inertia is still a lesser evil than the absence of caching)
	render cache OTOH should be always invalidated as cells are likely going to be animated
how big is the grid layout? is it infinite?
	it'll be easy to limit it with integers
	but is it possible to infer the size from `cells`?
	if it's like 10 items long - easily, if it's 100k - a problem
	should show a warning in this case
	another issue: if it's infinite, how to `draw` it?
	ok so it HAS to be finite, and limit can't be none (but can be auto)
	then inf-scrollable can make it infinite.. but...
	in case row height is 'auto - it may resize itself while scrolling
should grid space contain origin and implement pinned row/col logic?
	normally I would let origin be handled by scrollable
	however, scrollable cannot pin cells without rewrite of the draw func
	so it seems more work.. although we'll see
layout of styles
	1. style: [prefix draw commands] closure: [postfix draw commands]
	this is limited! example: space created during draw of it's parent (one-off space)
	if style gets called before `draw` - it cannot know it's size because it's not rendered
	if it gets called after - then it can't influence draw (set font, rearrange stuff, etc)
	oops... but then it's 2 renders: one to get the size, another to let style influence it
	and then there's a discrepancy: style may have influenced the size, so it wasn't valid on the 1st call
	2. new idea - object:
	style: [
		init: [prefix draw commands]
		done: [postfix draw commands]
		render: function [] [compose [(init) (draw) (done)]]	;-- full pipeline that controls the order of style application
		font: ...
		other words to set in the space
	]
	with an alternative form - single block: style: [[prefix draw commands]] (as it's the most useful)
	an object will be created out of it, space set to it, then ??
	what about `self`? it should be bound to the space, not style
	has a problem! while bind body-of style binds blocks, it can't bind the function!
	if we make function a block - it will leak words...
	recreating an object with functions - too heavy, not acceptable
	3. collect words of style, set them to words of space, then bind is not needed
	but then if we call `draw` for example, draw drags some words from the space
	and bigger problem: some words are global but will be overridden..
	won't work
	4. let style contain only blocks, but compose them in the order they were defined
	then we have binding, ordering, and it's not heavy
	drawback is that styles will have no defaults, and will have to define everything they are using
	another: dynamic assignments are ugly: `before: [(font: ... ())]`
	instead of just `font: ...`
	@@ perhaps paren should be reserved for this.. e.g. `font: (...)`
	but then it requires custom constructor, not just `object`, and thus limits styles in it's own way
	why not just single styling function? it will be given space as an argument
	access to draw - check, custom eval order - check, minimum allocations - check, simplicity - check
	win!
grid cell background - how to draw?
	1) draw grid background => each cell background => each cell contents
	problem: when row height = auto, we don't know the cell/row size in advance
	so we need to render the cell first, but we can't draw it's background not knowing the size of it
	catch 22
	2) draw grid background => each cell contents => draw grid lines
	this way when drawing grid lines we already know the size of each row, so it's ok
	and actually less drawing commands.. M + N rather than M * N
	drawback(?): cells without content look like cells with empty spaces, no distinction
	huge drawback: grid lines will be drawn atop the multi-cell content - inacceptable
	3) so, we need to render cell content first, then estimate row size, then render cell itself
	how? grid lines are a way to hell here..
	maybe.. we cache the cell contents drawn cmds, to eliminate double render
	then: grid bgnd => each cell content => each cell bgnd => each cell content (cached, box sized, alignment applied)
focus has to consider sameness of each path item
	e.g. grid/cell -> other grid/cell look the same but differ in pointed to objects
grid/cell/space vs grid/space - which is better?
	initially cell style was introduced to draw cell background and see it's bounds
	but cells are volatile, and it's better to include them into map
	but do we always want that?
	grid may be used to position other spaces on the layout, not just data, and in that case no need to draw cell boxes
	* cells may help with alignment - global sizing system will work out of the box
	  without cells I would have to do alignment in the grid code, which is bad
	* one of the questions - if the grid is huge, do we want `cell` space for every empty cell?
	  although, most likely if the grid is huge - we either have the data, or *want* to draw cells (like spreadsheet does)
	  will have to ensure only visible cells are in the map - but this may still be a lot, to cover whole `window` of scrolling
	* cells may help with interactivity - in case one wants provide events for cells even if they have no data
	* maybe I could make an option controlling whether to wrap into cells or not..
data & cell wrappers: wrap-data & wrap-space
	are incompatible with the focus model that expects focusable spaces to remain the `same?`
	we can spawn spaces on the fly only if we cache and reuse them for the same visual UI element
	that applies to list items and grid cells
	so cache is the only solution, but it may become huge
	although to keep it small - we could destroy items that were hidden by scrolling
	scrolling out of the sliding window or out of the view?
	defocusing items on scroll is bad UX, so the answer is out of the window
	;@@ TODO: update list-view with window-local cache
	so there's a cached space per each cell - should it be removed when span changes?
	if cell gets eaten by a multicell it automatically disappears from view, so doesn't matter there
	if cell becomes a multicell, it may retain focus, why not
	so no need to destroy cells, but only mark them for full redraw (if that is required)
grid cells array models
	1) cells = map
		supports limits=auto:
		possible to just add cells into the map and limits are inferred
		when mapping data into grid, cells must be filled with a space for each data point
		(if data is truly infinite, will be impossible to fill it)
	2) cells = picker func [/pick xy /size] (that picks from a map by default)
		/size has to infer it from the map itself
		possible to pick from an infinite data array
		no need to pre-fill cells spaces, can be done as they are rendered (but should be cached)
		works for truly infinite data - best argument in favor of it
tricks of grid containing itself in each cell
	draw-ctx and ccache can (and should) be shared between inner and outer renders
	and should only be invalidated before the outermost render
	no static lists should be used in draw
list-view's list width - how to infer it?
	let it be locked to list-view's width?
	there's no width for an infinite list
	and adjusting width to a range of visible items is not great UX-wise
	(scrollbars will show and hide while scrolling)
	but it needs more thought.. esp. when I decide on sizing system
	maybe this will help autosize items' content
on resizing
	some spaces' dimensions are fully automatic - list, data-view (unless limited), image (in auto mode)
	some have only one dimension automatic - tube, paragraph (unless width = none), grid
	some have only fixed dimensions - all scrollables, image (in fixed mode)
	let's call all these fixed dimensions "free dimensions"
	free as in "no inner constraints imposed" and "can be modified freely at any time"
	automatic are the constrained dimensions out of user's control
	ways to deal with free dimensions:
	1 use plain reactivity (very boring and clumsy way)
	2 define more high-level relations in terms of filling space and aligning in it
	  (also if defined as a function of time they become animations)
	3 use containers that will align/fill themselves with the inner space
	  this is less flexible than pure relations, as only limited to parent/child sizing
	  also floods the space tree with unnecessary entities (=> noise and slowdown)
	so best option seems to build a DSL on top of reactivity (2)
	OTOH some might expect predefined containers (3), esp. interactive ones,
	  e.g. splitters (2-4 panels divided by a draggable delimiter)
	  ? grid columns (draggable slim inter-column patch, inter-row too)
	    key here is that columns are not objects, their widths is part of a map (which is not reactive at all)
	    can be solved by using hash instead, but dealing with /skip is a headache (`map: map` is a lesser evil)
	  columns that fill available space (splitting it using weights) - not interactive, but can be (changing weights)
	what's also useful is expressing sizes in relative terms: window as part of the screen, widgets as part of the window
	and another thing to consider is how to export all this so it'll work on faces too
	  maybe a DSL that creates reactive relations from a description?
	1 more consideration: such free sizes may appear and disappear on the fly, e.g. alignment within visible cells
	  though that can be left to grid itself
	on-resize can be useful to adapt the layout to size, or when rotated
	  some use case: https://egghead.io/lessons/angularjs-angular-material-adaptive-layouts
	  basically, things to show and things to hide (instead of just resizing)
	  though it can be done simpler, by injecting a set of conditions into draw - to select which items to show
	DSL sketch:
	constrain [
		a/size/x -> b/size/x -> c/size/x
		a/size/x <-> a/size/y
	]
	creates 4 separate reactive relations:
		b/size/x: a/size/x
		c/size/x: b/size/x
		a/size/x: a/size/y
		a/size/y: a/size/x
	ideally, but in reality this won't trigger reactivity, so it should change `size:` every time
	constrain [
		split a [10% 100 20% *]		-- can be applied to lists, `*` = rest, `none` may mean "don't touch"
	]
	but this thing can be just added into list itself
	although then list will have a fixed size, so let's call it fixed-list or smth, maybe chain or stack or spring..
	question is, what to do with opposite direction? fill or leave?
	presumably, cases with split should all fill it
	gonna need to make a few UIs first, then try to apply this model to them


Timer design:
- we want to maintain the desired frequency of updates (otherwise every animation/game will be CPU dependent)
  but at the same time we don't want to lock execution in a single timer when it takes longer to process than it's period
  so we have to be able to drop events but since this affects the animation, a warning should be printed
  and we want to be able to disable those warnings for production code
- on a W10 laptop in battery saving mode face timer never repeats in less than 14ms, but usually it's 14-30ms
  but if we use `wait 0` as yield func, we never get intervals more than 15ms
- in performance mode timers are still 65 fps, so are `wait 0` granularity
- will need multimedia timers for anything more precise, or at least will need to set system timer to 0.5ms interval
  (that's 2000 fps compared to current 65 fps)
  this will increase the power consumption though (from what I read on the web)
- so there is very little point in doing our own event loop, just to improve the fps by a negligible effect
  and for now just using `rate 100` dispatcher should be good enough
- yet we can improve the animation by providing the delay to timers
  e.g. desired rate = 50fps = 20ms, if 30ms have passed that's 50% delay, if only 10 then that's -50% delay
  (0% would mean a perfect match)
  then one should scale the animation to that delay
  or 100% would be perfect match, 50% for 10ms, 150% for 30ms? it's a question of `dt` vs `dt - 1`
  depends on the argument name also, if it's `delay` then `dt - 1`, if it's `scale` then `dt`
- this will require a table of all timers' last trigger time
- how to determine *when* to call a timer handler?
  e.g. host has rate 67 = 15ms, and child has rate 30 = 33 ms
  if we only call the timer *after* the guaranteed 33 ms, we will get really 45 ms
  so it makes sense to call the timer before it expires, like up to 7ms before? half of the host resolution
  no that's bad.. rather we should accumulate bias and try to minimize it...
  OK it works up to 64 fps, where timer is slower than the desired fps...

MUSEUM
this is bad because it mirrors the code from draw
; into: function [xy] [
; 	any [
; 		all [within? xy 0x0 box  reduce [content xy]]
; 		all [box/x < size/x  within? xy o: box * 1x0 vscroll/size  reduce [vscroll xy - o]]
; 		all [box/y < size/y  within? xy o: box * 0x1 hscroll/size  reduce [hscroll xy - o]]
; 	]
; ]
; into: func [xy] [
; 	any [axis = 'x  xy: reverse xy]
; 	all [
; 		within? xy 0x0 size
; 		any [
; 			all [xy/x < back-btn/size/x  reduce [back-btn xy]]
; 			all [xy/x >= (size/x - forth-btn/size/x)  reduce [forth-btn xy - (size - forth-btn/size * 1x0)]]
; 			all [xy: xy - (1x0 * size * offset)  xy/x >= 0  xy/x < (size/x * amount)  reduce [thumb xy]]
; 		]
; 	]
; ]

this is bad because it doesn't build a map, and consequently we can't hittest against the map
; (back-btn/draw)
; ; (put items 'back-btn 0x0  back-btn/draw)
; translate (map/thumb/offset: o: back-btn/size + (stripe * offset) * 1x0) [
; 	(thumb/draw)
; ]
; translate (map/forth-btn/offset: back-btn/size + stripe * 1x0) [
; 	(forth-btn/draw)
; ]

this can't work because of #4788
; cached-length: none				;-- set to none when it's out of date
; on-deep-change*: function [owner word target action new index part /extern cached-length] [
; 	;@@ TODO: more actions
; 	;@@ BUG: on-deep-change is a mess, totally useless
; 	;@@ e.g. take/last - reports index=0 and series at head, so how to figure out the changed part?
; 	nitems: length? items
; 	case [
; 		none? cached-length [exit]				;-- nothing to modify
; 		word <> 'items      [exit]				;-- it's not items that changed
; 		any [
; 			'cleared = action 
; 			all [part * 3 > nitems  nitems > 10]	;-- part is too big: better recalculate size normally
; 		][
; 			cached-length: none  exit
; 		]
; 		find [appended poke poked] action [
; 			target: skip target index
; 			+-: :+
; 		]
; 		find [inserted remove take cleared change changed] action [
; 			+-: :-
; 		]
; 		'else [do make error! "TODO: unsupported-action"]
; 	]
; 	partlen: 0
; 	repeat i part [
; 		item: get target/:i
; 		item-size: item/size
; 		partlen: partlen + item-size/:axis
; 	]
; 	partlen: partlen + (part * spacing/:axis)
; 	if part = nitems [partlen: partlen - spacing/:axis + (2 * margin/:axis)]
; 	+-: either find [inserted appended changed] action [:+][:-]
; 	cached-length: cached-length +- partlen
; ]

consequently this becomes too slow...
; cut-items: function [
; 	"remove items until list size is within constraints"
; 	where [word!] "head or tail"
; 	limit [integer!] "enforce min number of items to keep"
; ][
; 	items: content/items
; 	len1: get-length
; 	num1: length? items
; 	cut-one: select [head [take items] tail [take/last items]] where
; 	while [all [limit > 0  not within-limits?]] [
; 		limit: limit - 1
; 		do cut-one
; 	]
; 	len2: get-length
; 	num2: length? items
; 	reduce [num1 - num2  len1 - len2]
; ]
; within-limits?: function [] [
; 	len: get-length
; 	num: length? content/items
; 	all [len <= max-length  num <= max-items]
; ]
; get-length: has [size] [
; 	size: content/size
; 	size/(content/axis)
; ]

on-deep-change is no place for list refill, cause such thing becomes hard to control & predict
; if all [word = 'origin  source  content/items] [
; 	if case [
; 		;@@ TODO: where to hold this 200ms delay? where to enforce it?
; 		;-- one can click 'page-down' faster than 200ms and get to the end unnoticed, but 100ms - unlikely
; 		;@@ TODO: this means this delay has to be ONLY in on-over, but how?
; 		;@@ also it's bad to have origin auto changed (breaks code continuity) - better to have it on demand
; 		0:0:0.100 >= difference t: now/precise last-refill-time [no]
; 		origin/y >= (0 - look-around) [
; 			;@@ TODO: add-items/cut-items should happen inside draw, only planned here
; 			set [add-n: add-len:] add-items 'head jump-length
; 			cut-items 'tail add-n
; 			set-quiet 'source skip source 0 - add-n
; 			origin/y: origin/y - add-len
; 		]
; 		(csize: content/size clen: csize/:axis) - (map/content/size/:axis) + origin/y <= look-around [
; 			set [added:] add-items 'tail jump-length
; 			set [cut-n: cut-len:] cut-items 'head added
; 			set-quiet 'source skip source cut-n
; 			origin/y: origin/y + cut-len
; 		]
; 	] [set-quiet 'last-refill-time now/precise]
; ]

scaled triangle doesn't play well with styles including an outline
; triangle!: make space! [
; 	size: 16x10
; 	dir: 'n
; 	; need `into` here? or triangle will be a box from the clicking perspective?
; 	draw: function [] [
; 		set [p1: p2: p3:] select [
; 			n [0x2 1x0 2x2]								;--   n
; 			e [0x0 2x1 0x2]								;-- w   e
; 			w [2x0 0x1 2x2]								;--   s
; 			s [0x0 1x2 2x0]
; 		] dir
; 		compose/deep [
; 			push [
; 				scale (size/x / 2) (size/y / 2) [
; 					triangle (p1) (p2) (p3)
; 				]
; 			]
; 		]
; 	]
; ]

items in list's map do not have to have different names, as this requires too many words
and it also messes the map up when moving items around (e.g. in add-items 'head)
still, we need each `item` to refer to a unique object so we need context to wrap it (unless we drop names)
sadly (#4165) find/same word doesn't work, but there doesn't seem to be a need for it anyway
; add-item: function [] [
; 	p: make paragraph! []
; 	o: object compose [(to set-word! rejoin ["item" 1 + length? content/items]) (p)]
; 	append content/items w: first words-of o
; 	w
; ]

slower 2-3 times on error than the all [] approach
; focused?: function ["Check if current style is the one in focus"] [
;	attempt [(get last path) =? (get last keyboard/focus)]

version for styles like [item subitem [style]] - slower 5x
; get-style: function [
; 	"Fetch styling code for the current space being drawn"
; 	/named path [path! block!] "Path to look for (defaults to current-style)"
; 	/closing "Fetch a closure instead"
; ][
; 	path: tail as [] either named [path][current-style]
; 	#assert [not head? path]
; 	; if head? path [return []]							;-- empty path
; 	c: [
; 	table: either closing [closures][styles]
; 	; table: find table path: back path
; 	; unless table [return []]							;-- no such style
; 	attempt [			;-- stops when find/tail fails
; 		until [												;-- look for the most specific fitting style
; 			;-- search order here: from the space name (most common) to it's full path (most uncommon)
; 			;-- to eliminate the number of failed lookups (performance)
; 			p: back path
; 			t: back table
; 			until [block? first t: find/tail t p]
; 			style: t/1
; 			table: skip t 0 - length? p
; 			head? path: p
; 		]
; 	]
; 	]
; 	either 'hscroll = last head path [clock/times c 100000][do c]
; 	unless style [return []]
; 	; style: select table path
; 	#assert [block? style]
; 	space: get last path								;-- need to expose it's context to the style
; 	; print ["style for " head path "is" style]
; 	compose/deep bind style space			;@@ how slow this bind will be? any way not to bind?
; ]

version for styles like [item subitem [style]] but using parse - slower 10x
; get-style: function [
; 	"Fetch styling code for the current space being drawn"
; 	/named path [path! block!] "Path to look for (defaults to current-style)"
; 	/closing "Fetch a closure instead"
; 	/local style
; ][
; 	table: either closing [closures][styles]
; 	path1: as [] either named [path][current-style]
; 	#assert [not tail? path1]
; 	space: last path1
; 	c: [
; 	path: clear []
; 	parse path1 [collect into path any [set w word! keep (to lit-word! w)]]
; 	append path: tail path [set style block!]
; 	until [
; 		path: back path
; 		any [
; 			not parse table [to path to end]
; 			head? path
; 		]
; 	]
; 	]
; 	; #assert [block? style]
; 	either 'hscroll = space [clock/times c 100000][do c]
; 	unless block? style [return []]
; 	space: get space								;-- need to expose it's context to the style
; 	; print ["style for " head path "is" style]
; 	compose/deep bind style space			;@@ how slow this bind will be? any way not to bind?
; ]

looks much less obfuscated using `with` and `map-each`
; context [
; 	w: table: none
; 	foreach table [styles closures] [						;-- replace words with paths
; 		parse get table [any [change only set w word! (to path! w) | skip]]
; 	]
; ]

update command should not exit from the event handler
; update: does [throw/name 'update 'event-command]

doesn't work because of #4802
; actors: [
; 	;-- using lightweight wrapper instead of the direct link to :event/dispatch
; 	;-- for actors will be copied at some point and we want as little footprint as possible
; 	on-down: on-up: on-mid-down: on-mid-up:
; 	on-alt-down: on-alt-up: on-aux-down: on-aux-up:
; 	on-dbl-click: on-over: on-wheel:
; 	on-key: on-key-down: on-key-up: on-enter:
; 	on-focus: on-unfocus: func [face event] [events/dispatch face event]
; ]

moved this into the proper event handlers, became less messy
; on-down [
; 	; events/dispatch face event
; 	set-focus face
; 	path: hittest test event/offset
; 	?? path
; 	;-- keyboard support
; 	path2: parse path [collect any [keep word! | skip]]
; 	while [not empty? path2] [
; 		either find keyboard/focusable last path2 [break] [take/last path2]
; 	]
; 	unless empty? path2 [keyboard/focus: path2]
; 	?? keyboard/focus
; 	;-- scrolling support
; 	either where: any [
; 		find path 'hscroll
; 		find path 'vscroll
; 	][
; 		axis: select [hscroll x vscroll y] where/1
; 		ss: get where/-2
; 		drag-in: none
; 		move-by: :scrollable-space/move-by
; 		switch where/3 [
; 			forth-arrow [move-by ss 'line 'forth axis  ss/refill]
; 			back-arrow  [move-by ss 'line 'back  axis  ss/refill]
; 			forth-page  [move-by ss 'page 'forth axis  ss/refill]
; 			back-page   [move-by ss 'page 'back  axis  ss/refill]
; 			thumb       [drag-in: reduce [where axis ss/origin]]
; 		]
; 		face/draw: render test 'root
; 	][
; 		;-- not on a scrollbar
; 		if where: find path 'content [
; 			ss: get where/-2
; 			drag-in: reduce [where 'list ss/origin]
; 		]
; 	]
; ]
; on-up [
; 	events/dispatch face event
; 	drag-in: none
; ]

this design is too hard to reverse properly (for tabbing), and is also tricky to get right & to follow
I'm not using an iterator for this is time critical code and iterator would at least double the 'select' count
if we don't do it recursive, we'll have to find where we are on the map every time we wanna get one level up
so it is recursive
no return value for simplicity & speed
`continue` can be used but not break (too much overhead to support it)
; foreach-space*: function [spec [block!] path [path! block!] "(modified)" dir [word!] "forth or back" code [block!]] [
; 	space: get name: path/1
; 	if map: select space 'map [
; 		path: next path
; 		either dir = 'forth [
; 			if name: path/1 [map: find/skip map name 2]
; 			end?: [tail? map: skip map 2]
; 		][
; 			map: either name: path/1 [find/skip map name 2][at tail map -2]
; 			end?: [head? also map map: skip map -2]
; 		]
; 		until [
; 			change path map/1			;@@ do we want to expose geometry to code?
; 			foreach-space* spec path dir code
; 			clear path
; 			do end?
; 		]
; 	]
; 	set spec head change change/only [] head path space
; 	loop 1 code
; 	; clear path
; ]

first space in the `path` determines the root (upmost space in the tree)
foreach-space will jump to other branches but can't go behind it
thus `path = to path! host/space` designates the whole tree as iteration range
`path = some window or panel` designates a root face, iterating only over hosts inside it ;@@ TODO
to limit the scope just shorten the path
iteration starts with the root path (no way around it), then to the first child or first neighbor
/back affects only neighbor iteration direction, but it's still top down always
; foreach-space: func [
; 	'spec [word! block!] "path or [path space]"
; 	path [word! path! block!] "Starting path"
; 	code [block!]
; 	/back "Traverse in the opposite direction"
; ][
; 	foreach-space*
; 		to block! spec
; 		to path! path		;-- makes a copy (will be modified), also forces index to 1 (so `head` will be relative to it)
; 		pick [back forth] back
; 		code
; ]

; scrap design where style name was overridden from the /style facet
; 	it caused too much complexity but was limited:
; 	it required every space to define it's name
; 	but that didn't help, as then every 'back-arrow' and shit would become just 'triangle'
;   background: we don't want events for 'triangle' but may want them for 'back-arrow', so we use map names.
;     but we don't want event for 'content' (generic), we want them to what style 'content' points to.
;     for this to work /style override needs to be defined for every space but this kills the map names; doesn't work

; scrap design where 'content' was pointing to an object
; 	because that required the object to provide it's name somehow
; 	while all we have to do is say `content: 'name` and that solves it all

; scrap design where map had 'content' word that pointed to another word and we would lay out e.g. `content/list` in map
; 	caused too much complexity in `into` functions

now generalized as an event previewer
; refocus: function ["internal use only" face [object!] path [block! path!] "words only (modified)"] [
; 	while [name: take/last path] [			;-- reverse order to focus the innermost space possible
; 		if find keyboard/focusable name [	;-- pairs are not found so skipped automatically
; 			f: face
; 			until [
; 				insert path anonymize f/type f
; 				none? f: f/parent
; 			]
; 			focus: append path name
; 			unless keyboard/focus = focus [
; 				#debug [print ["Moving focus to" as path! focus]]
; 				if all [
; 					old-name: last old-path: keyboard/focus
; 					handler: find-handler old-name 'on-unfocus
; 				][
; 					do-event old-name 'on-unfocus [handler keyboard/focus none]	;-- pass none as 'event'
; 				]
; 				set-focus face
; 				keyboard/focus: focus
; 				if handler: find-handler name 'on-focus [
; 					focus: append clear [] focus					;-- copy it in case user modifies/reduces
; 					do-event name 'on-focus [handler focus none]
; 				]
; 				commands/update
; 			]
; 			break
; 		]
; 	]
; ]

turns out scrollbars don't get focus in all programs I have around..
somehow I think in old versions of Windows it was the case, but apparently not anymore
; focusable: make hash! [scrollable hscroll vscroll]
; scrollable/on-key-down [path event] [
; 	set [ss: scroll:] reduce path
; 	;@@ TODO: keys for the ss itself
; 	unless scroll [pass exit]				;-- let the inner spaces take it
; 	axis: scroll/axis
; 	move-by: :scrollable-space/move-by
; 	code: switch event/key [
; 		down right [[move-by ss 'line 'forth axis]]
; 		up left    [[move-by ss 'line 'back  axis]]
; 		page-down  [[move-by ss 'page 'forth axis]]
; 		page-up    [[move-by ss 'page 'back  axis]]
; 	]
; 	either code [
; 		do code
; 		update
; 	][
; 		pass								;-- key was not handled (useful for tabbing)
; 	]
; ]

it's unwise to prepare the whole data array for display (can be huge)
instead, pickers should be defined to prep lines of data when needed
; spaces/table: [
; 	...
; 	prep-data: function [] [						;-- preps data for display, independent of `source` format
; 		pin: min pinned dim: data/size
; 		prep-into  1x1                  pin                  pinned-headers/source
; 		prep-into  as-pair pin/x + 1 1  as-pair dim/x pin/y  normal-headers/source
; 		prep-into  as-pair 1 pin/y + 1  as-pair pin/x dim/y  pinned-columns/source
; 		prep-into  pin + 1x1            dim                  normal-columns/source
; 	]
; 	prep-into: function [xy1 xy2 tgt] [
; 		if any [xy1/x < xy2/x  xy1/y < xy2/y] [clear tgt  exit]
; 		w: xy2/x - xy1/x + 1
; 		for y: xy1/y xy2/y [
; 			either row: tgt/:y [clear row][append/only tgt row: make [] w]
; 			for x: xy1/x xy2/x [
; 				append/only row data/pick x y
; 			]
; 		]
; 		clear at tgt y
; 	]
; ]

balancing row heights between 2 list-views is just too much effort:
- will have to pre-render to produce list items
- will have to change height constraints of each item in list (can be huge), then render again
- will have to reset those constraints post-render, so next render is not affected
instead, a single list-view should be made with each row supporting pinned columns
; spaces/table: [
; 	...
; 	draw: function [] [
; 		maybe pinned-columns/index: normal-columns/index	;-- sync indexes
; 		maybe pinned-columns/origin: as-pair pinned-columns/origin/x normal-columns/origin/y	;-- sync origin
; 		maybe normal-headers/origin: as-pair normal-columns/origin/x normal-headers/origin/y
; 		; can we get rid of extra render??? need better pipeline
; 		foreach [name _] map [render name]			;-- prerender lists to ensure they all have enough `items`
; 		;-- balance row heights and cell widths
; 		foreach [left right] reduce [
; 			pinned-headers normal-headers
; 			pinned-columns normal-columns
; 		] [
; 			repeat y length? right/list/items [
; 				litem:  left/list/items/:y
; 				ritem: right/list/items/:y
; 				unless all [litem ritem] [continue]		;-- one of the lists is shorter
; 				litem: get litem  ritem: get ritem
; 				case [
; 					litem/
; 				]
; 			]
; 		]
; 		; reset constraints so they won't affect the next render; any better idea????
; 	]

unused
; list-ctx/item-box: function [list i [integer!]] [
; 	if word? list [list: get list]
; 	ofs: list/margin
; 	if i > 1 [
; 		guide: select [x 1x0 y 0x1] list/axis
; 		ofs: ofs + (guide * list/size/only 1 i - 1)
; 	]
; 	reduce [ofs list/size/only i i]
; ]

this doesn't work if word = 'value, silly mistake
; anonymize: func [
; 	"Return WORD bound in an anonymous context and set to VALUE"
; 	word [word!] value [any-type!]
; ][
; 	bind word object compose [(to set-word! word) :value]
; ]

doesn't work if value is a set-word
; anonymize: func [
; 	"Return WORD bound in an anonymous context and set to VALUE"
; 	word [word!] value [any-type!]
; ][
; 	bind word construct/only compose/only/into [(to set-word! word) (:value)] clear []
; ]

didn't use it
; grid-ctx: context [
; 	;-- grid is like list - simply arranges spaces given to it
; 	;@@ should grid/list be called grid/row or not? technically it may be grid/column as well...
; 	spaces/grid: make-space/block 'list [
; 		;-- `items` should contain lists to display, though these lists are not exposed in the map
; 		axis: 'y			;-- items = rows by default
; 		pinned: 0x0			;-- how many rows/columns to pin (move data to the head to make it pinned)

; 		draw: function [/only xy1 xy2] [
; 			;@@ keep this in sync with `list/draw`
; 			r: make [] 10
; 			guide: select [x 1x0 y 0x1] axis
; 			clear map
; 			max-size: 0x0									;-- size of the biggest item in a column/row
; 			i-item: 1										;-- item (column by default) index
; 			p: margin
; ;@@@ SHIT so much useless low level code here! how to generalize? how not to write grid-view after list-view? how to lay out items in one expression?
; 			while [max-size/x >= 0] [						;-- becomes <0 when no more items
; 				max-size: -1x-1
; 				foreach list-name items [
; 					list: get list-name
; 					item-name: pick list/items i-item
; 					item: get item-name
; 					drawn: none
; 					skip?: if only [
; 						unless item/size [drawn: render item-name]	;-- prerender to get the size
; 						max-size: max max-size item/size
; 						p2: p + item/size
; 						isec: (min p2 xy2) - (max p xy1)			;-- intersection size
; 						isec <> max isec 1x1						;-- optimized `any [isec/x <= 0 isec/y <= 0]`
; 					]
; 					unless skip? [
; 						;@@ TODO: style selected-item?
; 						compose/only/into [translate (p) (any [drawn  render item-name])] r
; 						compose/deep/into [(item-name) [offset (p) size (item/size)]] tail map
; 					]
; 				p: p + (spacing + item/size * guide)
; 				p: max p item/size
; 			]
; 			self/size: p + margin
; 			r

; 		]

; 		on-change*: function [word old [any-type!] new [any-type!]] [
; 			if word = 'axis [
; 				if :old = :new [exit]
; 				normal: select [x y x] axis
; 				foreach item items [		;-- dynamically switch each list's direction
; 					spc: get item
; 					spc/axis: normal
; 				]
; 			]
; 		]
; 	]
; ]

tabbing is trickier than expected:
when I move focus in `key-down` to another face (e.g. field)
next `key` event goes to that face instead
so I need to delay focus change until `key` event fires
cannot use `key-up` since it does not repeat
can use `key` directly but will miss Ctrl-Tab, used by field/area
option: use `key`, miss Ctrl-Tab, but let area/field have some 'unfocused' state changed by Esc/Enter
(this will help spatial navigation as well)
; register-finalizer [key-down] function [space [object!] path [block!] event [event!]] [

this didnt scale:
in the end I had to include style name into the definition block,
else define-handlers doesn't have the name and thus can't accept inner styles
also error reporting was inferior
; extend-handlers: function [
; 	"Extend event handlers of STYLE"
; 	style [path! word! map!] "Style name, path or a map of it's event handlers"
; 	def [block!] "A block of: on-event-name [spec..] [code..]"
; ][
; 	all [
; 		not map? map: style
; 		none? map: get as path! compose [handlers (style)]
; 		map: #()
; 	]
; 	#assert [map? map]
; 	r: copy-deep-map map							;@@ BUG: copy/deep does not copy inner maps unfortunately
; 	while [not tail? def] [
; 		either word? :def/1 [						;-- on-event [spec] [body] case
; 			set [name: spec: body:] def
; 			def: skip def 3
; 			list: any [r/:name r/:name: copy []]
; 			#assert [								;-- validate the spec to help detect bugs
; 				any [
; 					parse spec [
; 						word! opt quote [object!]
; 						word! opt quote [block!]
; 						word! opt [quote [event!] | quote [event! none!] | quote [none! event!]]
; 						opt [if (name = 'on-time) word! opt quote [percent!]]
; 						opt [/local to end]
; 					]
; 					(?? handler  none)				;-- display handler to clarify what error is
; 				]
; 				"invalid handler spec"
; 			]
; 			append list function spec bind body commands
; 		][											;-- substyle: [handlers..] case
; 			#assert [not map? style]				;-- cannot be used without named style
; 			#assert [set-word? :def/1]
; 			set [name: spec:] def
; 			def: skip def 2
; 			unless r/:name [r/:name: copy #()]
; 			; name: to word! name
; 			substyle: as path! compose [(style) (to word! name)]
; 			r/:name: extend-handlers substyle spec
; 		]
; 	]
; 	r
; ]


list-view's infinite space logic is now decoupled from the list logic
; ;@@ TODO: chat will need reverse indexing... though how about `source` function gets -1 -2 -3 ... ?
; ;-- there's a lot of logic in this space only to make it fast
; ;-- list items may vary in size, and not knowing the size of each item
; ;-- we can't just multiply the index by some number, we have to traverse the whole list
; ;-- but list can be huge, and all these functions try to minimize the size estimation effort
; list-view-ctx: context [
; 	spaces/list-view: make-space/block 'scrollable [
; 		source: []		;@@ or a function [index]? or support both?
; 		data: function [/pick i [integer!] /length] [
; 			either pick [source/:i][length? source]
; 		]
; 		index: 1										;-- index of the first item within source
; 		;-- geometric constraints:
; 		;-- * it will display at least 1 item but no more than max-items
; 		;-- * it will drop items starting after max-length along the axis
; 		;-- setting max-length to big enough value makes list size constant = max-items
; 		;-- big enough max-items makes list always show all of the items
; 		max-items:   200
; 		max-length:  10000
; 		jump-length: 100								;-- how much more to show when rolling (px)
; 		look-around: 50									;-- zone after begin and before tail that triggers roll-edge (px)
; 		roll-timer: make-space 'space [rate: 4]			;-- how often to call roll-edge when dragging (can't override scrollable/rate)
; 		list:  make-space 'list [axis: 'y]				;-- list/axis can be changed to get a horizontal list
; 		content: 'list
; 		;@@ TODO: on-change or assertions should ensure max-items >= 1, and sane values for the rest

; 		append map [roll-timer [offset 0x0 size 0x0]]		;@@ any better way to have a separate rate?

; 		filled?: no										;-- true when items are cached
; 		invalidate: does [set-quiet 'filled? no]		;-- call this to force items update

; 		wrap-data: function [item-data [any-type!]][
; 			spc: make-space 'data-view []
; 			set/any 'spc/data :item-data
; 			if list/axis = 'y [spc/width: size/x - (list/margin/x * 2)]		;@@ what data width to use for horizontal lists?
; 			anonymize 'item spc
; 		]

; 		scrollable-draw: :draw
; 		draw: function [] [
; 			any [filled? fill-items]
; 			scrollable-draw
; 		]
		
; 		add-items: function [
; 			"Insert items into list from position WHERE"
; 			where [word!] "head, tail or over"
; 			ext-len [integer!] "Min extension length in pixels (if enough available)"
; 			/local idata
; 		][
; 			x:         list/axis
; 			spc:       list/spacing/:x
; 			items:     list/items
; 			new:       clear []
; 			target:    either where = 'over [items][new]
; 			offset:    switch where [tail [index - 1 + length? items] over [index - 1] head [index]]
; 			available: either where = 'head [index - 1][data/length - offset]
; 			if 0 = available [return [0 0]]						;-- optimization
; 			;@@ it should not know list's internal spacing logic (in case we change the list).. but how?
; 			added-len: either empty? items [list/margin/:x * 2 - spc][0]
; 			+-:        either where = 'head [:-][:+]
; 			repeat i min max-items available [
; 				set/any 'idata data/pick offset +- i
; 				either item: target/:i [
; 					#assert [in get item 'data  "item should have a /data facet to be used in list-view"]
; 					set/any in get item 'data :idata
; 				][
; 					change at target i item: wrap-data :idata
; 				]
; 				item: get item
; 				unless item/size [render 'item]					;-- render it to get the size
; 				added-len: added-len + spc + item/size/:x
; 				if added-len >= ext-len [break]
; 			]
; 			added-num: any [i 0]
; 			switch where [
; 				head [insert items reverse new]
; 				tail [append items new]
; 				over [clear skip items added-num]
; 			]
; 			reduce [added-num added-len]
; 		]

; 		cut-items: function [
; 			"Remove items until list size is within constraints"
; 			where [word!] "head or tail"
; 			limit [integer!] "Enforce min number of items to keep"
; 		][
; 			items: list/items
; 			num1: length? items
; 			size: list/size
; 			x: list/axis
; 			len2: len1: size/:x
; 			; #assert [max-items >= limit]		;-- min shouldn't be bigger than max
; 			min-rem: num1 - max-items					;-- num items over max-items
; 			pick-item: select [head [first items] tail [last items]] where
; 			rem-item:  select [head [take items]  tail [take/last items]] where
; 			repeat i num1 - limit [
; 				item: get do pick-item
; 				item-size: item/size
; 				len3: len2 - item-size/:x - (list/spacing/:x)
; 				all [len3 < max-length  i >= min-rem  break]	;-- check if after removal list will be too short
; 				do rem-item
; 				len2: len3
; 			]
; 			num2: length? items
; 			reduce [num1 - num2  len1 - len2]
; 		]

; 		at-head?: does [(0 - origin/(list/axis)) <= look-around]
; 		at-tail?: function [] [
; 			x:     list/axis
; 			csize: list/size
; 			max-origin: csize/:x - map/list/size/:x
; 			(0 - origin/:x) >= (max-origin - look-around)
; 		]

; 		roll-edge: function [
; 			"Move position of ITEMS within DATA if origin has approached one of the edges"
; 			/head "Force adding items at the head"
; 			/tail "Force adding items at the tail"
; 			; return: [logic!]							;-- whether actually refilled or not
; 		][
; 			unless any [head tail] [head: at-head?  tail: at-tail?]
; 			if all [tail head] [return no]				;-- empty list or less than the viewport
; 			case [
; 				head [
; 					set [add-n: add-len:] add-items 'head jump-length
; 					cut-items 'tail add-n
; 					self/origin: origin - (add-len * 0x1)
; 					set-quiet 'index index - add-n
; 				]
; 				tail [
; 					set [added:] add-items 'tail jump-length
; 					set [cut-n: cut-len:] cut-items 'head added
; 					self/origin: origin + (cut-len * 0x1)
; 					;@@ BUG: we should trigger on-change/index so it can be detected by other spaces
; 					;@@ OTOH if we do, we cause another add-items/over call and lose the added items
; 					;@@ so how to solve this?
; 					set-quiet 'index index + cut-n
; 				]
; 				'else [return no]
; 			]
; 			yes
; 		]

; 		fill-items: does [
; 			add-items 'over max-length
; 			set-quiet 'filled? yes
; 		]

; 		;-- when to fill?
; 		;-- - width changes => new length
; 		;-- - text of one of the items changes => new length -- can't track this automatically
; 		;-- - source index changes => new content for each item
; 		scrollable-on-change*: :on-change*
; 		on-change*: function [word [word! set-word!] old [any-type!] new [any-type!]] [
; 			scrollable-on-change* word :old :new
; 			if find [source width index] word [invalidate]
; 		]
; 	]
; ]

development (non-reduced) version of extend-layout in case I break it later
; extend-layout: function [dir [word!] amount [integer!] /keep where [block!]] [
; 	; print ["extend" dir amount]
; 	lt: list/make-layout
; 	unless empty? list/items [amount: amount - lt/spacing/(list/axis)]
; 	switch dir [
; 		n w [+-: :-  n-max: (base: index) - 1]
; 		s e [+-: :+  n-max: data/length - base: index - 1 + length? list/items]
; 	]
; 	#assert [(select [n y s y e x w x] dir) = list/axis]
; 	repeat i n-max [
; 		name: wrap-data data/pick base +- i		;-- guarantee at least 1 item (else spacing could be bigger than the requested amount)
; 		#assert [not find/same list/items name]
; 		render name
; 		lt/place select get name 'size
; 		if keep [append where name]
; 		if lt/content-size/(list/axis) >= amount [break]
; 	]
; 	lt
; ]

; window/fill: function [xy1 [pair!] xy2 [pair!]] [
; print ["fill" xy1 xy2]
; 	;@@ TODO: e / w support
; 	#assert [0 = xy1/x]
; 	#assert [window/size/x = xy2/x]
; 	#assert [any [xy1/y = 0  xy2/y = window/size/y]]

; 	initial?: window/map/list/offset = 0x0				;-- on first fill, do not align with the lowest/rightmost edge
; 	x: list/axis
; 	dir: select
; 		pick [ [x e y s] [x w y n] ] xy2/:x = window/size/:x	;-- s/e = tail fill (or head to tail), n/w = head fill
; 		x
; 	switch dir [				;-- get already rendered parts out of the requested window
; 		n w [xy2/:x: xy2/:x - extra? dir]
; 		s e [xy1/:x: xy1/:x + extra? dir]
; 	]
; 	;-- window now lies purely outside of the list
; 	req-size: xy2 - xy1
; 	?? req-size
; 	lt: extend-layout/keep dir req-size/:x clear new: []
; 	#assert [not empty? lt/items]

; 	ext-size: lt/content-size/:x + either empty? list/items [0][lt/spacing/:x]

; 	offset: window/map/list/offset				;-- we can count invisibles right now from list/offset
; print [dir offset "new:" length? new "lt/size:" lt/content-size]
; 	rem: 0
; 	foreach': switch dir [n w [:foreach-reverse] s e [:foreach]]	 ;@@ should be for-each/reverse
; 	foreach' [name: geom:] list/map [			;-- count the number of invisible spaces
; 		o: geom/offset + offset
; 		visible?: bbox-overlap?  0x0 window/size  o o + geom/size
; 		either visible? [break][rem: rem + 1]
; 	]

; 	switch dir [										;-- add items
; 		n w [
; 			#assert [not empty? new]
; 			insert list/items reverse new
; 			self/index: self/index - length? new
; 		]
; 		s e [
; 			append list/items new
; 			maybe self/index: self/index + rem			;-- rem can be 0
; 		]
; 	]

; 	rem-size: 0
; 	if rem > 0 [
; 		removed: switch dir [								;-- add items, remove invisibles from `items` & `map`
; 			n w [
; 				take/last/part list/items rem
; 				take/last/part list/map rem * 2
; 			]
; 			s e [
; 				remove/part list/items rem
; 				take/part list/map rem * 2
; 			]
; 		]

; 		rem-1st: removed/2
; 		rem-last: last removed
; 		rem-size: rem-last/offset + rem-last/size - rem-1st/offset + lt/spacing
; 		rem-size: rem-size/:x
; 	]
; 	;-- now that we know removed size we can calculate the new list offset
; 	offset: switch dir [
; 		n w [
; 			ext-size * select [n 0x1 w 1x0] dir
; 		]
; 		s e [
; 			rem-size * -1 * select [s 0x1 e 1x0] dir
; 		]
; 	]

; 	foreach [name geom] list/map [					;-- relocate the visible spaces now that we know the offset
; 		geom/offset: geom/offset - offset
; 		;-- impossible to verify visibility here because we don't know list/offset until we get the size
; 		;-- and don't know the size until we render it and we can't render it until we relocate the items
; 		; o: window/map/list/offset + geom/offset: geom/offset - offset
; 		; expect [bbox-overlap?  0x0 window/size  o o + geom/size]
; 		; #assert [bbox-overlap?  0x0 window/size  o o + geom/size]
; 	]

; 	; unless list/size [render/only 'list xy1 xy2]	;-- refreshes list/size after removal ;@@ TODO: possible to get rid of it and use `lt`?
; 	; render/only 'list xy1 xy2		;-- refreshes list/size after removal ;@@ TODO: possible to get rid of it and use `lt`?
; 	either new-size: list/size [
; 		;-- update the size, without re-rendering anything
; 		new-size/:x: new-size/:x - rem-size + ext-size
; 		maybe list/size: new-size
; 		; render/only 'list xy1 xy2
; 	][
; 		;-- render the list to get it's size - should only be needed first time it's shown
; 		render/only 'list xy1 xy2
; 	]

; 	#assert [list/size]
; 	; lgeom: window/map/list
; 	window/map/list/size: list/size
; 	window/map/list/offset: switch dir [
; 		n w [0x0]
; 		s e [
; 			either initial? [0x0][
; 				window/size - list/size * select [s 0x1 e 1x0] dir
; 			]
; 		]
; 	]
; ]

got rid of this; now map name = style name
; get-style-name: function [
; 	"Transform MAP name into STYLE name"
; 	name [word!]
; ][
; 	space: get name
; 	all [
; 		new-name: select space 'style 					;-- allow space to enforce it's style
; 		name <> new-name
; 		;-- enforced name has to not to leak into globals and should have the same value as the name in map
; 		return anonymize new-name space					;@@ any easier way?
; 	]
; 	name
; ]

closures are now style/after
; get-style: function [
; 	"Fetch styling code for the current space being drawn"
; 	/named path [path! block!] "Path to look for (defaults to current-style)"
; 	/closing "Fetch a closure instead"
; ][
; 	table: either closing [closures][styles]
; 	path: tail as path! either named [path][current-style]
; 	#assert [not head? path]
; 	until [												;-- look for the most specific fitting style
; 		p: back path
; 		style: any [find/only table p  style]
; 		head? path: p
; 	]
; 	unless style [return []]
; 	style: first find style block!
; 	#assert [block? style]
; 	space: get last path								;-- need to expose it's context to the style
; 	; print ["style for " head path "is" mold style]
; 	compose/deep bind style space			;@@ how slow this bind will be? any way not to bind?
; ]

now powered by trap mezz, simpler
; do-handler: function [spc-name [path!] handler [function!] path [block!] args [block!] /local result] [
; 	path: cache/hold path							;-- copy in case user modifies/reduces it, preserve index
; 	space: get path/1
; 	code: compose/into [handler space path (args)] clear []
; 	error: try/all [set/any 'result do code  'ok]
; 	cache/put path
; 	unless 'ok == error [
; 		msg: form/part error 400					;@@ should be formed immediately - see #4538
; 		print #composite "*** Failed to evaluate (spc-name)!"
; 		print msg
; 	]
; 	:result
; ]
; do-global: function [map [map!] path [block!] event [event! none!] type [word!]] [
; 	unless list: map/:type [exit]
; 	kind: either map =? previewers ["previewer"]["finalizer"]
; 	foreach fn list [
; 		pcopy: cache/hold path					;-- copy in case user modifies/reduces it, preserve index
; 		error: try/all [(fn get path/1 pcopy event)  'ok]
; 		cache/put pcopy
; 		unless 'ok == error [
; 			print #composite "*** Failed to evaluate event (kind) (mold/part/flat :fn 100)!"
; 			print form/part error 400
; 		]
; 	]
; ]

this style design can't be bound - didn't work
; cell [
; 	bgnd: [
; 		fill-pen (svmc/panel)
; 		box 0x0 (size)
; 	]
; 	render: function [] [
; 		before: compose/deep self/before
; 		?? draw
; 		drawn:  draw
; 		bgnd:   compose/deep self/bgnd
; 		after:  compose/deep self/after
; 		compose [(bgnd) (before) (drawn) (after)]	;-- composed order differs from evaluation order
; 	]
; ]

render now can accept a host face directly, and split into parts
; set 'render function [
; 	space [word! object!] "Space name; or host face as object"
; 	; /as style [word!]
; 	/only xy1 [pair! none!] xy2 [pair! none!]
; 	; /draw cmds [block! function!]
; 	; /root "Apply the styles/root as well (for topmost spaces)"
; ][
; 	either word? space [
; 		unset 'prefix
; 	][
; 		prefix: bind get-style 'host		;-- apply styles/root for topmost spaces
; 	]

; 	space: get name: space
; 	append current-style name			;-- used by get-style
; 	#assert [space? space]
; 	style: get-style					;-- call it before calling draw or draw/only, in case it modifies smth
	
; 	trap/all/catch [					;-- traps compose and draw calls errors
; 		if value? 'prefix [prefix: compose/deep prefix]
; 		either block? :style [
; 			style: compose/deep bind style space		;@@ how slow this bind will be? any way not to bind? maybe construct a func?
; 			draw: select space 'draw
; 			all [
; 				only
; 				function? :draw
; 				find spec-of :draw /only
; 				draw: draw/only xy1 xy2
; 			]
; 			render: compose [(style) (draw)]			;-- call the function if not called yet, inline blocks
; 		][
; 			#assert [function? :style]
; 			render: (style space)						;@@ TODO: /only support for it?
; 		]
; 	][
; 		msg: form/part thrown 400						;@@ should be formed immediately - see #4538
; 		print #composite "*** Failed to compose the style of (name)!^/(msg)"
; 		render: copy []
; 	]
; 	take/last current-style									;-- draw should be called before take/last, in case `draw` relies on current-style
; 	compose/only [(:prefix) push (render)]					;-- push should shield from style propagation
; ]

this fails because it considers context of the word, but we don't care about it
; same-paths?: function [p1 [block! path!] p2 [block! path!]] [
; 	to logic! all [
; 		(length? p1) = length? p2
; 		find/match/same p1 p2							;@@ won't work in master branch yet (#4165)
; 	]
; ]

this is too naive
; same-paths?: function [p1 [block! path!] p2 [block! path!]] [
; 	to logic! all [
; 		p1 == as p1 p2									;-- spelling & length match
; 		(
; 			repeat i n: length? p1 [					;-- values sameness
; 				unless same? get/any p1/:i get/any p2/:i [return no]
; 			]
; 			yes
; 		)
; 	]
; ]

REP #104 experiments, have no use for them anyway
; same-scalar?: function [v1 [any-type!] v2 [any-type!]] [
; 	to logic! any [
; 		:v1 =? :v2
; 		all [
; 			series? :v1
; 			(type? :v1) = type? :v2
; 			(length? :v1) = n: length? :v2
; 			(repeat i n [unless same-scalar? :v1/:i :v2/:i [return false]]  true)
; 		]
; 	]
; ]
; ;-- `find/match` using `same-scalar?` comparator
; find-match-same-scalar: function [series [series!] match [any-type!]] [
; 	if series? :match [
; 		repeat i n: length? match [
; 			unless same-scalar? :series/:i :match/:i [return none]
; 		]
; 		return skip series n
; 	]
; 	all [same-scalar? :series/1 :match  next series]
; ]
; ;-- `find` using `same-scalar?` comparator
; find-same-scalar: function [series [series!] value [any-type!]] [
; 	; while [series: find/case series :value] [		can't be used because find will never match nans
; 	while [not tail? series] [
; 		if find-match-same-scalar series :value [return series]
; 		series: next series
; 	]
; 	none
; ]
; #assert [same-scalar? 1.#nan 1.#nan]
; #assert [same-scalar? reduce [1.#nan] reduce [1.#nan]]
; #assert [r: find-match-same-scalar reduce [0.0 / 0.0 1.0 * 1.#inf] 0.0 / 0.0  'r]
; #assert [r: find-match-same-scalar b: reduce [0.0 / 0.0 1.0 * 1.#inf] copy b  'r]
; #assert [r: find-match-same-scalar b: reduce [0.0 / 0.0 reduce [1.0 * 1.#inf]] copy/deep b  'r]
; #assert [2 = index? r: find-same-scalar reduce [0.0 / 0.0 1.0 * 1.#inf] 1.0 * 1.#inf  'r]
; #assert [2 = index? r: find-same-scalar b: reduce [0 0.0 / 0.0 reduce [1.0 * 1.#inf]] copy next b  'r]

from grid/draw: this broke tabbing because cell objects were replaced after redraw
thus making keyboard/focus point to invalid object
of course it couldn't have a clue - replaced objects must be treated as different ones
;@@ TODO: this should be documented in the widget builders guide
; unless mcspace [
; 	render mcspace: rcache/:mcell: wrap-space mcell-content-name
; ]

from events/dispatch - causes stack overflow and crashes as expected (when UI lags a bit)
; if commands/update? [
; 	face/draw: render face
; 	do-events/no-wait
; ]

this window model was too convoluted to work with
; last-origin: last-size: none							;-- geometry during previous call to `renew`
; renew: function [] [
; 	unless all [last-origin last-size = max-size] [		;-- first ever invocation or size changed
; 		self/last-origin: origin
; 		self/last-size: max-size
; 		fill 0x0 max-size
; 		exit
; 	]
; 	if 0x0 = offset: origin - last-origin [exit]		;-- has not been moved
; 	self/last-origin: origin
; 	unless caching? [
; 		clear map
; 		fill 0x0 max-size
; 		exit
; 	]

; 	remove-each [name geom] map [				;-- clear the map of invisible spaces
; 		o: geom/offset: geom/offset + offset	;-- and relocate visible ones
; 		not bbox-overlap?  0x0 max-size  o o + geom/size
; 	]
; 	case [										;-- fill top/bottom before left/right (random decision)
; 		offset/y > 0 [fill  0x0  as-pair max-size/x top: offset/y]
; 		offset/y < 0 [fill  as-pair 0 btm: max-size/y + offset/y  max-size]
; 	]
; 	default top: 0
; 	default btm: max-size/y
; 	case [										;-- left/right excludes already drawn top/bottom regions
; 		offset/x > 0 [fill  as-pair 0 top  as-pair offset/x btm]
; 		offset/x < 0 [fill  as-pair max-size/x + offset/x top  as-pair max-size/x btm]
; 	]
; ]
; draw: function [/only xy1 [pair!] xy2 [pair!]] [
; 	old-origin: origin							;-- renew may change origin, in which case we don't wanna miss the viewport
; 	renew
; 	either only [
; 		visible: []
; 		foreach [name geom] map [				;@@ should be map-each
; 			if bbox-overlap? 0x0 max-size xy1 xy2 [append visible name]
; 		]
; 		r: compose-map/only/limits map visible xy1 - old-origin xy2 - old-origin
; 		clear visible							;-- let GC free it up
; 	][
; 		r: compose-map map
; 	]
; 	self/size: either empty? map [
; 		0x0
; 	][
; 		item-last: last map
; 		min max-size item-last/offset + item-last/size
; 	]
; 	r

(dispatch) this was supposed to provide real time updates but due to #4881 totally blocked the UI
; if commands/update? [
; 	face/draw: render face
; 	;@@ TODO: fix the lag once #4881 gets a solution
; 	do-atomic [									;-- uses reactivity to unroll the recursion and prevent stack overflow
; 		do-events/no-wait						;@@ this still does not prevent GUI huge lags :(
; 	]
; ]

now that there's proper grid-view, this list of lists hack is not needed anymore
; table-ctx: context [
; 	;@@ TODO: func to automatically balance column widths to minimize table height
; 	; balance: function [] 

; 	spaces/table-row: make-space/block 'list [
; 		spacing: 4x3
; 		margin: 0x0
; 		data: none
; 		table: none				;-- should be set by the table

; 		make-layout: has [r] [
; 			r: make row-layout [
; 				pinned: table/pinned/x
; 				widths: table/widths
; 				axis: 'x
; 			]
; 			r/axis:    axis
; 			r/margin:  margin
; 			r/spacing: spacing
; 			r
; 		]

; 		;@@ TODO: unify this with data-view block variant somehow
; 		fill: function [] [
; 			#assert [block? data]
; 			n: length? data
; 			repeat i n [
; 				value: :data/:i
; 				unless item: items/:i [
; 					append items item: anonymize 'item make-space 'data-view []
; 				]
; 				item: get item
; 				maybe item/width: table/widths/:i
; 				set/any 'item/data :value
; 				item/set-content
; 			]
; 			clear skip items n
; 		]

; 		list-draw: :draw
; 		draw: function [] [
; 			fill		;@@ TODO: caching
; 			list-draw
; 		]
; 	]

; 	;@@ TODO: spacers between pinned and not pinned data
; 	spaces/table: make-space/block 'list [
; 		pinned: 0x1							;-- pinned columns x rows (headers)
; 		margin: 0x0	
; 		data-columns: [1 2]					;-- indexes of visible DATA columns in the order of appearance
; 		;-- NOTE: don't use #() here because it's ignored by copy/deep
; 		widths: make map! [1 100 2 100]		;-- data column index -> it's visible width
; 		axis: 'y

; 		source: []										;-- block of blocks or a function returning one
; 		;-- user can override `data` for more complex `source` layouts support
; 		data: function [/pick x [integer!] y [integer!] /size] [
; 			s: source									;-- eval in case it's a function
; 			case [
; 				pick [if row: s/:y [row/:x]]			;-- s/:y can be `none`
; 				empty? s [0x0]
; 				'else [
; 					#assert [block? s/1]
; 					as-pair  length? s/1  length? s
; 				]
; 			]
; 		]

; 		prep-data-row: function [
; 			"preps data row for display, independent of `source` format"
; 			y [integer!]
; 		][
; 			dsize: data/size
; 			if any [y <= 0  y > dsize/y] [return none]	;-- out of data limits case
; 			ncol: length? data-columns
; 			if 0 = ncol [return []]						;-- empty row case (no allocation needed)

; 			;@@ TODO: make a free list of blocks for this
; 			r: make [] ncol
; 			repeat x ncol [append/only r data/pick data-columns/:x y]	;@@ should be map-each, but it's slow
; 			r
; 		]

; 		headers: make-space 'list-view [hscroll/size/y: 0]
; 		columns: make-space 'list-view []
; 		headers/data: func [/pick i /length] [
; 			either pick
; 				[prep-data-row i]
; 				[min pinned/y second data/size]
; 		]
; 		columns/data: func [/pick i /length] [
; 			either pick
; 				[prep-data-row i + pinned/y]
; 				[max 0 (second data/size) - pinned/y]
; 		]
; 		headers/wrap-data:
; 		columns/wrap-data: function [item-data [block!]] [
; 			anonymize 'row make-space 'table-row compose/only [table: (self) data: (item-data)]
; 		]

; 		items: [headers columns]

; 		list-draw: :draw
; 		draw: function [] [
; 			maybe headers/origin: as-pair columns/origin/x headers/origin/y	;-- sync origin/x
; 			; headers/invalidate
; 			; columns/invalidate
; 			render 'headers
; 			render 'columns
; 			;-- don't let headers occupy more than half of height
; 			maybe headers/size: min headers/list/size size / 1x2 - (margin * 2x1)
; 			maybe columns/size: size - (headers/size * 0x1) - (margin * 2x2) - (spacing * 0x1)
; 			list-draw
; 		]

; 		;@@ do this as a function called inside draw!
; 		; on-change*: function [word old [any-type!] new [any-type!]] [
; 		; 	if word = 'dimensions [						;-- automatically show just added columns
; 		; 		#assert [pair? :old]
; 		; 		#assert [pair? :new]
; 		; 		set-quiet 'columns union columns rng: range old/x new/x
; 		; 		foreach i rng [widths/:i: 100]			;@@ externalize the default width?
; 		; 	]
; 		; ]
; 	]
; ]

this was crazy complex
; list-view-ctx: context [
; 	spaces/list-view: make-space/block 'inf-scrollable [
; 		source: []		;@@ or a function [index]? or support both?
; 		data: function [/pick i [integer!] /length] [
; 			either pick [source/:i][length? source]
; 		]
; 		index: 1										;-- index of the first item within source
		
; 		wrap-data: function [item-data [any-type!]][
; 			spc: make-space 'data-view []
; 			set/any 'spc/data :item-data
; 			if list/axis = 'y [spc/width: window/max-size/x - (list/margin/x * 2)]		;@@ what data width to use for horizontal lists?
; 			anonymize 'item spc
; 		]

; 		list: make-space 'list [axis: 'y]				;-- list/axis can be changed to get a horizontal list ;@@ but then setup becomes wrong
; 		window/map: [list [offset 0x0 size 0x0]]

; 		window/max-size: 1000x1000		;@@ this is where sizing strategy would be cool to have

; 		extra?: function [dir [word!]] [			;-- measure dangling extra size along any direction
; 			if empty? map: window/map [return 0]
; 			#assert [2 = length? map]
; 			r: max 0x0
; 				switch dir [
; 					w n [negate map/2/offset]
; 					e s [map/2/offset + map/2/size - window/max-size]
; 				]
; 			r/x + r/y
; 		]

; 		window/available?: function [dir [word!] requested [integer!]] [
; 			#assert [0 < requested]
; 			if any [
; 				all [list/axis = 'y  find [e w] dir]
; 				all [list/axis = 'x  find [n s] dir]		;@@ not sure about this yet, /width doesn't guarantee it
; 			] [return 0]
; 			reserve: extra? dir
; 			requested: requested - reserve

; 			r: 0
; 			if requested > 0 [
; 				lt: extend-layout dir requested
; 				r: lt/content-size/(list/axis)
; 				unless empty? lt/items [r: r + lt/spacing/(list/axis)]
; 			]
; 			r: max 0 r + reserve
; 			; print ["avail?" dir "=" r "of" requested "(reserve:" reserve ")"]
; 			r
; 		]

; 		;@@ ensure this one is called only from inf-scrollable/draw
; 		extend-layout: function [dir [word!] amount [integer!] /keep where [block!]] [
; 			; print ["extend" dir amount]
; 			lt: list/make-layout
; 			unless empty? list/items [amount: amount - lt/spacing/(list/axis)]
; 			switch dir [
; 				n w [+-: :-  n-max: (base: index) - 1]
; 				s e [+-: :+  n-max: data/length - base: index - 1 + length? list/items]
; 			]
; 			#assert [(select [n y s y e x w x] dir) = list/axis]
; 			repeat i n-max [
; 				name: wrap-data data/pick base +- i		;-- guarantee at least 1 item (else spacing could be bigger than the requested amount)
; 				#assert [not find/same list/items name]
; 				render name
; 				lt/place select get name 'size
; 				if keep [append where name]
; 				if lt/content-size/(list/axis) >= amount [break]
; 			]
; 			lt
; 		]

; 		;-- this func is quite hard to get right, many aspects to consider
; 		;-- * window moves list within it's map before calling `fill`,
; 		;--   but we'll have to move list back and move all items within list accordingly
; 		;-- * move offset can be used right away to know what spaces will be hidden
; 		;-- * list may have extra dangling items partially clipped by window (before the move), which now become visible
; 		;--   i.e. list/size may be > window/max-size because it contains whole items, not necessarily aligning to window borders
; 		;-- * these hidden parts should be subtracted from the xy1-xy2 area to know how much to extend the list itself
; 		;-- * there may be no new items to add, just the hidden area to show
; 		;-- * list may initially be empty (spacing to consider), or not rendered (undefined size)
; 		;-- * when filling from above, list should be aligned with the top border, when from below - the opposite
; 		;@@ and I haven't considered the case where window/max-size <= list-view/size (it isn't working)
; 		window/fill: function [xy1 [pair!] xy2 [pair!]] [
; 			; ?? size print ["fill" xy1 xy2]
; 			;@@ TODO: remove these or add x=opposite support
; 			#assert [0 = xy1/x]
; 			#assert [window/max-size/x = xy2/x]
; 			#assert [any [xy1/y = 0  xy2/y = window/max-size/y]]

; 			unit: select [x 1x0 y 0x1] x: list/axis
; 			dir: select
; 				pick [ [x e y s] [x w y n] ] xy2/:x = window/max-size/:x	;-- s/e = tail fill (or head to tail), n/w = head fill (partial)
; 				x
; 			negative?: none <> find [n w] dir
; 			either negative? [											;-- get already rendered parts out of the requested area
; 				xy2/:x: xy2/:x - extra? dir
; 			][	xy1/:x: xy1/:x + extra? dir
; 			]
; 			lgeom: window/map/list

; 			;-- xy area now lies purely outside the list, so we can fill it
; 			lt: extend-layout/keep dir (xy2/:x - xy1/:x) clear new: []

; 			;-- sometimes it's possible that `new` is empty and `fill` should only move the list to show `extra?` (hidden) area
; 			unless empty? new [
; 				;@@ TODO: some automatic extension calculation? right now it won't work for arbitrary layout
; 				pixels-added: lt/content-size/:x + either empty? list/items [0][lt/spacing/:x]

; 				offset: lgeom/offset						;-- we can count invisibles right now from list/offset
; 				initial-fill?: offset = 0x0					;-- on first fill, do not align with the lowest/rightmost edge
				
; 				n-remove: 0									;-- count how many invisible spaces to remove
; 				foreach': switch dir [n w [:foreach-reverse] s e [:foreach]]	 ;@@ should be for-each/reverse
; 				;@@ list should have no timer in the map, else we'll have to check names for `item`
; 				foreach' [_: geom:] list/map [
; 					o: geom/offset + offset
; 					visible?: bbox-overlap?  0x0 window/max-size  o o + geom/size
; 					either visible? [break][n-remove: n-remove + 1]
; 				]

; 				either negative? [									;-- insert new items
; 					insert list/items reverse new
; 					self/index: self/index - length? new
; 				][
; 					append list/items new
; 					maybe self/index: self/index + n-remove			;-- n-remove can be 0
; 				]

; 				pixels-removed: 0									;-- along the list/axis
; 				if n-remove > 0 [
; 					removed: either negative? [						;-- remove invisibles from `items` & `map`
; 						take/last/part list/items n-remove
; 						take/last/part list/map n-remove * 2
; 					][
; 						remove/part list/items n-remove
; 						take/part list/map n-remove * 2
; 					]

; 					rem-1st: removed/2
; 					rem-last: last removed
; 					pixels-removed: rem-last/offset + rem-last/size - rem-1st/offset + lt/spacing		;@@ TODO: automatic calculation if possible?
; 					pixels-removed: pixels-removed/:x
; 				]

; 				;-- now that we know removed size we can calculate how much to shift the list in window/map
; 				offset: unit * either negative? [pixels-added][pixels-removed * -1]

; 				foreach [_ geom] list/map [					;-- relocate visible spaces now that we know the offset
; 					geom/offset: geom/offset - offset
; 				]

; 				either new-size: list/size [
; 					;-- update the size, without re-rendering anything
; 					new-size/:x: new-size/:x - pixels-removed + pixels-added
; 					maybe list/size: new-size
; 				][
; 					;-- render the list to get it's size - should only be needed first time it's shown
; 					render/only 'list xy1 xy2
; 				]
; 			]
; 			#assert [list/size]

; 			;-- update list geometry inside the window
; 			lgeom/size: list/size
; 			lgeom/offset: either any [negative? initial-fill?] [
; 				0x0												;-- align to top-left corner of the window
; 			][	min 0x0 window/max-size - list/size * unit		;-- to bottom-left, but only if list > window(!)
; 			]
; 		]

; 		setup: function [] [
; 			if size [									;-- if size is defined, adjust the window (paragraphs adjust to window then)
; 				pages: 10								;@@ make this configurable?
; 				unit: select [x 1x0 y 0x1] list/axis
; 				maybe window/max-size: size + (pages - 1 * size * unit)
; 			]
; 		]

; 		inf-scrollable-draw: :draw
; 		draw: function [] [
; 			setup
; 			inf-scrollable-draw
; 		]
; 	]
; ]

call to `available?` to window's limits is very expensive - renders whole window
; window/draw: function [/only xy1 [pair!] xy2 [pair!]] [
; 	#debug grid-view [#print "window/draw is called with xy1=(xy1) xy2=(xy2)"]
; 	#assert [word? content]
; 	map/1: content								;-- rename it properly
; 	cspace: get content
; 	geom: map/:content
; 	o: geom/offset
; 	;-- there's no size for infinite spaces so we use `available?` to get the drawing size
; 	s: max-size
; 	foreach x [x y] [s/:x: available? x 1 (0 - o/:x) s/:x]
; 	default xy1: 0x0
; 	default xy2: s
; 	geom/size: s - o
; 	self/size: s							;-- limit window size by content size
; 	cdraw: render/only content xy1 - o xy2 - o
; 	compose/only [translate (o) (cdraw)]
; ]

no longer relevant in the new styles design
; set 'closures reshape [		;-- closures come after the main drawing code
; 	; hscroll/thumb vscroll/thumb [
; 	; 	(when focused?/parent [compose/deep [
; 	; 		push [
; 	; 			;@@ MEH DOESNT WORK YET -- CHECK PATTERN PEN WHEN IT"S FIXED
; 	; 			; pen pattern 4x4 [line-width 0 fill-pen black box 0x0 2x2 box 2x2 4x4]
; 	; 			; fill-pen 0.100.200.200
; 	; 			; line-width 0
; 	; 			; box 0x0 (size)
; 	; 			; line-width 2
; 	; 			line-width 0
; 	; 			fill-pen !(svmc/text + 0.0.0.100)
; 	; 			box 4x3 (size - 4x3)
; 	; 			line-width 2
; 	; 		]
; 	; 	]])
; 	; ]	
; ]

too complicated, hard to support reordering (e.g. left-to-right placement)
; tube-layout-ctx: context [
; 	~: self

; 	place: function [layout [object!] item [word!]] [
; 		sz: select get item 'size
; 		#assert [sz]									;-- item must have a size
; 		data: tail layout/raw-map
; 		x: switch layout/align/1 [n s ['x] w e ['y]]
; 		y: select [x y x] x
; 		rw: data/-1/:x									;-- row width accumulated so far
; 		cs: layout/content-size
; 		sp: layout/spacing

; 		if rw > 0 [rw: rw + sp/:x]						;-- add size to row
; 		rw: rw + sz/:x
; 		if all [
; 			rw > sz/:x									;-- put at least 1 item per row, even if it's wider
; 			layout/margin/:x * 2 + rw > layout/width	;-- jump to next row if needed
; 		][
; 			cs/:y: cs/:y + sz/:y						;-- count height in content-size
; 			if 3 < index? data [cs/:y: cs/:y + sp/:y]
; 			data: insert insert/only data copy [] 0x0
; 			rw: sz/:x
; 		]
; 		if all [
; 			rw > sz/:x
; 			0 < added: sz/:y - data/-1/:y
; 		][cs/:y: cs/:y + added]
; 		data/-1/:x: max data/-1/:x rw					;-- update row size
; 		data/-1/:y: max data/-1/:y sz/:y
; 		layout/content-size: max data/-1 cs				;-- update content size (x from row-size, y from cs)

; 		guide: select [x 1x0 y 0x1] x
; 		ofs: rw - sz * guide
; 		compose/deep/into [(item) [offset (ofs) size (sz)]] tail data/-2
; 	]

; 	build-map: function [layout] [
; 		al: layout/align
; 		x: switch al/1 [n s ['x] w e ['y]]
; 		y: select [x y x] x
; 		; guide: select [x 1x0 y 0x1] y
; 		sign: switch al/1 [n w [1] e s [-1]]
; 		move-items: sign * (switch al/3 [n w [-1] c [0] e s [1]]) + 1 / 2	;@@ use -1/+1 instead of nw/es pairs?
; 		move-rows:  sign * (switch al/2 [n w [-1] c [0] e s [1]]) + 1 / 2
; 		pos: layout/margin
; 		r: make [] 20
; 		foreach [row row-size] layout/raw-map [
; 			gap: layout/width - (layout/margin/:x * 2) - row-size/:x	;-- can be negative, still correct
; 			pos/:x: to 1 gap * move-rows
; 			if layout/dir < 0 [reverse/skip row 2]
; 			foreach [name geom] row [
; 				if move-items <> 0 [
; 					gap: row-size/:y - geom/size/:y
; 					geom/offset/:y: geom/offset/:y + to 1 (move-items * gap)
; 				]
; 				geom/offset: geom/offset + pos
; 			]
; 			append r row
; 			pos/:y: pos/:y + layout/spacing/:y + row-size/:y
; 		]
; 		; set 'xx layout
; 		; ?? layout
; 		r
; 	]

; 	set 'tube-layout object [
; 		;-- interface
; 		width:   100
; 		; origin:  0x0			;@@ TODO - if needed
; 		margin:  0x0
; 		spacing: 0x0
; 		align:   [n w n]		;-- 3 alignments: tube itself (nesw), then list within row (neswc), then item within list (neswc)
; 		dir: 1

; 		content-size: 0x0
; 		size:  does [margin * 2 + content-size]
; 		place: func [item [word!]] [~/place self item]
; 		map:   does [~/build-map self]

; 		;-- used internally
; 		raw-map: [[] 0x0]		;-- accumulated map so far (make object! copies this deeply)
; 	]

; 	#assert [not same? tube-layout/raw-map/1 (first select make tube-layout [] 'raw-map)]
; ]
