TODOS
+ event handling system - standard way to react to clicks, clicks-and-holds, keypresses, etc.
keys binding to each UI item?
+ focused items should be highlighted using styles
+ decouple styles from the objects
+ demo+test of rotated scrollable space (mb rotate it with time and demo proper origin)
demo: chatlog with smooth scrolling and an interactive bot
	needs reversal of list items and a custom wrapper (sender/time+paragraph)
	also buttons to remove & edit messages
+ scrollbar should generate page events periodically until LMB is up
+ styles should be deep, e.g. paragraph! <> list-view!/paragraph!
need to try 2 types of KB navigation: tabbed and spatial, how they apply
	this navigation, at least tabbed, should be able to work across different *faces*
	so: mixed transparent tabbing across spaces and faces
+ if `map` is defined `into` should not be needed, when none is defined it is a final space (non-composite)
	or leave `into` always there? afraid of inheritance errors
draggability of spaces (e.g. table columns) - this will require temporary offsets in the map
disabled items, and they should not be focusable!
if an item gets hidden, it should not receive keyboard events even if it's still in focus
	(there will be no 'hidden', there will be 'not drawn')
+ how to decouple KB navigation from the dispatcher?
+ make content: 'a-word ! make `make` return a word with a style value!
how to compose styles from the old ones? need a clear mechanism
handler spec validation and auto addition of typesets - to help learning, minimize mistakes
list & doc ideas that improve over vid/view, key differences
debug func to list handlers for this or that space (with all path variants)
should events receive full paths (from `screen`) or relative to host (from it's `space`)??
in event handlers `self` =? `commands` right now, should be set to `space`? and get rid of `space` arg?
	this will be problematic as will require a `bind` before every handler call
+ can I externalize list-view's rolling logic to be able to utilize it in other spaces?
table demo with wavy animated layout: each row would slide left and right in a sine manner - will be a killer demo!
	and it's columns should be draggable! :D
high-level table that would extend minimal table with advanced features
maybe a plugin mechanism:
	each space would list possible features and each of them would be a separate code, that can be turned on/off
	or it's not worth it, even for the table?
demo templates for all useful styles, like small static table, huge table for csv, etc etc
	so others can take those and build upon
+ separate space for an icon+text combo -- very common thing nowadays
	or `list` will be enough?
+ VID extension for spaces:
	on-created (possible?) global event handler
	will scan each host face's worst actor and create a space tree from it's spec
rename host/space to host/content for consistency with scrollable?
	or make it host a scrollable always?
	or make separate faces for all spaces? - best idea to keep layout clean.. e.g. host.list, host.scrollable ..
+ decide on resize model (though ideally it should cover View wholly)
+ what if I devise a standard way child sizes can be propagated into parent sizes? (headers-list dilemma)
+ make multi-cell span
	how can cell span multiple rows vertically?
	perhaps separate grid style will be required
	or I just make a span: field and disable clipping everywhere (except scrollable)
	no, disabled clipping won't work as we need hittest to deliver events
	however disabled clipping may be useful for a different thing: casting wide outside shadows, but be able to click thru them
table cells should know their coordinate, to be able to modify original data
styles should be able to rearrange UI items 
	maybe by changing the map before it's rendered? but that's a bit limited
	e.g. we split `draw` into `draw` and `prep`, style would apply after prep, draw will read the map
	that complicates `space` design
	OTOH it will be possible to get the `size` without actually composing draw blocks
	like this!: if `prep` exists, it's called, if not then `draw` will do it's work
				and styles will be limited in their rearrange ability
	though then one will be unable to call prep to get the size.. maybe default prep will call draw?
+ click event should only be produced when pointer didn't travel long (i.e. it's not a drag event)
will it be possible to minimize style/event lookup time if I detect changes to the tree and to style/event tables
	and then just cache the lookup results?
optional scrollbars for infinite space:
	logarithmic, linear near the current offset
	cyclic, inertial, wheel-like in appearance
trooper-like zooming into infinite canvas? although it may take quite a time to prerender it... useless unless realtime
demo: interactive plot of some downloadable btc price
	will require a color picker (Red doesn't have one) - to edit colors, and also need to edit labels, width..
demo: neon text
demo: fractal explorer on infinite canvas
describe a set of challenges to invite other to play with it and learn
maybe scrollable should be the default container for everything layout creates? or at least for lists?
add inertia to scrollable to easier hunt the spider (maybe as a separate style or pluggable trick)
	otherwise it demonstrates how inefficient scrollbars are, as a UI element
this is a good idea though: easy way to make every scrollable area draggable with inertia
demo: jedi librarians betting game (assisted), to see how this all works in 2D games, and as a template
optimize `translate 0x0`
hints (tooltips) for everything, pluggable
demo: better console, extensible, paragraph-oriented
scrollbar should work as a separate space too (e.g. influence some external value)
demo: infinitely zoomable table, each cell is the table itself
	will require limiting rendering depth (or < 1 pixel size), so it won't stackoverflow
	and resetting the zoom, else we'll hit that depth sooner or later
	and rotating slowly, for total mind blow - gonna need `clip [circle ..]` to be the clipping region of rotor
truly rich text (hypertext) widget - where text is mixed with other (interactive) spaces
rename grid-view to data-grid?
demo: debugger, need to mark functions, store values of all words during last iteration or 2-3 last iterations,
	and be able to explore those (where spaces come to help)
+ demo: round lists (like in games or sketchbook) - showing the power of container/layout
splitters for UI panels
inspect https://nicepage.com/nicepage-review for anything useful
allow size to be an integer in `field` - so it will infer height automatically from font and adjust it on the fly
demo: very basic layout designer for simple webpage-like shite, one others should be able to build upon
    good example: https://discuss.streamlit.io/t/dynamic-grid-layout-ui/2097
multi level popup menus (probably on separate borderless windows)
demo: example of a glossy style sheet
`arrange` func based on flow layouts that will work with faces?
web preview component to preview the links in the chat
widget: markdown renderer (unless Bolek adds it)
	even more value is in a truly rich editor that can be used for markdown, for email composition, wiki creation etc
consider removing double blocks from styles: just check if 1st word is func/function ?
is there an alternative to styles than draw-blocks? like a set of facets and a special facet `style` for draw commands?
let one define actors for static spaces (in VID or by adding them to the space manually)
in widget reference: create a quick-nav map, somewhat like TOC but with pictures and arranged as a table
UI where user can select table features and export code for this kind of table 
if only bgnd color is specified for a widget (e.g. label), use contrast-with to determine the text color
rename field to input - a low level embeddable input field, while field should be high-level
some help support for space types? in advanced console? maybe interactive, hyper-text?
deeper design docs should include visual examples (snippets + gifs) how this or that works
document resource usage howto:
	- draw can be heavy (10-20ms)
	- spaces do not redraw unless `update` or `invalidate` is called
	- cache? = yes usage
generative planet atlas to demo full-featured table widget; galaxy name hash used as random seed
	a bit of a problem with this: can't sort infinite data, so not so good for table widget..
lists (table) polymorphism: https://www.microsoft.com/en/microsoft-365/microsoft-lists
debug-draw should become a fully-featured layout explorer to help users understand the anatomy of their layouts
	+ and it should move the main window to the left
make tree-view widget a widget creation case study (document the whole process) ?
pekr's idea is to rename `host` to `spaces` in VID/S, and it's reasonable but.. has drawbacks too - need more consideration and input
	dsunanda's vote: "A SPAN is a collection of SPACES held in one VID face"


key aspects: draggable columns, rearrange by styles

QUIRKS

`into` allows to twist coordinates in any way, e.g. meaningfully react to clicks on a rotated/flipped face
	it's also simpler than hittest, so only carries the space's own logic, without duplicating generics
`map` and `into-map`, as well as caching of coordinates in `map`:
	- avoids duplication of the most widely used logic in each space
	- makes hittesting faster because of the cached offsets/sizes
	however `map` shouldn't be relied upon! `into` is the proper way to translate coordinates
	(e.g. think of non-rectangular or rotated areas)
`map` can't be of type `map!` because it should be ordered (e.g. for tab navigation) (can be a hash though!)
map names don't have to be unique (e.g. list may have 1000s of `item`s), just traversable
	but each of it's names has to lead to a unique object
	(unique names help working with each map item though, using path notation)
map/space/size <> space/size -- 1st is in parent CS, 2nd is in child CS (and may also be rotated/translated/...)
name (in a map) is not an identifier (unique) of a space, it's the class! e.g. `hscroll` is a class of horizontal scrollbars
	(however since name is bound to an object it's also an identifier under the hood)
content is a word!
	we want 'content' to appear in styles (and consequently in 'path') so we can process events for 'content'
	but we also want the space it refers to to appear in styles, for that style must process it's own events
	e.g. table inside scrollable - both scrollable/content and table are focusable and handle keys differently
	it's a bit of a special case though.. but it guarantees that inner item name won't clash in map with other names
	(in other words, we can't just put style name into map)
	however, can we maybe just define the events block for each space?
	at least we won't have to look for it..
	but if we do, we'll have to wrap generic spaces and replace events inside
	no... content+name looks cleaner to me
word/object dilemma
	though I've chosen to only have words inside spaces bodies, I'm not 100% convinced yet, not even 70%
	we need names for styling, we don't want dumps of all objects in a space tree (even though as a tree it has no cycles)
	but it creates an obstacle on the high level:
	instead of writing `space/thing/x: 1` we have to write `thing: get space/thing thing/x: 1`
	so far I haven't found a good workaround
	for debugging, I wrote a helper that rewrites paths, but in real time code this is not an option
	`with get space/thing [x: 1]` is the next option, but still not high-level
	I'm still keeping *some* objects, e.g. parts of scroller in itself, but that's it
	so another option to work with `list/items/1` and `space/content`-like paths is to use objects
	but keep the name somewhere as well, and hack `??` and `probe`,
	making them not dive into objects, or not dive into spaces & faces
	still doesn't look like overall win, but maybe I'm missing something
since no space knows it's parent, same space can be used multiple times in the tree
scrollable-space supports `draw/only xy1 xy2` for it's content - to minimize rendering effort by preemptive clipping
lot of parts in space become valid only after it's drawn (couldn't be any other way), e.g. it's map
style! could easily have been a kind of space! that wraps any other space, but it shouldn't be as:
	- that would mix functionality with styling
	- will be harder to change styling
	- styles will appear in the path
	or not??? ok bigger problem:
	- will have to sync style size with content size all the time
	  (can't be done from inside content, so how else? manually? or we resize style that resizes content? stupid..)
there are 2 ways styling can be applied:
	1) each space applies it's own name
	2) parent space applies names from it's own map
	2 has a drawback: e.g. scrollable-space doesn't know the type of it's content, so generic style applies
	then if we put thing into scrollable-space this thing loses it's style, and this is shitty
	but 2 has a benefit too: we can change inner parts without worry, styles will still apply
	e.g. think of scrollbar's thumb - it's a rectangle under the hood but we wanna style it as thumb
	solution? allowing a `style: 'name` field for spaces, which would override `content` generic name
	dumb? or will work?
funny thing about paths: example - we have 3 list-views on a window (a, b and c)
	- from styling POV they should all be called `list-view`
	- from focusing POV they should be `a`, `b` and `c` (i.e. unique)
	  this distinction applies only to faces, not anything inside (yes? maps provide enough uniqueness?)
	  also `root` should be parent to them all
	  ps. solved: faces can carry the name of their type but they're unique objects
	  however, styling faces differently will require some understanding
why keyboard/focus has to be a *deep* path containing focused face along with *all* of its parents:
	tabbed navigation can be done in 2 ways:
	- geometrically by finding nearest item along the path (but this is so called spatial navigation)
	- by finding next/prev node in the space tree
	  but this requires us to be able to transcend limits of one container and traverse all that is shown
	  (even other faces, so we need a parent that holds all space-hostin faces)
	it doesn't have to bother with names though (like content vs list, etc)
	as we're using it to navigate the tree only, so as long as each item leads to an object it's good
	(it could be just an object but then we won't be able to mold this path, easily)
focus is not selection:
	multiple lists can be shown with a selection (maybe multiple) but only one list has a focused item
	so to minimize code duplication and simplify styles we need `focused?` and `selected?` flags in styles
	`selected?` will be a property of `list`, while `focused?` is a global flag (func or logic)
what is root?
	for tabbing, we need to be able to focus both faces and spaces
		so naturally screen is the root for windows, then faces, then spaces
		so keyboard/focus should begin with a screen object
		(need to wrap those objects into words as [screen window face only then spaces] for mold friendliness)
		for styling however, we don't need screens or faces, `root` may refer to the (any) host face
		or should we assign a name to each host face and root will be parent to them all?
		it depends if we wish to style each host differently? no reason so far..
		besides, when one needs it, one just creates a container space with a `style: name` and addresses as root/name/...
		@@ rename root to host? or to face? for clarity
		@@ describe in docs how to style each host face differently
		for hittesting we want coordinates obviously, but what names?
		hittest has to be forceable (repeatable) so wee choose names from maps
		but root? screen? for compatibility with focus? probably no other point, could just start with the host
		[host space space ...] + coordinates (besides we can't translate into screen coordinates w/o R/S, and it's unneeded work)
	do we want tabbing across different windows of the same app?
		I think we do
		that means `keyboard/focusable` has to start with screen or list of screens
	do we wanna tab and scroll to hidden items?
		I think not
		e.g. scrollable [ 
			edit-box
			..1M edit boxes..
		]
		if we (on Tab) show next edit box that's 1M of them to traverse to get out of the `content`
		one will sooner die than finish this quest
		if we just allow skipping to the scrollbar however,
		one can just scroll one page down and tab back into edit boxes and this just works
		partially clipped edit box is still a corner case: we may wanna show it fully
		also, we certainly don't wanna tab to hidden panes of a tab-panel
pros and cons of each styles layout:
	item/subitem another/subitem [style..]       -- currently chosen
	 - have to be traversed once for each item in the path (which is 5+ items long)
	   because absense of 'subitem' in table doesn't guarantee absense of 'item/subitem'
	 + allows style grouping
	 + faster than other styles despite the extra work done
	upper item subitem [style..]
	 - requires another inner loop to ensure that when we look for `item` we don't also find `item subitem`
	 - styles can't be grouped
	 + no confusion on words vs paths, no `to path` or `as path` conversion needed
	 + finding `subitem` automatically finds `item subitem` and upper layers, but still slow (2-5 times)
	   parse can be used but it's even slower still (4-10 times),
	   and parse requires escaping each word in path (as lit-word)
event handlers are separated from space objects for:
	- memory efficiency: one event handler can serve multiple spaces
	- cognitive convenience: separation of code from data and structure from behavior
	- ?unsure? ease of extension: one handler can easily pass data into another (e.g. one that's overridden)
events are passed to the topmost layer that can handle them
	because upper layers have the whole context of how they are using their inner spaces, but not vice versa
	and lower layers may be used with or without upper layers, so they can not produce to the point results
	(at best they can just provide some better abstraction over event data, but most likely it's just dead code)
trickiness of keyboard focus and tabbing:
	e.g. we have layout: scrollable-space [content = list [edit-box ...] hscroll vscroll]
	we want:
	- h/v scrolls to handle keys separately (up=left, down=right, meaning defined by each scroll bar)
	- whole space to react to keys (page down/up, up<>left, down<>right)
	- spaces inside the list can be focused too, e.g. edit-box would handle keys on it's own
	so, focusable face can be a parent to another focusable face
	and we need to consider that during tree traversal,
	and also when assigning the focus - last space in the path is the one focused
	also: for 'content' to be focusable it is imperative that `focus` uses proper style names
there is not space geometry before it's drawn, no size no nothing, because what isn't drawn isn't existing
	and it makes sense, as we want animations and space may be moving in a complex way
	each frame of such move determines different geometry and reacts to events (like clicks) differently
following REP#80, event handlers return values do not control event flow,
	but their bodies are bound to commands that do
iteration over spaces
	there are 2 directions:
	- top-down from the root to the leaves, or bottom-up
	- forward from one leaf to adjacent leaf, or backward
	for tabbing to work properly we want fully reversable order
	i.e. if tab iteration is top-down forward, then shift-tab is bottom-up backward
	for this, listing a tree seems like much easier approach than recursively visiting nodes
unsolved problems of `content: 'name` design:
	to get content/size: `cspace: get content  cspace/size` is a bit complicated
	name changes in the map itself, which may theoretically lead to name collision (and I'm using path access)
reasons not to define `style: ... events: ...` in every space:
	want styles to be an isolated layer, so who defines styles does not have to poke around objects
	want styles names to be composite, like `this-space/that-space`,
		which is harder to map onto objects (and way harder to track after)
	objects can be numerous (= numerous links), while style is defined only once, so it saves some RAM
we need to use fonts in styles, as well as any other thing that may affect space's `size`
	including setting size directly from the style..
	this is all fine when styles are shallow, but what about deep ones?
	we have to somehow apply the tree of styles before `size` is called
	tricky thing: what if size is random or depends on time?
	then whatever we do, `size` and `draw` will not align
	unless we make `size` only available after `draw`... until the next `draw`...
why event handlers should be referred to by paths:
	example:
		item/subitem has handler: sub-item/on-event: [..if path/-1 = 'item .. [do smth]]
	this handler can't be copied into a new style,
	because `path/-1 = 'item` will not produce anything good
	if we however copy the whole tree of handlers, `path/-1 = 'item` is not needed at all
	and we become able to copy handlers together with the space tree
	as such we probably should allow simpler, literal, copying of events:
		events/handlers/item/subitem: 'item2/subitem2
handlers extensibility
	we will want some handlers to control visual behavior and be embedded into the lib
	while other handlers will be written by the user and follow user's logic
	how do we allow both to coexist?
	and how to simplify the extension of one style by another?
	actors should be lists?
	if so, what defined first should fire first
	but how to override? do we want to override?
	there may be levels, like lib-level and user-level, both with multiple handlers..
dynamic size vs draw/only
	it makes little sense to redraw possibly infinite number of invisible items of a list
	however if their sizes change, we can't know until we draw them
	so what to do? obviously we can't draw all the items (performance-wise)
	so it should be advised to re-render those items which size changes, before showing the list
	(TODO: document this limitation)
pinning
	list-view should support some pinned items
	but list is who renders those
	yet list is refilled with items from some offset, not from the head
	so is this even worth it to make list and list-view logic so complicated?
	vs just creating 2 lists, one pinned, one normal?
	scrollbar will be different: will span either the whole height or only of normal items
	2nd option is preferred: more natural
table structure
	2 grids with pinned rows?
	4 grids?
	we want pinned columns to have pinned headers and scrollable
	we want scrolling to be synced vertically, and horizontal scrolling only for the unpinned columns
	how to sync col/row widths?
table column order
	we can rearrange columns by dragging the UI
	and we don't rearrange the data, nor we should expect user-defined data pickers to all support ordering
	we rearrange the visual representation only
	so we should have an order defined in the UI itself: e.g. [2 6 1 5 4 3] (indexes may or may not exist)
	order will act as a simple filter too: what isn't present - isn't shown
	rearranging rows OTOH should be a change in the data, so should not be covered by UI... I think
headers - data or special value?
	I think table should provide a generic interface,
	and picker function should decide if row=1,2..etc is a header string or part of original data array
funny observation about table long/infinite in both directions (x and y):
	it will be impossible to infer row height, because we'll have to scan the whole (infinite) row every time
	without it, rows height will depend on what items are actually shown right now (i.e. where the scrolling window is)
	and rows height will jump around while scrolling left and right
	so such layout is only possible for fixed-size cells, or at least fixed-size row heights
hittest design shows that inner spaces should be named by their styles, not as generic `content`
	though that means that map has to hold those proper names as well, otherwise `hittest/force` isn't going to work
	proper style name is also required for `focusable` block
map: block or hash?
	list style has numerous `item`s which is bad for hash
	and lookups in a map should only be useful for small maps anyway
	so block wins
events chain: still undecided
	e.g.
		list-view
		list-view/hscroll
		          hscroll
		list-view/hscroll/thumb
		          hscroll/thumb
		                  thumb
	if list-view/hscroll takes event, and calls `pass`, should `hscroll` also receive it or only `thumb` variants?
	I think it should, because if specific handler didn't eat the event, generic one still can
logarithmic scroller
	problem of infinite space is that to know it's size we need to render it fully at least once
	otherwise scrollbars won't know how big the current viewport is within the whole
	but since it's infinite, we can't render it
	this is solved by list-view which makes itself a finite view on an infinite space
	and list-view's scrollbar doesn't map to infinity because of that
	but can scrollbar map to infinity? is this possible?
window inside scrollable: how generic it has to be
	one of the applications (apart from chatlog & table) is plot f(t), e.g. timeline of some exchange rate
	it can be huge and instead of rendering it fully (and making scrollbar uselessly imprecise)
	it makes sense to render only a window
	it remains to be seen how to make the plot interactive though
how to contain infinite-scrollable within content limits?
	ideally should be animated: e.g. scroll up, show some empty space, then realign during 0.5sec
	suggestion: let window have some empty space, but scrollable will contain itself using some replaceable algorithm
	however, then scrollbars will not look like they're at the head..
	`available? <direction> <max-lookup>` query func before offsetting?
	then window stays within available limits, but scrollable can optionally scroll itself out then animate
in grid layout, should row/columns sizes be a map or a vector?
	map makes sense because human can only configure a limited set of sizes manually (and prefers it to be less)
	so if one resizes 100000-th row only, map is tiny
	OTOH, if we want fast access to any i-th size, map is a hash lookup, while vector is a direct access
	benchmarks to the rescue: vector access is 90ns, map - 110ns (map miss is 90ns), so given map's other benefits, it wins
	in the future when we have native `sum`, vectors may still win when we want to get continuous sum of sizes
is it possible to auto infer row height in grid mode?
	clearly this case is a problem:
		|  |  |  |  |
		|  |  |  |  |       <- what height is this row? (if all it's cells have vertical span)
		|__|  |  |  |
		|  |__|  |__|
		|  |  |__|  |       <- this row is bound by one cell's span ending at it
	the idea for the 1st is to either:
	- make such row 1/N if it's 1st cell span is MxN
	- use smallest span cell instead of 1st (but why?)
	so, inspecting row cells from left to right:
	- if a cell has Nx1 span - skip next N-1 cells, and add it's height to constraints list
	- if a cell has NxM span, but doesn't end vertically after this row - ignore it, and skip N-1 cells
	- if it does end vertically on this row - subtract all previous rows from it's height and add result to constraints
	- if constraint list is empty, use 1/R of the 1st cell, where R - cell vspan minus rows above
	  (not sure, 1st or the closest rowspan below..)
	  still an issue: can lead to 0-height rows if below cells are empty (content ended)
	- so instead of 1/R it would be better to have a min-height constraint (and simpler)
another problem with span
	how to know which cell occupies XxY row/col?
	have to traverse the whole span map to ensure no other cell above has span big enough to include this cell
	so spanned cells should have span=0x0 if they belong to other cells above or to the left
	or better if they have a link to the starting coordinate
	idea: use negative span to point to the beginning of the multi-cell
	it aligns with the rule that any cell can only be occupied by a single multi-cell
	and then we can occupy & deoccupy it using some helper functions
yet one more gotcha about height cache
	calling `draw/only xy1 xy2` it makes sense to leave rows out of the viewport cached
	that is - to only calculate the size of rows we're actually about to show
	yet, to locate on which row xy1 point maps, we have to use the cached height of that row (and all those before it)
	we could invalidate caches of visible rows in advance if we knew what their numbers are, but we don't
	so the only reasonable solution (not considering full cache invalidation) is..
	to not invalidate the cache at all and let data modifying functions take care of it
	this means that if styles affect the size of the cell on each render,
	it won't be reflected unless those styles also clear the cache
	(such inertia is still a lesser evil than the absence of caching)
	render cache OTOH should be always invalidated as cells are likely going to be animated
how big is the grid layout? is it infinite?
	it'll be easy to limit it with integers
	but is it possible to infer the size from `cells`?
	if it's like 10 items long - easily, if it's 100k - a problem
	should show a warning in this case
	another issue: if it's infinite, how to `draw` it?
	ok so it HAS to be finite, and limit can't be none (but can be auto)
	then inf-scrollable can make it infinite.. but...
	in case row height is 'auto - it may resize itself while scrolling
should grid space contain origin and implement pinned row/col logic?
	normally I would let origin be handled by scrollable
	however, scrollable cannot pin cells without rewrite of the draw func
	so it seems more work.. although we'll see
layout of styles
	1. style: [prefix draw commands] closure: [postfix draw commands]
	this is limited! example: space created during draw of it's parent (one-off space)
	if style gets called before `draw` - it cannot know it's size because it's not rendered
	if it gets called after - then it can't influence draw (set font, rearrange stuff, etc)
	oops... but then it's 2 renders: one to get the size, another to let style influence it
	and then there's a discrepancy: style may have influenced the size, so it wasn't valid on the 1st call
	2. new idea - object:
	style: [
		init: [prefix draw commands]
		done: [postfix draw commands]
		render: function [] [compose [(init) (draw) (done)]]	;-- full pipeline that controls the order of style application
		font: ...
		other words to set in the space
	]
	with an alternative form - single block: style: [[prefix draw commands]] (as it's the most useful)
	an object will be created out of it, space set to it, then ??
	what about `self`? it should be bound to the space, not style
	has a problem! while bind body-of style binds blocks, it can't bind the function!
	if we make function a block - it will leak words...
	recreating an object with functions - too heavy, not acceptable
	3. collect words of style, set them to words of space, then bind is not needed
	but then if we call `draw` for example, draw drags some words from the space
	and bigger problem: some words are global but will be overridden..
	won't work
	4. let style contain only blocks, but compose them in the order they were defined
	then we have binding, ordering, and it's not heavy
	drawback is that styles will have no defaults, and will have to define everything they are using
	another: dynamic assignments are ugly: `before: [(font: ... ())]`
	instead of just `font: ...`
	@@ perhaps paren should be reserved for this.. e.g. `font: (...)`
	but then it requires custom constructor, not just `object`, and thus limits styles in it's own way
	why not just single styling function? it will be given space as an argument
	access to draw - check, custom eval order - check, minimum allocations - check, simplicity - check
	win!
grid cell background - how to draw?
	1) draw grid background => each cell background => each cell contents
	problem: when row height = auto, we don't know the cell/row size in advance
	so we need to render the cell first, but we can't draw it's background not knowing the size of it
	catch 22
	2) draw grid background => each cell contents => draw grid lines
	this way when drawing grid lines we already know the size of each row, so it's ok
	and actually less drawing commands.. M + N rather than M * N
	drawback(?): cells without content look like cells with empty spaces, no distinction
	huge drawback: grid lines will be drawn atop the multi-cell content - inacceptable
	3) so, we need to render cell content first, then estimate row size, then render cell itself
	how? grid lines are a way to hell here..
	maybe.. we cache the cell contents drawn cmds, to eliminate double render
	then: grid bgnd => each cell content => each cell bgnd => each cell content (cached, box sized, alignment applied)
focus has to consider sameness of each path item
	e.g. grid/cell -> other grid/cell look the same but differ in pointed to objects
grid/cell/space vs grid/space - which is better?
	initially cell style was introduced to draw cell background and see it's bounds
	but cells are volatile, and it's better to include them into map
	but do we always want that?
	grid may be used to position other spaces on the layout, not just data, and in that case no need to draw cell boxes
	* cells may help with alignment - global sizing system will work out of the box
	  without cells I would have to do alignment in the grid code, which is bad
	* one of the questions - if the grid is huge, do we want `cell` space for every empty cell?
	  although, most likely if the grid is huge - we either have the data, or *want* to draw cells (like spreadsheet does)
	  will have to ensure only visible cells are in the map - but this may still be a lot, to cover whole `window` of scrolling
	* cells may help with interactivity - in case one wants provide events for cells even if they have no data
	* maybe I could make an option controlling whether to wrap into cells or not..
data & cell wrappers: wrap-data & wrap-space
	are incompatible with the focus model that expects focusable spaces to remain the `same?`
	we can spawn spaces on the fly only if we cache and reuse them for the same visual UI element
	that applies to list items and grid cells
	so cache is the only solution, but it may become huge
	although to keep it small - we could destroy items that were hidden by scrolling
	scrolling out of the sliding window or out of the view?
	defocusing items on scroll is bad UX, so the answer is out of the window
	;@@ TODO: update list-view with window-local cache
	so there's a cached space per each cell - should it be removed when span changes?
	if cell gets eaten by a multicell it automatically disappears from view, so doesn't matter there
	if cell becomes a multicell, it may retain focus, why not
	so no need to destroy cells, but only mark them for full redraw (if that is required)
grid cells array models
	1) cells = map
		supports limits=auto:
		possible to just add cells into the map and limits are inferred
		when mapping data into grid, cells must be filled with a space for each data point
		(if data is truly infinite, will be impossible to fill it)
	2) cells = picker func [/pick xy /size] (that picks from a map by default)
		/size has to infer it from the map itself
		possible to pick from an infinite data array
		no need to pre-fill cells spaces, can be done as they are rendered (but should be cached)
		works for truly infinite data - best argument in favor of it
tricks of grid containing itself in each cell
	draw-ctx and ccache can (and should) be shared between inner and outer renders
	and should only be invalidated before the outermost render
	no static lists should be used in draw
list-view's list width - how to infer it?
	let it be locked to list-view's width?
	there's no width for an infinite list
	and adjusting width to a range of visible items is not great UX-wise
	(scrollbars will show and hide while scrolling)
	but it needs more thought.. esp. when I decide on sizing system
	maybe this will help autosize items' content
on resizing
	some spaces' dimensions are fully automatic - list, data-view (unless limited), image (in auto mode)
	some have only one dimension automatic - tube, paragraph (unless width = none), grid, list with fixed width
	some have only fixed dimensions - all scrollables, image (in fixed mode)
	let's call all these fixed dimensions "free dimensions"
	free as in "no inner constraints imposed" and "can be modified freely at any time"
	automatic are the constrained dimensions out of user's control
	ways to deal with free dimensions:
	1 use plain reactivity (very boring and clumsy way)
	2 define more high-level relations in terms of filling space and aligning in it
	  (also if defined as a function of time they become animations)
	3 use containers that will align/fill themselves with the inner space
	  this is less flexible than pure relations, as only limited to parent/child sizing
	  also floods the space tree with unnecessary entities (=> noise and slowdown)
	so best option seems to build a DSL on top of reactivity (2)
	OTOH some might expect predefined containers (3), esp. interactive ones,
	  e.g. splitters (2-4 panels divided by a draggable delimiter)
	  ? grid columns (draggable slim inter-column patch, inter-row too)
	    key here is that columns are not objects, their widths is part of a map (which is not reactive at all)
	    can be solved by using hash instead, but dealing with /skip is a headache (`map: map` is a lesser evil)
	  columns that fill available space (splitting it using weights) - not interactive, but can be (changing weights)
	what's also useful is expressing sizes in relative terms: window as part of the screen, widgets as part of the window
	and another thing to consider is how to export all this so it'll work on faces too
	  maybe a DSL that creates reactive relations from a description?
	1 more consideration: such free sizes may appear and disappear on the fly, e.g. alignment within visible cells
	  though that can be left to grid itself
	on-resize can be useful to adapt the layout to size, or when rotated
	  some use case: https://egghead.io/lessons/angularjs-angular-material-adaptive-layouts
	  basically, things to show and things to hide (instead of just resizing)
	  though it can be done simpler, by injecting a set of conditions into draw - to select which items to show
	DSL sketch:
	constrain [
		a/size/x -> b/size/x -> c/size/x
		a/size/x <-> a/size/y
	]
	creates 4 separate reactive relations:
		b/size/x: a/size/x
		c/size/x: b/size/x
		a/size/x: a/size/y
		a/size/y: a/size/x
	ideally, but in reality this won't trigger reactivity, so it should change `size:` every time
	constrain [
		split a [10% 100 20% *]		-- can be applied to lists, `*` = rest, `none` may mean "don't touch"
	]
	but this thing can be just added into list itself
	although then list will have a fixed size, so let's call it fixed-list or smth, maybe chain or stack or spring..
	question is, what to do with opposite direction? fill or leave?
	presumably, cases with split should all fill it
	gonna need to make a few UIs first, then try to apply this model to them
so next sizing steps, and considering "free dimensions" idea
	list dimensions that require sizing:
	  - list inside list-view: list width (or height) adjusts to that of list-view (is locked to it)
		or vice versa? one changes list size, list-view adapts? unlikely, since list-view size is fully free
		list itself doesn't change it's free size
		scroller problem: either we leave it's space free even when there's no scroller
		or list width gets reduced when scroller appears, stretching list even more
		these 2 strategies can be chosen by the user, preferably 1st one being the default
	  - grid inside grid-view: this has a lot of options
	    when grid-view size changes, 
	    we could stretch each column or only those configured as stretchable (split example above)
	    or we could default to static size, with the ability to easily define stretch mechanics on top of it
	    grid-view itself should not adapt to grid
	    same scroller problem exists here too, same solutions apply
	list dimensions that can be sized (by the user):
	  - lists in complex layouts, e.g. web ui (take gitter as example, though it's fully static)
	    it can be a grid with unified cells, and an ability to drag some columns/rows sizes
	    or it can be a grid of grids, more complex but may make sense if resulting tree is easier to work with
	    each grid cell then is a list-view and these adapt to cell size, forcing lists to adapt too
	    what's important is to define some kind of aliases to cells here
	    e.g. chatlog will be cell N, convo-list will be cell M, issues-list will be cell P, etc.
	    but that's not an issue, since each cell is a space, it works out of the box
	    (in fact grid can be composed with already named spaces)
	  - visual fx and animations where things get smaller and bigger but have anchors and func of time
	containers of other spaces:
	- grid cell is the most important one - for layouts esp (this includes splitters)
	- list cell is the next one, and list of lists (TODO: automatic switch of layout direction in this case h/v/h/..)
	  however list cell has only zero to one free dimension (depending on width), so it's limited in it's size propagation 
	- data-view usually adapts to it's content, like list
	we want the logic of all this unified by a single shared mechanism
	mechanism should allow fine control: each facet is a formula of other things
	most used forms of it have names and are leveraged everywhere, exposed into VID
biggest sizing question: how does grid cell size affect it's embedded space size?
	grid may deal with generative data, or it may contain named spaces, so there's dangerous duality
	it makes little sense to NOT adjust grid's cell space size to cell size?
	in that case size adjustment may be done by wrap-space itself on in the render func
	or, what is the use case for not adjusting the size? is it ever useful? and in that case, can it easily be switched off?
	types of content in lists:
		text line - e.g. for file view, whole space width is adapted to max line width 
		text paragraph - typical for chats and books, paragraph width is adapted to list width
		 (in chats though paragraph will be wrapped into a custom space with buttons and status and time)
		 (and that custom space will adapt to list width)
		image - usually before or after text, sometimes standalone, lists of icons (e.g. toolbar/appmenu, icons=buttons)
		 in this case we may want control whether each image adjusts to list or not, use-case dependent
		button/dropdown - tricky, we don't want a huge button but may want small button centered in big area
		 so it makes sense to either use a centering container or hardcode alignment logic into lists/gridcells
		 if it's a centering container, container adjusts to list width, but it's height is determined
		 lists of buttons are very common, esp. lists of image-buttons, likely of fixed size and list should adjust
		editbox - more likely we want to adjust it to list width or cell size
		check/radioboxes - will be adjusted
		sliders/progressbars - also
		 I guess there's value in a list that has no width and includes a few different spaces
		 but.. then one will have to either set each space's width manually, or use defaults
		 also, in any case heights should either be default or set manually
		 perhaps we need a common size constraint system, and make sure everything adheres to it
		orthogonal sublist - width is autosized anyway, height may or may not be automatic
		 again, we should both be able to set width from sublist length, or have it fixed
		 although it's more likely that sublist will be a list-view (with fixed dimensions)
	lists can be of two main forms:
		- list that is within list-view, of minimal size, extends indefinitely, shows scrollers if needed
		- elastic list that expands to layout size (or to own constraints), may stretch inner items (`band`? `row`?)
		  if text is wider, it is ellipsized - same as in cells! (see MD lists)
		  this list also may split itself into a few columns / rows
	need to write down how I want e.g. gitters layout be expressed (top-down), then figure out how to do this
	need to write some layouts of some websites and polish the declaration
		GH is a great example: https://s7.gifyu.com/images/GIF-13-Mar-22-17-33-21.gif
		great in that it does so many things and does them so pathetically that a comparison is a must have
		it also highlights the importance of `stretch` item in a list of fixed length, which controls alignment
		(means that we need to extend list to support fixed length, likely fixed by outside layout)
		and that each element may react to layout size, e.g. "Pulls"/"Pull requests"
		funny how tables react to resize: they rebalance, but do not keep the currently visible row
		browser resize is a funny stress test for most sites btw
		https://easings.net/ is interesting: it has 1-2 columns, consisting of 3 icons arranged in 1-2 rows
	"protip" line is most interesting: it contains markdown
		<code> of markdown is not part of paragraph, at best it's part of tube layout
		OTOH, tube cannot tell it's items to wrap, and we need to wrap text, so rich-paragraph is going to be quite a quest
	MD "chips" are also interesting in that they're part of an edit field's text by the look of it (needs rich content) 
	TODO: ask community for site or UI examples that are challenging to consider how spaces may approach these
	great flutter video: https://www.youtube.com/watch?v=kmZz_q7W2jI
possible size to constraint adaptation strategies
	e.g. for cells of a table, when contents does not fit in:
		any text: none / clip / ellipsize / downscale (but not infinitely)
			none is important as it enforces a minimum size of the item, not letting the container itself to shrink
		button/dropdown/check/radio: adapts it's own size, lets the text decide how it adapts
		editbox: adapts own size, for text probably nothing?
		progress bars: scale/stretch easily
		image: clip / downscale
		list: adapts own size, content decides for itself
		row/tube: tricky! inspects constraints of inner items, weights, may contract them
		grid: should not be affected, not automatically at least
		grid-view/list-view: do nothing, but constraints may be used by row to resize them
	but this applies to any other container
	upper constraint bigger than the contents is only useful for containers/editbox/etc
		ie anything that is arbitrarily scalable and/or allows varying content
		no upscaling is done in any case
	if we use tube as row, and to the 3 alignments: back/forth/center, we add fill
	then we have 2 weights:
		weight in a row - divided between all items
		weight in a cell - either expand or not
			alignment is set for a row, but we want to control this per item
			so the value of this is either 0 (don't expand) or non-zero (expand),
			which makes no sense to use a number for, but pair is still the best candidate
		default weight: 0x0 - fixed
		numeric weight: N = Nx0 - stretch along main axis
		pair weight: Nx1 - stretch and fill
		or, do we need weight for this?
	having sec axis constraints should be enough for deciding whether to fill or not!
	weight should not affect the secondary axis at all!
	is there a point in 'fill' alignment then?
		if constraint allows up to 80px, but row is 100px, we have to align the content, so alignment must be set
		then we either expand by default to 80, or don't
		expanding makes sense, because it's turned of by constraint, but if we don't expand, there's no switch to enable it
		similarly, row can be full, but it's extent is bigger than max constraints, so alignment should still be set
		so we must expand the content of each item too when possible
		'width' parameter should be replaced by 2D constraints set
		constraints is a long word, variants: bounds, limits, confines
		can we rename grid/limits?
		for grid it is the max number of cells in both directions, I'd rather use bounds/confines there
	this is still a mess... and what about `draw/on size`?
		image: only changes `size` if it's `none`, or if constaints require it, aims at `image/size` ?
		paragraph: size can be `none` or `size/x` may determine width
			`size/y` will be freely set or not?
			in a cell it should not extend itself, better to clip
			OTOH, if it's bigger it can be scaled down by the grid
			also grid wants it to draw itself down so it can be measured
			in a list we also want it maximized
			we don't want to reset size/y to 99999 before every render to make maximize text
			and we esp. don't want that after on-change
			so draw/on will be a much cleaner and predictable way to tell the size of the canvas
			also we should be able to automate constraining of draw/on argument, somehow
			also since some draws call other draws, this constraining should be done by the caller
			otherwise we end up with a series of constraining calls only first of which is useful
			maybe render/on will do the clipping?
on ranges: perhaps, instead of fixed 100 .. 200 or smth like that (which is shooting blindly)
	we should by default let the minimum e.g. for any text to be the size of that text ?
	OTOH do we ever want to stretch text labels? unlikely
	ranges are for stretches, fields, areas
on ranges and constraints:
	what should be the `canvas` to obtain the minimum space's size? none or limits/min? and if limits/min = none, 0x0?
	specifying canvas as 0x0 is bad idea, 0x0 should only be used internally in `constain` if no lower limit
	on the other hand, none is "infinite" canvas, so it does not really align with the minimum size idea
	it works because if canvas is infinite, there's no point in trying to fill it, so the minimum is taken
	so what about:
	- no limits/min => canvas=none as usual => min size
	- pair limits/min => canvas=limits/min => real size may be bigger or smaller depending on how space adjusts
	  (cell is never smaller, paragraph can be smaller vertically, list can be bigger horizontally and smaller/bigger vertically)
	- integer limits/min => canvas is half-unlimited => adjusts width only (of dubious use... - should it be supported?)
	problem with this is that `none` is different from any canvas in that it doesn't `fill` the space whatever it is
	e.g. paragraph with no min. size => one line, with min. size => will now fit into that min size, which is undesired
	so another idea: min. size is always obtained with `canvas=none` but further once canvas is specified, render constrains it
	in this case constrained canvas can easily be smaller than the size with `none`
	e.g. paragraph will lay itself out in one line with `none`, but will adjust to the width if given
	so, render should not constrain `none` canvas, only pair canvas
	so, tube will unroll any paragraphs into lines, even if they are wrapped into cells, which is also bad
	what if I assume tube only contains cells ever, and then use min-size ?
	list: on `none` will unroll paragraphs then fill it's own width, with `min-size` - will fit paragraphs
	biggest issue is: if no limits/min but have limits/max - unrolled text may be bigger than /max on 1st render
	I can't use 0x0 canvas here, nor it makes sense to use /max to obtain min size
	what in this case should be used? and tube behaves exactly like paragraph... except `none` may be forbidden for it
	this needs more thought...
	maybe really use 0x0 or 1x1? for text this will work for horizontal tubes only, vertical should use `none`
	if text is in vertical tube, it's "min" size will be that written in one line, or limits/max if it's defined
	which will lead to very wide tube
	there can also be different layout intents for text: lay out in one line, or make it as square as possible
	in other words, placing tube inside a tube is a bad idea overall, unless both of it's limits are defined
	also, rendering on `none` when limits/min is defined may make space bigger than /max, so canvas should be limited if possible
	also, /max may not be honored by text: with 1x1, size-text will still return full text size (single column)
	same with list: wide items that stick out of whatever /max is set, will make whole list wider than /max
	this means clipping will have to be done, even though not for every space
	okay for text 1x2e9 and 2e9x1 are most consistent/predictable "min" canvases, what of other spaces?
	btw, on VID side, /min can be `'fit` for text, esp. buttons, radio buttons etc. - meaning never clip the text
	because maybe we want to be able to clip button text? hmm that's unlikely - and possible using `cell`
	then button&co should always render their text in full even on 1x1 canvas
on layout: with the introduction of spaces styles, it will blur the distinction between spaces and faces
	so compatibility has value in this context
	most likely I will need support of full set of VID commands and some superset will be spaces-only
drop-menus: how will they work, considering they place themselves above the other content when expanded (with occlusion)?
	idea is to have a popup layer, where a menu/tooltip is generated
	but such menu may produce additional menus/tooltips so it cannot be a single layer
	so we need to insert menu/tooltip into at the top of the stack (after all the other spaces)
		this choice will make tooltips reside fully within the drawing area (rich text)
		or possibly clipped by drawing area but scrollable to reveal the hidden parts (less useful)
	or we may create another host in case of menu/tooltip, and this host then can appear anywhere inside the screen
		drawback of this is overall bugginess of mouse event pipeline when new faces are spawned/shown
		also each menu and each tooltip will be a separate face, bloating the whole app
		and this face will have to be injected into the face tree, which is also not superb
		also transparency (for non-boxy tooltips) won't work on W7
		or better: it can be another window, but then this window should not be activated, 
			and parent window should stay active
			this will make possible to show tooltips outside of the window border, which is cool
			but in this case non-boxy tooltips become impossible as Red has no transparent windows
	ok new window is not an option, OS tooltips not supported, tried another face:
		view [base all-over on-over [tip/offset: event/offset + 15x15 tip/visible?: not event/away?] tip: base 60x20 hidden "Hello?"]
		view [button all-over on-over [tip/draw: either event/away? [[]][compose [fill-pen white box (pos: event/offset + 15x15) (pos + 60x20) text (pos) "Hello?"]]] at 0x0 tip: box 200x200]
		#1640 concludes tooltips as faces are possible
		a bit dangerous in that if it slows down, one can actually point at the tooltip,
		but this can be fixed by tooltip code
		since tooltip can only be single, it's just one reserved or spawned face, not resource hungry
		still clipped by the window, so alignment have to be calculated properly
		since the glass box way works, this opens possibilities for the menu as well
		but since menu may show submenus, it makes sense to adopt another strategy:
		fill whole window with a trasparent rich-text surface, use it to render all the spaces
		but #5104 shows that it's a problematic approach
		transparent layer is ruled out because it eats events on GTK at least
		(and I'm sure a lot of other bugs will surface with it)
		then spawning new faces on the fly (on the root window) is the best way so far
popup logic
	menus: have to appear under the pointer, so move away closes the window
	  one menu may open another menu and both should stay open until pointer leaves both
	  second layer menu may be replaced (hidden) by another second layer menu, and so on (any number of layers)
	  no need for hints on menus for now for simplicity
	  I do hate popup menus though, worst UX ever, maybe fuck them? so much trouble for me and users
	  main menu is supported natively, but it's shitty and naturally one may want to use a spaces-based one
	  and main menu is still widely used everywhere, no way around it..
	  ribbon? even worse, besides it's not a replacement but an addition to menu (maybe a replacement for toolbars)
	  menus are shown next to each other without gaps so mouse travel is possible across them
	radial menu: is an ok thing but has one level usually and stays only as long as LMB/RMB is down
	  also usually displayed around the pointer, even if gets clipped by the window, which makes it less useful around borders
	  but this is easy to fix
	  UX idea:
	    RMB to show menu until pointer leaves it's radius or another RMB or pick is made (by LMB)
	    LMB to show menu until LMB is up, then pick is made by LMB being up at it
	    this works fine for touchpad and touchscreen
	hints: should be away from the pointer so it doesn't obstruct the text
	  (and I never know the pointer's hotspot so better reserve ~16 px from both sides)
	  new hint always replaces old hint - no two hints are shown at the same time
	  trigger - delay for the first hint, but when one hint is visible next hint should be shown immediately on hover
	  then I need a way to check if other hint is visible or not, to decide the delay 
	so on the base level I want smth like show-popup: func [level layout] and a map of window->popup-face
	to allow hints on menus (esp radial menus) they have to have a special level, e.g. 0, while menus have level 1 and up
	- any level popup replaces popups of the same level
	- popups of level > 0 also hide popups of level above
	I need to:
	- determine if popup level 0 is visible (to adjust hint delay)
	- show popup of a certain level (to replace another popup of that level and hide upper levels)
	- get all visible popups of a certain level and above (to hide and replace popups)
	should hint display be automatic? having /hint inside any cell would show the hint on hover... makes sense
	hint showing logic:
	- timer must be used to display it
	- should hook to host's timer and over events:
	  - host itself because it should fire even when there's no space below the pointer
	  - over so on /away? it hides the hint
	  - timer so there can be a delay
	- hover over the hint itself must hide it, but only if the pointer moved, not if it was already upon the hint
	  should travel ~5px to be considered "moved" (not just ball vibration or sensor jitter)
	- I decided to add travel to hiding as well, otherwise even 1px distance between spaces requires another delay to show the next hint  
cells - idea how to simplify and unify alignment
	cell is a thin wrapper around single space
	cell includes alignment and it's size and alignment is set by the parent
	it then handles how to place it's content, when to cache or render it
	cell will be directly used in a grid and in tube
	on high level, vid styles will often declare a cell+content pair, with both alignment and content defined
	when canvas is not provided, cell should render in it's minimal size (required by tube and grid)
	cells are also needed by grid and maybe list-view to receive clicks on a cell (not on it's content)
	`stretch` becomes just an empty (content-less) `cell`
alignment - with cells and canvas, there's no need to `fill`
	but the question remains, what format to use?
	-1x-1 to 1x1 looks simplest option code-wise
	in vid, we'll use left/center/right/top/middle/bottom as usual
	but should we also use these high-level words in the space itself?
	it may be easier for the user to understand
	though it also may be much harder for him to work with (if he has to)
	e.g. it now has to be a block [center middle]
	separate options for handling X and Y (since words are different)
	also these words have to be often translated into numbers in computations
	question is, should cell also have margin? this would conflict with layout-provided margins
cells complicate tube:
	compare https://i.gyazo.com/3ebe22d96c8b5a6ae726bc3ffe3a63e7.png
	to https://i.gyazo.com/f89ea7c617a5da79dd703bab25579faa.png
	in a tube there's alignment: of every row, and of every item within row
	(2D alignment of rows within canvas should be dedicated to an external cell)
	if we use cells that stretch without restriction, all these alignments are no more:
	whole area is covered, every row is full, and every cell is expanded
	there's however still alignment of every item within it's cell (X/Y - 3x3 alignments)
	moreso, each cell's alignment can be differently configured by the user
	we could use tube's alignment to fill cells alignments, but this would override user's choice
	basically, tube's alignments still make sense for fixed items but become irrelevant once items stretch
idea behind layouts was to abstract geometry computations from container code and rendering
	also to be able to incrementally fill it, e.g. once we reach a certain size
	but this failed miserably because it's only applicable to lists,
	and lists are the only big enough layout where it makes sense
	circular list already breaks incrementality
	tube further complicates this by requiring two renders: first to get min. size, then to expand it's items
	we can still pre-render items without canvas, arrange them in tube layout, set sizes in the map
	and later render on sizes from the map, but this breaks the map idea a bit if rendered size is smaller
	and it certainly will break alignment in this case
	so rendering in the tube layout is a must, because we need to get the size
	or else, we can rely on cells to always occupy the allocated area fully
	for lists the point was to use old item size when possible, and not re-render hidden items, conserving resources
	for tubes, this point is lost - if tube is shown it's almost certainly shown in full or it doesn't matter
	so there appear to be different pipelines that each make sense in their context
	it's tempting then to move render into layout, let it have control
	but then it will have to know the viewport and maybe other gory details...
	an issue with list cache: if item in the viewport changes it's size during forced render,
	it's map geometry will be invalid as it was set for the old size
	this also can only be solved if layout does the rendering
	there must an option for list layout to disable the rendering (in case it's up to date)
	layout interface also changes: should just take a list & settings, spit out size & map
	the only critical feature for lists is to be able to render only selected (visible) items
	which is easy enough to do 
	another idea was that if layout renders, it discards the result, which is wasteful
	but this we can fix with a cache in every space (cache may be a map with key = canvas size)
TODO: for `area` space: it should be possible to do 2-3 renders to work around #5113 issues
	I don't see how this can be applied to a general list-view case though, without performance degradation
	maybe list-view can "learn" how it's content behaves and then apply this knowledge
	but it's no priority 
why drawn block should be copied:
	if I don't, the same style rendered twice in a tree will replace the first result with the second
	even if I had a static draw block per unique space, same unique space still may appear on different canvases
	so, caching is only possible in the sense "return previous result if nothing changed" (no static data involved)
	whether or not to centralize this mechanism I'm still thinking
	I'll need /cached facet to hold previous block and on-change clears it, as well as draw
	another facet will be required to hold canvas size
	alternately, global hash! can hold all that (key = space object),
	which is probably a good idea, because in the lack of apply, render wastes a lot of time
	this will also enable render to have more than one cache, but.. how to invalidate?
	/cache? = yes / /cache? = 'invalid ?
global caching is trickier than I thought 
	since a lot of spaces are composite - from `cell` & `scrollable` to `tube` to `grid-view` etc
	they cannot be directly cached as they never know if their `content` is changed
	so I have to check if all their inner spaces are unchanged, and if not - do a redraw
	so I either have to render all inner spaces (those in `map`) and check against cached code
	or to check if they all are in the cache and have /cache? = true (preferably, since render conditions are unknown)
	but this means to cache a composite space, all of it's inner spaces has to be cacheable as well
	and inner spaces of inner spaces too..
	a single uncacheable space inside a huge parent will nullify any caching attempt
	and of course this is happening, as I don't know what was drawn on canvas=none and what on a geom/size
	and I don't know even if space will look the same if rendered on none or geom/size (though reasonable assumption)
	extend cache with geom/size? then I can search by object and resulting size
	another issue is that I have paths in styles, and styles may differently paint the *same* space in different places
	so say I have a differently paragraph (same object, even same size) how can I cache it?
	the only way to ensure style uniqueness seems to be ensure path uniqueness
	but lookups by path are slow, so I need to lookup by object and then filter by path
	then if I have a path, do I still need xy1 xy2 canvas?
	canvas yes, because e.g. cell is drawn at least twice - on none then on fixed size, and results will differ
	as for scrollable, maybe xy1 xy2 are not that important? TODO: consider removing them
	crap.. `same-paths?` is 10x slower than all the renders, need some kind of render tree marking to not repeat it
	or arrange caches in a tree - should be much faster this way, but may still need marking
	any way to avoid deep tree visiting on render?
	space1 can contain space2 that contains space3 that is changed, and maybe even set cache? to 'invalid
	how does space1 know that without deep visiting?
	the only proper way to handle this is to have host render produce a tree
	then any invalidation will bubble up the tree invalidating all of it's parents
	then validity checking is simple and fast
	meaning that tree has to carry references from all spaces to parents
	but how each space will locate itself on that tree on invalidation?
	direct link to cache node will make spaces unmoldable
	just a path? invalidation will then have to traverse the whole path to find the node
	it's okay even if not ideal
	anonymous word referring to a cache node? that's 260 bytes more per space or ~2MB for 8k spaces (tube-test)
	maybe a path of words - reduced into a path of space objects - `get` natively?
	unfortunately `get` matches objects by content, not by pointer, and select/same is slower
	OTOH I have to invalidate it all up anyway, so I'm either going up from a cell, or down from root to cell
	so a path should be enough if I invalidate everything along it
	cache should then still contain space objects for quicker search (words are looked up by symbol)
	and be structured as a tree, containing rendering parameters, size and code for each node
	hmmm space cannot contain a path, since it may be at different tree nodes
	so how to invalidate it? it has to be invalidated on all nodes anyway
	idea: let cache still be flat, but each node will contain links to all it's last parents
	going to be unwieldy to keep it up to date, so let there be 2 caches:
	- cache of space object, render conditions and results
	- 2 tree caches for each host: one that is being built, another for validation lookups
	  and they're swapped on every host render
	  or one? I only need single validation lookup if it succeeds
	  but if it fails - it's subtree cannot be cleared as I wanna know what children are still valid
	on the bright side, no point in keeping render parameters except canvas (needed for double rendering) 
	no, damn, flat cache is ruled out because we have path styling
	TODO: hosts have to be roots of render-cache because styles may include host names
	but right now there's no support for that, all hosts appear as `host` in paths
	with this, cache? = 'invalid is not needed anymore, but a global `invalidate` function?
	tricky: if space appears multiple times in a tree, I cannot mark it as valid until it's rendered in all places
	thus /cache? = 'invalid is a bad strategy
	there's also these issues:
	- I save cache into new tree, but only look up in the old tree, thus re-rendering the same thing many times until tree is committed
	- I look it up in both trees, but then once I add render on one canvas to new tree, it's auto-validated for other canvases in old tree
	  which results in fetching the outdated look
	also after some thought, invalidation is a rare procudure and it can be slow
	only cache lookups should be optimized to the fullest
how to lay out rows? that is, should it be a block for data-view or row style or what?
	what's in the block? how to denote separators? should separator be a globally shared widget?
	e.g. image+heading+text+switch like on android?
	or label+hotkey+'>'marker like in menus?
	on a lower level this can be just a VID/S `row [image %img note "heading^/text" switch off]` or smth
	but can I leverage type richness to get rid of template declarations and fit row into a single template?
	easy: char!/file!/image! -> image, string! -> note, logic! -> switch, string! -> hotkey
	no need for separator, can just declare first string as weight=1, rest as weight=0, with possible overrides
	may still use issue for hotkeys, with the aim to automatically react to these hotkeys
	how does the row know it's has submenus? aha, menu layout does that
	also `>` stands in it's own column which hotkeys do not intersect, which makes it a bit too special
	how to generalize? hmm what about `pad` space which I assign the same size as `>` limits, so they align
	great!
	don't like the weight=1 for general row though, maybe lists will have a special kind of row?
	band? list-row? line? bar? strap? lane? band best hints at elasticity
	may ofc just use row and add a stretch space, may even call it `<->`, and let menu add it
	also menu may add `pad` or impose a limit on stretch, so hotkeys never get close to text
menu DSL:
	1st iteration:
	  menu: a block! [any menu-item]
	  menu-item: [layout opt hotkey action]
	  layout:    [string! | block!]
	  	string is interpreted simply as text,
	  	while block may include other data as accepted by data-view
	  hotkey:    [issue!] e.g. #Ctrl+O
	  action:    [code | menu] (block is a submenu in this case)
	  code:      [paren!]
	hotkey as issue is bad: e.g. `Ctrl+,` is not a word type
	but hotkey can be a string easily, why not? or tag.. let it be string for now until a better idea
	so 2nd iteration:
	  menu: a block! [opt flags any menu-item]
	  menu-item: [any content [code | submenu]]
	  content: [space | data]
	  data: [string! | char! | image!]	- | logic! ? for list rows/bands
	     question then can I use the same dialect for both menu and lists?
	     certainly, android rows are either submenus, toggles or actions (popups?)
	  space: [word!] - refers to an existing named space, e.g. <->
	  code: [paren!]
	  submenu: [ahead block! into menu]
	  flags: [ahead block! into [any flag]]
	  flag: ['radial] - the only supported flag for now
	  instead of text, menu/list will use `note` or.. how to name? message? record? all off
	  ah! label could support multiple lines out of the box!
	  `line` is a nice name for horizontal divisor, maybe `hline`, but only if `vline` makes sense, which I'm not sure
	  OTOH divisor doesn't have to be a line, it may be styled differently
	what other than string/char/image/logic (or word referring to these) can be data? (also a question for data-view)
	  block can be a sublist? but it makes little sense, unless it's somehow different from the outer list
	  besides, menus use blocks
	  url will need a special url style that is underlined and can be clicked (TODO)
	  other datatypes should be molded perhaps - as will be best for data-view
	  word should probably be formed too, and reduce used when needed - useful for data-view of arbitrary red content
	  data block is not a VID/S block - it doesn't support any space parameters or anything, just a plain list of stuff
	  data block should likely become a tube, not list, so it will go to the next line gracefully
is there a difference between tube and row? other than possibly applied style? row is only a VID style then
on radial menu UX
	click and drag UX:
	- on windows, up event is received by the same face that got down event
	  alt-up is not tied to alt-down though
	- on linux, both alt-up and up are tied to alt-down and down
	  so there's platform discrepancy
	right-click+drag on touchpad is not convenient, needs physical button press
	  then needs 2nd finger to make downward dragging, as buttons are at the bottom
	on touchscreen it's quite okay, with pen too
	I'll go with simple alt-up, as with other menus, for now
	but TODO: there must be some configurability in this
	  though how? maybe introduce some higher-level "events" like tap+drag+release gesture?
how different are VID/S widgets from space templates?
	VIDgets do not introduce a new template, so do not require a separate style defined,
	which helps keep style sheet clean and efficient
there's a collision in terms: styles, templates, themes - how to resolve?
	template is final, it's a space specification block
	"theme" makes sense to name color sets, i.e. look may be android-like but themed differently
	"skin" this is smth like stylesheet - a collection of styles (on wikipedia - same as theme)
	"look n feel" - wider, changes the way of interaction - not supported out of the box in spaces
	hmm maybe I just write "VID/S style" vs "space style" to make it clear
bug/limitation: adaptive space with a map cannot be shared at all, since map should be different for various canvases
	how can this be solved? and should it be?
	if the same space appears on various canvases simultaneously, it should have multiple sizes and maps
	for current spaces to be shared either size should be fixed or it should not be interactive (then who cares about size)
	this may yet cause issues if single generic/stretch appears everywhere, at least it's size will be invalid
	can size & map not be properties of the space itself? but properties of the tree?
	this needs more thought, maybe even entire change of model, though utility value of such sharing is tiny
	if I completely disable sharing, then parent list may have single parent per space
	also, render cache doesn't have to be a tree then
	it makes perfect sense to share simple spaces, like `empty` or some image of fixed size - quite often sensical
	"chips" (stupid name) may also be shared, fine
	stretch and frame - no reason to share really, because they have to be redrawn on a new canvas anyway
	sharing of adaptive container spaces looks even less useful - I can't see any good use for that
	so the rule will be clear: only spaces that do not depend on canvas can be shared
	TODO: ideally some kind of warning mechanism, but not sure how to detect unwanted sharing
	if I eventually find a reason every space can be shared, the model changes will include:
	- separate `tree` of spaces generated by last render
	- no /size or /map in spaces themselves - these will have to be in the tree
	- as such, tree navigation and work with spaces become a little more involved
	  e.g. global words assigned to spaces now will not have direct access to size, etc
	  maybe I'll then add a map [canvas -> [size map drawn]] into each space, or hold it separately, undecided
	- other properties like `limits` or `color` raise questions - how stable they are? or what else changes with canvas?
	  e.g. some space may adjust font to size
	- another dark side of sharing: if same spaces are in the same container, or even that container is multiplied
	  then focus system will go bananas, because it relies on uniqueness of the path
	  so, another requirement for now: focusable spaces are not shareable
timers and performance
	there was a bug in timers that made them jump to the last iteration
	when it was fixed, timers started taking 99-100% of tube-test time to simply iterate over 8k spaces 65 times per sec
	foreach-space 8000 items = 69ms wow
	list-spaces alone = 54ms
	obviously it's a no-go, how to speed up?
	need to somehow only iterate across spaces with /rate and have their paths ready and known
	may utilize it from cache? in this case may make sense to make cache more "official"
	other option is to hunt for "rate" facet change, but that doesn't give me path
	and has to be in space's most basic on-change to avoid duplication
	ok this may work: on-change keeps a registry of "rated" spaces, but paths come from the cache
	then each path is again tested incrementally against handlers list
	made a tree inside render-cache but it went badly: 2 hosts appear to have the same tree, timer events broken
	because top level spaces have no parent
	trying to introduce host parents.. nah this is too fragile.. as expected, I have to make a separate tree
	thing is, for timers invalidation should not affect the tree, but for further invalidation?
	if e.g. there was invalidate/only - next full invalidate should not be stopped
	if there was a full invalidate, child spaces of invalidated parents still may be invalidated
	so tree has to persist, and invalidation should go up to the root without any shortcuts
	if tree is not affected by invalidation, it then can be discrarded by render-face, swapped to a new tree
	the only trouble is how to at the same time, build a new tree and keep the old one for relations check
	if "emerging" tree is used by the builder, new relations will not be reflected on the old one
	have to at the same time add relations to both trees, then later discard the old one
	at least this will make cache more stable, though also slower
	another issue: emerging tree will not include cached (not rendered) subtrees, how to copy them?
	ideally it should be just a node that is attached together with it's children, but it's way more bookkeeping
	funny, both for invalidation and for timers all I need is path
	so if I have a path, I've no need for recursive calls
	and those paths can be generated in a way similar to list-spaces, just with added key and metadata
	and list-spaces can just reuse this tree, while foreach-space doesn't even have to copy it
	though single key will correspond to multiple paths (in rare cases), hashtable should handle it fine
	or maybe it's reasonable to group all paths into a single node?
	first need more high level path api to abstract the low level parts
	the question is one of ordering.. listed tree is ordered by map order
	but rendered tree is ordered by render call order, which is no good for tabbing
	so list-spaces will not reuse the render tree?
	or render may create ordered nodes for children, since it has access to the map?
	bigger question is, whether such complication of render is worth simplification of invalidation? quite unlikely
	during render no event should ever happen, so it invalidates only isolated immediate children
	they may be in the old cache, not in the new, but they have to be moved into the new anyway
	so all cached stuff will be moved, and nobody knows if it's still valid, so trees grow anyway dammit
note on size and reactivity:
	I wanted to put `quietly` before each /size: setting, but it disables reactive relations obv
	and those are used in VID quite a lot
	so, using `maybe` now 
fast hittesting over grid - how?
	problem: `cell` is a generic name, within a map search is linear, even if it was a hash
	thus into-map will be slow with thousands of cells
	to fix it, need some map of cell-object -> cell-offset
	tried to introduce scache (object->geom or object->offset) for this exactly
	but scache can't just return geometry or offset, because that may change with canvas!
	may make it return index into the map, but that has the same pitfall:
	last drawn map may not be the one render fetched from cache
	and though I may rely on it's length being unchanged, this is rather fragile and will fire back at me
	so for now, until a better idea, hittest on grid is slow 
	nor scache worked for pinned-or-not cell identification, because grid/cell style has no access to grid!
	as a result, pinned cells cannot have different size (only colors),
	because grid-ctx/pinned? does not affect rendering from calc-height (and locate-line)
	for the time being: using locate-point (until proven slow) 
infinite canvas bores me to death already
	main reason - I'm treating infinite dimensions somewhere as 0, somewhere as alias to limits/max, it's a mess
	can I get rid of it? use only finite and 0?
	main actors:	
	- scrollables (incl. list-view, grid-view)
	  these either have min/max limits defining their size, 
	  otherwise should fill the available finite dimensions
	  infinite dimensions not applicable, use zero instead to minimize
	- cell/box
	  same as scrollables
	- paragraph/area
	  paragraph assumes finite width, so no problem here
	  height is ignored? should never assume height lesser than the text,
	  but may be made to expand vertically when canvas allows
	- text
	  for text the distinction between 0 and inf width is clear - sets wrapping margin
	  height is irrelevant/ignored
	  none is treated as inf canvas by rich-text, but not by spaces
	- tube/row/column
	  same as paragraph/text, 0 makes sense to stretch vertically, inf to stretch horizontally
	  fixed width to assume the wrap margin
	- hlist/vlist
	  ignore canvas size along main axis
	  finite secondary axis is filled, infinite makes no sense, at best works as zero
	- image
	  inf makes no sense, but should mean 1:1 display, that is different from 0x0
	  0x0 should mean either 1:1 or downscaled to 0 (preferably, because who wants an image with scrollers?)
	  current algo just downscales if canvas requires, but not upscales unless /min is not met
	so inf canvas is only applicable to flow layout, theoretically
	in practice, is it useful?
	rows are made to stretch to fixed width
	text? intent is to not wrap it, and get the actually needed size
	so infinity stays but must be treated by most spaces as zero
	exceptions: flow and image
	0xINF canvas is used by tube to hint the rendered item across what axis it should minimize itself
	grid/cell renders items on WIDTHxINF and items should minimize across inf but fill width
	ok, the issue I found was that row was rendering it's items on 0xN canvas, while list - on INFxN canvas
	made list same as row, but now how to lay out menus? vlist sets x size to 0, row follows suit, results in 2 rows
	somehow vlist must set x size to inf, but when? how?
	vlist's default canvas maybe none, but if it's inside a row, it will get 0x0 anyway, so I have to work with that
	some "wide" flag that would ignore the canvas width, set to inf? not good for resizeability
	default none to infxinf canvas and let row pass none to items too?
	ok so let vlist draw items on infx0
	let row on infx0 draw on infxinf - resulting in almost hlist-like layout
	while row on Nx0 will work as it does today - start from 0xinf, stretch, align
	vlist has alignment too, that doesn't break
	row in a row? normally, outer row will draw on 0xinf then stretch, this also works fine
	row within hlist? hlist will render it on 0xinf, and never stretches, and that's fine, use row in a row instead
	scrollables? should use infxinf, so rows don't wrap 
shit! timers are still a bottleneck, because e.g. `inspect system` creates 428 rated spaces (scroll/roll timers)
	and the culprit is paths-from-space, surprisingly
	anyway, not optimizable - have to turn off unused timers (when scrollbars are hidden)
field origin is tricky!
	can't modify it in the draw func, because every draw on zero canvas (in a row/list) will anchor origin to the beginning
	can't modify it in key events purely, because resizing would put caret out of view (though acceptable tradeoff)
	maybe fixate it in key events, but temporarily adjust during draw?
	now the problem is, a few key events may be processed in a row, 
	one invalidates the layout, others have no access to it now
	requiring a render cycle would slow down key input (which is already not so great)
	also, layout is not guaranteed to be aligned with /size - size may be fetched from cache
	possible to fix by tracking /size change and ensuring a layout exists or created
	OTOH, field is always single-line, so this problem only exists for `area`, which can wait
	layout invalidation without setting it to none?
	oh ez fix: look in /layouts for an existing one?
	nope, canvas can be 2e9, but size will be determined by the limits
	ok, it's a bug that canvas is not the same as size? no it's not, since it is used to determine if redraw is needed
	usage of 2e9 has another drawback: `constrain` in presence of upper limit, makes it finite
	but finite canvas gets filled
	maybe constrain should not affect infinite dimensions?
	really this canvas system is quite messy due to it's implicit assumptions
	maybe it would be better to rework it, pass an object with dimensions to fill and dimensions to minimize along
	or simply do not call constrain in render, call it in each space when setting size?
	on-change can't work here since this size should also apply to other things
	;@@ `none` canvas should probably be normalized to infxinf by render itself though; removes `default` from everywhere
scrollable origin is tricky too!
	when scrollable is inside tube - tube calls it on a 0 canvas and scrollable adjusts it's origin
	since this happens all the time, it becomes impossible to scroll after a certain length
found a problem in tubes
	I want them to fill the available limited canvas dimension (otherwise will have to set limits manually = boring)
	on the other hand, I want them to split into rows when they can't fit into one
	and these requirements conflict with one another, as split rows will then become bigger than should be
	here's an idea: render them on infinity first
	once rows are known, adjust the widths, then we know each row height
	then distribute available row height to rows according to weights (just modifies the 3rd render)
even bigger one
	column [paragraph] - if paragraph is long, goes out of the canvas, can be fixed but fix is a kludge
	column [row [paragraph]] - fix doesn't work
	test code for polygon: column [row [data-view wrap?= on data= "abc def ghi klm nop abc def ghi klm nop abc def ghi klm nop abc def ghi klm nop abc def ghi klm nop abc def ghi klm nop abc def ghi klm nop abc def ghi klm nop "]]
	but main issue is that this is so messy I can't even think of it
	have to redesign the canvas notion!
	idea is: have both canvas and explicit filling intent (which axes to fill or not)
	in simple form, single pair should be enough:
	WxH   - fill whole canvas
	-WxH  - fill vertically
	Wx-H  - fill horizontally
	-Wx-H - don't fill, just don't hang over
	0 will still be used for minimization
	+infinity will still be used for e.g. unconstrained text rendering inside horizontal list etc
	that means, finite dimensions may not mean "fill" but they will always mean "clip" at that point, which for flow layouts makes sense
	`none` will not be used explicitly, only when passing over from a function called without canvas
	lack of /on or canvas=none will be normalized to infxinf to simplify every other canvas handling code
	hmm encoding and decoding canvas all the time seems like quite an overhead
	maybe pass it as two arguments?
	or to hell with encoding, not need it, no need to pass fill flag?
	dammit, canvas should be passed as it was, with fill flags
	so best option then is to use test functions
	shit math is too complicated, subtraction, taking maximum etc
	better to have two arguments then: abs canvas and fill flags
	if fill flags are a block, it has to be copied, so pair should be a better fit
	encoding+decoding 2 pairs should be simple though
	let negative values mean 'fill=true' then for simplicity (since infxinf is positive and doesn't fill)
	most important point of introduction of canvas/fill split is to carry over info about outer canvases
	e.g. spaces within a column within a row should not be bigger than the row,
	and explicit rounding to zero/inf loses this info, so should be avoided when possible
	list of course is infinite by design
	so far encoding/decoding is fine.. nice properties of using negatives for fill and enabling fill = 0 and 1 for "no fill":
	- can pass fill=1x1 and if canvas is zero, fill will be set to 0 too
	- extend-canvas just works: no change needed
	- render cache needs no change while canvas is a single value, negative and positive canvas leads to different cache hits
	- encode-canvas is super easy operation
there's a problem with window autosizing (again)
	list-view sets window to a 1D multiple of it's sizes, so there's never a horizontal scroller
	even if content is bigger than the window!
	generic resize sets window to 2D multiple, so it becomes huge, much bigger than content
	need to think more on this aspect...
	what if: not only window gets smaller if it's content is smaller
	but it also gets larger if it's content is larger?
	what limits it is `available` returns up to max-size
	and max-size is the only way to tell it what size it should align to.. well, so far it was
	now there's canvas and window may use it! while max-size may stay big in 2D sense
	oh, list-view has it's own available which just uses canvas for width (as max size)
	I cannot resolve this after all?.. it's ambiguous
	list items either draw themselves to fit into canvas, or into infinity
	(list could have a controllable wrap flag)
	problem here is wrapping instead, why it's not wrapped (files are single words?)
	hmm... rethinking
	if there was no `available?`, only draw:
	list-view:
	1. has canvas and limits - adjusts canvas to limits, calls draw on adjusted canvas (fills width? yes)
	2. has no/inf canvas but limits - uses /min limit only, calls draw on it (may be 0x0) (fills width? yes)
	3. has no/inf canvas or limits - because content may be infinite, cannot infer the size, uses 0x0 as default /min limit
	   or rather passes canvas as is? if it's infinite so be it
	window: always receives canvas, maybe 0x0, or infxinf:
		list-view gives it 1x10*size canvas, to fill horizontally
		grid-view gives it 10x10*size canvas, not to fill (web too)
		in this case important part of the canvas is not lost, and no need in max-size too, or it can be set on the fly
		problem with max-size is that available may then return 0 if window is 0 sized: need to ensure available works with content, not window
	auto sets its max-size? there was a problem with this on 0x0/inf, but maybe it doesn't need explicit max-size anymore
	> remove max-size
	let it just multiply the canvas and pass it to the child? but then the original canvas will be lost
	hmm actually it's maxsize is the argument to draw/only, and /on can still carry original canvas and filling intent
	but clipping intent is the issue?
	grid: will be no clipping
	list: it's okay if it can clip at it's width
	what window passes on as canvas?
	may want to fill the original canvas (only if window is <= canvas), but not window
	worse case: I could expose a lever to control list-view's 1D/2D behavior which controls the filling
	also list itself fills it's width, but should it expand it's width to the canvas? for clickability of items, yes
	so, now I add `available`.. why? because rendering is so much slower
	what does it need?
	in list case:
		available takes canvas - why? because locate-line needs to render items to wrap around canvas width when they can
		vertically, it doesn't care about window and may render outside of it
		> horizontally, it should just tell how big is the current window (with all items rendered inside it's 1x10 size)
		so then it doesn't really need the canvas, but it needs window to render itself (and items)
		oops, it needs canvas for vertical estimation, because wrapping affects window height with limited content
		> but if it's already rendered to window size, then it's enough to use this size
		but first window renders get zero canvas, so how big should it render itself? how does it know 10x multiple of what it will take?
		need to take care not to call available before window gets it's final render?
		> also window maybe should not render anything if it's zero-sized
		previous available? design didn't use canvas - only window/max-size as canvas, so it was losing canvas and it didn't reach content
		this must change.. but still, available should not cause renders and use already rendered geometry!?
		except it can't: it's called on window edges, and requires to render items around the window, and canvas to wrap these items
		> so, roll will have to provide canvas, but roll is an event.. maybe it should use list-view's current size as canvas?
		possible danger: during tube rendering cycle, list-view gets rendered at various sizes and causes a roll incidentally
		> need to ensure, that roll is only called from timer events and never from the rendering chain itself
		> pages must be synced with list-view/grid-view pages or removed from them? I'm for removal
funny discrepancy found in window rendering:
	window over list needs to render all items within itself, so we know size of items and can adjust scrollers' look
	window over grid *must* not render all items, or it becomes way too slow
	however if it doesn't, and rows are autosized, then how will it estimate scrollers offset/portion?
	it's only simple on an infinite grid - just take the window size (though window knows nothing about that)
	moreover, draw itself is a serious performance hit, so it would be best to exclude clipped out items from it's block
	dammit.. another unsolvable puzzle
	so: window only has to be rendered on a canvas once, next time it's cached (rightfully)
	then cache doesn't work? or window gets invalidated?
	aw shit.. window receives /only xy1 xy2 so it's not cached, indeed, and same goes for grid
	but even if window gets cached, initial render of 10x10*size window is super slow (well, 100x times no shit)
	so in general /only idea just doesn't work, needs redesign
	initially meant for a scrollable over a container
	but then even for a list, cacheability of items is questionable unless canvas stays the same
	and even bigger issue is the initial render time.. just 5k text strings by 120ms take 6 seconds
	grid can only avoid that if has fixed line height and I limit the rendering region to the viewport
	so idea here is passing small region from window to the grid and list, and those will decide if they need to render more
	and for that they need to know max rendering area covered by window, so /only needs 4 args, not 2 (ok maybe 3 considering canvas)
	/window xy1 xy2 origin ? or simpler, 2 args: xy1 is always negative, origin is at 0x0, size up to canvas? nice!
	/window is a good name then
	XY1 is now coordinate before or at 0x0, left corner of the window relative to current window(!) location
	XY2 then is after window
	shit no! this is not simpler - same but reversed, old xy1-x2 were better (at least nonnegative)
	while grid/origin contains current viewport (canvas) offset within the window but if I limit drawing I can't cache window
	but if I don't limit, it'll be too slow to render and window size will have to be made too small
	omg! can't cache window for grid then, but have to - for list? at least I have a /cache? flag
	also, when not cached window is slow, let's see:
	1) each cell creation is 2 spaces creation, each ~100us, 2x120x100us=24ms
	   but wrap-data is not the culprit here, it's slow when approaching right bottom part of the window!
	   btw 2x2500x100us=500ms
	2) draw-range is indeed suspiciously increasing it's time towards bottom right! up to 350ms!
	   now that's dumb, it always draws content starting from the 1st unpinned cell! of course it's slow
	   solved! smooth now! 70fps @ 50x50 grid
	now just to restore window to it's positive xy1 xy2 coordinates...
problem with scrollers now...
	scrollable removes them from canvas so in case scrollers will be visible, content stays fit
	but then window (grid) only draws itself up to scrollers, and there's an empty band in case they're invisible
	ideally I would make a few renders to fit scrollers properly, but with a grid-view it's not an option
	~3x slowdown? or rather, exponential, since each scrollable will multiply it's subtree by two?
	grid knows nothing of scrollers size either, pity
	don't wanna use an adhoc kludge too, what to do?
	add an /over-render [pair!] facet to grid so it could be fixed in case default scroller's size is changed?
	or maybe grid's canvas should simply be increased, because why not? it doesn't align anything anyway
	(increase also increases the final size, so that doesn't work)
	can scrollable remember it's scrollers state to avoid extra re-renders? will in this case initial render still be too slow?
	also this auto-adjustment would be useless for grid, only applicable to lists.. so must be a configurable flag
	general scrollable doesn't know if it's applicable to it's content or not
	ok idea:
	/content-type (/extension ?) facet for all scrollables which can be:
	- 'planar - default, single render on a full canvas
	- 'vertical - for list-view, texts - 1st render on full canvas, 2nd (if doesn't fit) - without vertical scrollbar
	- 'horizontal - for (unused now) horizontal lists - 1st on full canvas, 2nd (if doesn't fit) - without horizontal scrollbar
	because I simply have no idea how to properly feed the canvas sizes to a content which extension strategy is unknown 
	
	
	


Timer design:
- we want to maintain the desired frequency of updates (otherwise every animation/game will be CPU dependent)
  but at the same time we don't want to lock execution in a single timer when it takes longer to process than it's period
  so we have to be able to drop events but since this affects the animation, a warning should be printed
  and we want to be able to disable those warnings for production code
- on a W10 laptop in battery saving mode face timer never repeats in less than 14ms, but usually it's 14-30ms
  but if we use `wait 0` as yield func, we never get intervals more than 15ms
- in performance mode timers are still 65 fps, so are `wait 0` granularity
- will need multimedia timers for anything more precise, or at least will need to set system timer to 0.5ms interval
  (that's 2000 fps compared to current 65 fps)
  this will increase the power consumption though (from what I read on the web)
- so there is very little point in doing our own event loop, just to improve the fps by a negligible effect
  and for now just using `rate 100` dispatcher should be good enough
- yet we can improve the animation by providing the delay to timers
  e.g. desired rate = 50fps = 20ms, if 30ms have passed that's 50% delay, if only 10 then that's -50% delay
  (0% would mean a perfect match)
  then one should scale the animation to that delay
  or 100% would be perfect match, 50% for 10ms, 150% for 30ms? it's a question of `dt` vs `dt - 1`
  depends on the argument name also, if it's `delay` then `dt - 1`, if it's `scale` then `dt`
- this will require a table of all timers' last trigger time
- how to determine *when* to call a timer handler?
  e.g. host has rate 67 = 15ms, and child has rate 30 = 33 ms
  if we only call the timer *after* the guaranteed 33 ms, we will get really 45 ms
  so it makes sense to call the timer before it expires, like up to 7ms before? half of the host resolution
  no that's bad.. rather we should accumulate bias and try to minimize it...
  OK it works up to 64 fps, where timer is slower than the desired fps...

MUSEUM
this is bad because it mirrors the code from draw
; into: function [xy] [
; 	any [
; 		all [within? xy 0x0 box  reduce [content xy]]
; 		all [box/x < size/x  within? xy o: box * 1x0 vscroll/size  reduce [vscroll xy - o]]
; 		all [box/y < size/y  within? xy o: box * 0x1 hscroll/size  reduce [hscroll xy - o]]
; 	]
; ]
; into: func [xy] [
; 	any [axis = 'x  xy: reverse xy]
; 	all [
; 		within? xy 0x0 size
; 		any [
; 			all [xy/x < back-btn/size/x  reduce [back-btn xy]]
; 			all [xy/x >= (size/x - forth-btn/size/x)  reduce [forth-btn xy - (size - forth-btn/size * 1x0)]]
; 			all [xy: xy - (1x0 * size * offset)  xy/x >= 0  xy/x < (size/x * amount)  reduce [thumb xy]]
; 		]
; 	]
; ]

this is bad because it doesn't build a map, and consequently we can't hittest against the map
; (back-btn/draw)
; ; (put items 'back-btn 0x0  back-btn/draw)
; translate (map/thumb/offset: o: back-btn/size + (stripe * offset) * 1x0) [
; 	(thumb/draw)
; ]
; translate (map/forth-btn/offset: back-btn/size + stripe * 1x0) [
; 	(forth-btn/draw)
; ]

this can't work because of #4788
; cached-length: none				;-- set to none when it's out of date
; on-deep-change*: function [owner word target action new index part /extern cached-length] [
; 	;@@ TODO: more actions
; 	;@@ BUG: on-deep-change is a mess, totally useless
; 	;@@ e.g. take/last - reports index=0 and series at head, so how to figure out the changed part?
; 	nitems: length? items
; 	case [
; 		none? cached-length [exit]				;-- nothing to modify
; 		word <> 'items      [exit]				;-- it's not items that changed
; 		any [
; 			'cleared = action 
; 			all [part * 3 > nitems  nitems > 10]	;-- part is too big: better recalculate size normally
; 		][
; 			cached-length: none  exit
; 		]
; 		find [appended poke poked] action [
; 			target: skip target index
; 			+-: :+
; 		]
; 		find [inserted remove take cleared change changed] action [
; 			+-: :-
; 		]
; 		'else [do make error! "TODO: unsupported-action"]
; 	]
; 	partlen: 0
; 	repeat i part [
; 		item: get target/:i
; 		item-size: item/size
; 		partlen: partlen + item-size/:axis
; 	]
; 	partlen: partlen + (part * spacing/:axis)
; 	if part = nitems [partlen: partlen - spacing/:axis + (2 * margin/:axis)]
; 	+-: either find [inserted appended changed] action [:+][:-]
; 	cached-length: cached-length +- partlen
; ]

consequently this becomes too slow...
; cut-items: function [
; 	"remove items until list size is within constraints"
; 	where [word!] "head or tail"
; 	limit [integer!] "enforce min number of items to keep"
; ][
; 	items: content/items
; 	len1: get-length
; 	num1: length? items
; 	cut-one: select [head [take items] tail [take/last items]] where
; 	while [all [limit > 0  not within-limits?]] [
; 		limit: limit - 1
; 		do cut-one
; 	]
; 	len2: get-length
; 	num2: length? items
; 	reduce [num1 - num2  len1 - len2]
; ]
; within-limits?: function [] [
; 	len: get-length
; 	num: length? content/items
; 	all [len <= max-length  num <= max-items]
; ]
; get-length: has [size] [
; 	size: content/size
; 	size/(content/axis)
; ]

on-deep-change is no place for list refill, cause such thing becomes hard to control & predict
; if all [word = 'origin  source  content/items] [
; 	if case [
; 		;@@ TODO: where to hold this 200ms delay? where to enforce it?
; 		;-- one can click 'page-down' faster than 200ms and get to the end unnoticed, but 100ms - unlikely
; 		;@@ TODO: this means this delay has to be ONLY in on-over, but how?
; 		;@@ also it's bad to have origin auto changed (breaks code continuity) - better to have it on demand
; 		0:0:0.100 >= difference t: now/precise last-refill-time [no]
; 		origin/y >= (0 - look-around) [
; 			;@@ TODO: add-items/cut-items should happen inside draw, only planned here
; 			set [add-n: add-len:] add-items 'head jump-length
; 			cut-items 'tail add-n
; 			set-quiet 'source skip source 0 - add-n
; 			origin/y: origin/y - add-len
; 		]
; 		(csize: content/size clen: csize/:axis) - (map/content/size/:axis) + origin/y <= look-around [
; 			set [added:] add-items 'tail jump-length
; 			set [cut-n: cut-len:] cut-items 'head added
; 			set-quiet 'source skip source cut-n
; 			origin/y: origin/y + cut-len
; 		]
; 	] [set-quiet 'last-refill-time now/precise]
; ]

scaled triangle doesn't play well with styles including an outline
; triangle!: make space! [
; 	size: 16x10
; 	dir: 'n
; 	; need `into` here? or triangle will be a box from the clicking perspective?
; 	draw: function [] [
; 		set [p1: p2: p3:] select [
; 			n [0x2 1x0 2x2]								;--   n
; 			e [0x0 2x1 0x2]								;-- w   e
; 			w [2x0 0x1 2x2]								;--   s
; 			s [0x0 1x2 2x0]
; 		] dir
; 		compose/deep [
; 			push [
; 				scale (size/x / 2) (size/y / 2) [
; 					triangle (p1) (p2) (p3)
; 				]
; 			]
; 		]
; 	]
; ]

items in list's map do not have to have different names, as this requires too many words
and it also messes the map up when moving items around (e.g. in add-items 'head)
still, we need each `item` to refer to a unique object so we need context to wrap it (unless we drop names)
sadly (#4165) find/same word doesn't work, but there doesn't seem to be a need for it anyway
; add-item: function [] [
; 	p: make paragraph! []
; 	o: object compose [(to set-word! rejoin ["item" 1 + length? content/items]) (p)]
; 	append content/items w: first words-of o
; 	w
; ]

slower 2-3 times on error than the all [] approach
; focused?: function ["Check if current style is the one in focus"] [
;	attempt [(get last path) =? (get last keyboard/focus)]

version for styles like [item subitem [style]] - slower 5x
; get-style: function [
; 	"Fetch styling code for the current space being drawn"
; 	/named path [path! block!] "Path to look for (defaults to current-style)"
; 	/closing "Fetch a closure instead"
; ][
; 	path: tail as [] either named [path][current-style]
; 	#assert [not head? path]
; 	; if head? path [return []]							;-- empty path
; 	c: [
; 	table: either closing [closures][styles]
; 	; table: find table path: back path
; 	; unless table [return []]							;-- no such style
; 	attempt [			;-- stops when find/tail fails
; 		until [												;-- look for the most specific fitting style
; 			;-- search order here: from the space name (most common) to it's full path (most uncommon)
; 			;-- to eliminate the number of failed lookups (performance)
; 			p: back path
; 			t: back table
; 			until [block? first t: find/tail t p]
; 			style: t/1
; 			table: skip t 0 - length? p
; 			head? path: p
; 		]
; 	]
; 	]
; 	either 'hscroll = last head path [clock/times c 100000][do c]
; 	unless style [return []]
; 	; style: select table path
; 	#assert [block? style]
; 	space: get last path								;-- need to expose it's context to the style
; 	; print ["style for " head path "is" style]
; 	compose/deep bind style space			;@@ how slow this bind will be? any way not to bind?
; ]

version for styles like [item subitem [style]] but using parse - slower 10x
; get-style: function [
; 	"Fetch styling code for the current space being drawn"
; 	/named path [path! block!] "Path to look for (defaults to current-style)"
; 	/closing "Fetch a closure instead"
; 	/local style
; ][
; 	table: either closing [closures][styles]
; 	path1: as [] either named [path][current-style]
; 	#assert [not tail? path1]
; 	space: last path1
; 	c: [
; 	path: clear []
; 	parse path1 [collect into path any [set w word! keep (to lit-word! w)]]
; 	append path: tail path [set style block!]
; 	until [
; 		path: back path
; 		any [
; 			not parse table [to path to end]
; 			head? path
; 		]
; 	]
; 	]
; 	; #assert [block? style]
; 	either 'hscroll = space [clock/times c 100000][do c]
; 	unless block? style [return []]
; 	space: get space								;-- need to expose it's context to the style
; 	; print ["style for " head path "is" style]
; 	compose/deep bind style space			;@@ how slow this bind will be? any way not to bind?
; ]

looks much less obfuscated using `with` and `map-each`
; context [
; 	w: table: none
; 	foreach table [styles closures] [						;-- replace words with paths
; 		parse get table [any [change only set w word! (to path! w) | skip]]
; 	]
; ]

update command should not exit from the event handler
; update: does [throw/name 'update 'event-command]

doesn't work because of #4802
; actors: [
; 	;-- using lightweight wrapper instead of the direct link to :event/dispatch
; 	;-- for actors will be copied at some point and we want as little footprint as possible
; 	on-down: on-up: on-mid-down: on-mid-up:
; 	on-alt-down: on-alt-up: on-aux-down: on-aux-up:
; 	on-dbl-click: on-over: on-wheel:
; 	on-key: on-key-down: on-key-up: on-enter:
; 	on-focus: on-unfocus: func [face event] [events/dispatch face event]
; ]

moved this into the proper event handlers, became less messy
; on-down [
; 	; events/dispatch face event
; 	set-focus face
; 	path: hittest test event/offset
; 	?? path
; 	;-- keyboard support
; 	path2: parse path [collect any [keep word! | skip]]
; 	while [not empty? path2] [
; 		either find keyboard/focusable last path2 [break] [take/last path2]
; 	]
; 	unless empty? path2 [keyboard/focus: path2]
; 	?? keyboard/focus
; 	;-- scrolling support
; 	either where: any [
; 		find path 'hscroll
; 		find path 'vscroll
; 	][
; 		axis: select [hscroll x vscroll y] where/1
; 		ss: get where/-2
; 		drag-in: none
; 		move-by: :scrollable-space/move-by
; 		switch where/3 [
; 			forth-arrow [move-by ss 'line 'forth axis  ss/refill]
; 			back-arrow  [move-by ss 'line 'back  axis  ss/refill]
; 			forth-page  [move-by ss 'page 'forth axis  ss/refill]
; 			back-page   [move-by ss 'page 'back  axis  ss/refill]
; 			thumb       [drag-in: reduce [where axis ss/origin]]
; 		]
; 		face/draw: render test 'root
; 	][
; 		;-- not on a scrollbar
; 		if where: find path 'content [
; 			ss: get where/-2
; 			drag-in: reduce [where 'list ss/origin]
; 		]
; 	]
; ]
; on-up [
; 	events/dispatch face event
; 	drag-in: none
; ]

this design is too hard to reverse properly (for tabbing), and is also tricky to get right & to follow
I'm not using an iterator for this is time critical code and iterator would at least double the 'select' count
if we don't do it recursive, we'll have to find where we are on the map every time we wanna get one level up
so it is recursive
no return value for simplicity & speed
`continue` can be used but not break (too much overhead to support it)
; foreach-space*: function [spec [block!] path [path! block!] "(modified)" dir [word!] "forth or back" code [block!]] [
; 	space: get name: path/1
; 	if map: select space 'map [
; 		path: next path
; 		either dir = 'forth [
; 			if name: path/1 [map: find/skip map name 2]
; 			end?: [tail? map: skip map 2]
; 		][
; 			map: either name: path/1 [find/skip map name 2][at tail map -2]
; 			end?: [head? also map map: skip map -2]
; 		]
; 		until [
; 			change path map/1			;@@ do we want to expose geometry to code?
; 			foreach-space* spec path dir code
; 			clear path
; 			do end?
; 		]
; 	]
; 	set spec head change change/only [] head path space
; 	loop 1 code
; 	; clear path
; ]

first space in the `path` determines the root (upmost space in the tree)
foreach-space will jump to other branches but can't go behind it
thus `path = to path! host/space` designates the whole tree as iteration range
`path = some window or panel` designates a root face, iterating only over hosts inside it ;@@ TODO
to limit the scope just shorten the path
iteration starts with the root path (no way around it), then to the first child or first neighbor
/back affects only neighbor iteration direction, but it's still top down always
; foreach-space: func [
; 	'spec [word! block!] "path or [path space]"
; 	path [word! path! block!] "Starting path"
; 	code [block!]
; 	/back "Traverse in the opposite direction"
; ][
; 	foreach-space*
; 		to block! spec
; 		to path! path		;-- makes a copy (will be modified), also forces index to 1 (so `head` will be relative to it)
; 		pick [back forth] back
; 		code
; ]

; scrap design where style name was overridden from the /style facet
; 	it caused too much complexity but was limited:
; 	it required every space to define it's name
; 	but that didn't help, as then every 'back-arrow' and shit would become just 'triangle'
;   background: we don't want events for 'triangle' but may want them for 'back-arrow', so we use map names.
;     but we don't want event for 'content' (generic), we want them to what style 'content' points to.
;     for this to work /style override needs to be defined for every space but this kills the map names; doesn't work

; scrap design where 'content' was pointing to an object
; 	because that required the object to provide it's name somehow
; 	while all we have to do is say `content: 'name` and that solves it all

; scrap design where map had 'content' word that pointed to another word and we would lay out e.g. `content/list` in map
; 	caused too much complexity in `into` functions

now generalized as an event previewer
; refocus: function ["internal use only" face [object!] path [block! path!] "words only (modified)"] [
; 	while [name: take/last path] [			;-- reverse order to focus the innermost space possible
; 		if find keyboard/focusable name [	;-- pairs are not found so skipped automatically
; 			f: face
; 			until [
; 				insert path anonymize f/type f
; 				none? f: f/parent
; 			]
; 			focus: append path name
; 			unless keyboard/focus = focus [
; 				#debug [print ["Moving focus to" as path! focus]]
; 				if all [
; 					old-name: last old-path: keyboard/focus
; 					handler: find-handler old-name 'on-unfocus
; 				][
; 					do-event old-name 'on-unfocus [handler keyboard/focus none]	;-- pass none as 'event'
; 				]
; 				set-focus face
; 				keyboard/focus: focus
; 				if handler: find-handler name 'on-focus [
; 					focus: append clear [] focus					;-- copy it in case user modifies/reduces
; 					do-event name 'on-focus [handler focus none]
; 				]
; 				commands/update
; 			]
; 			break
; 		]
; 	]
; ]

turns out scrollbars don't get focus in all programs I have around..
somehow I think in old versions of Windows it was the case, but apparently not anymore
; focusable: make hash! [scrollable hscroll vscroll]
; scrollable/on-key-down [path event] [
; 	set [ss: scroll:] reduce path
; 	;@@ TODO: keys for the ss itself
; 	unless scroll [pass exit]				;-- let the inner spaces take it
; 	axis: scroll/axis
; 	move-by: :scrollable-space/move-by
; 	code: switch event/key [
; 		down right [[move-by ss 'line 'forth axis]]
; 		up left    [[move-by ss 'line 'back  axis]]
; 		page-down  [[move-by ss 'page 'forth axis]]
; 		page-up    [[move-by ss 'page 'back  axis]]
; 	]
; 	either code [
; 		do code
; 		update
; 	][
; 		pass								;-- key was not handled (useful for tabbing)
; 	]
; ]

it's unwise to prepare the whole data array for display (can be huge)
instead, pickers should be defined to prep lines of data when needed
; spaces/table: [
; 	...
; 	prep-data: function [] [						;-- preps data for display, independent of `source` format
; 		pin: min pinned dim: data/size
; 		prep-into  1x1                  pin                  pinned-headers/source
; 		prep-into  as-pair pin/x + 1 1  as-pair dim/x pin/y  normal-headers/source
; 		prep-into  as-pair 1 pin/y + 1  as-pair pin/x dim/y  pinned-columns/source
; 		prep-into  pin + 1x1            dim                  normal-columns/source
; 	]
; 	prep-into: function [xy1 xy2 tgt] [
; 		if any [xy1/x < xy2/x  xy1/y < xy2/y] [clear tgt  exit]
; 		w: xy2/x - xy1/x + 1
; 		for y: xy1/y xy2/y [
; 			either row: tgt/:y [clear row][append/only tgt row: make [] w]
; 			for x: xy1/x xy2/x [
; 				append/only row data/pick x y
; 			]
; 		]
; 		clear at tgt y
; 	]
; ]

balancing row heights between 2 list-views is just too much effort:
- will have to pre-render to produce list items
- will have to change height constraints of each item in list (can be huge), then render again
- will have to reset those constraints post-render, so next render is not affected
instead, a single list-view should be made with each row supporting pinned columns
; spaces/table: [
; 	...
; 	draw: function [] [
; 		maybe pinned-columns/index: normal-columns/index	;-- sync indexes
; 		maybe pinned-columns/origin: as-pair pinned-columns/origin/x normal-columns/origin/y	;-- sync origin
; 		maybe normal-headers/origin: as-pair normal-columns/origin/x normal-headers/origin/y
; 		; can we get rid of extra render??? need better pipeline
; 		foreach [name _] map [render name]			;-- prerender lists to ensure they all have enough `items`
; 		;-- balance row heights and cell widths
; 		foreach [left right] reduce [
; 			pinned-headers normal-headers
; 			pinned-columns normal-columns
; 		] [
; 			repeat y length? right/list/items [
; 				litem:  left/list/items/:y
; 				ritem: right/list/items/:y
; 				unless all [litem ritem] [continue]		;-- one of the lists is shorter
; 				litem: get litem  ritem: get ritem
; 				case [
; 					litem/
; 				]
; 			]
; 		]
; 		; reset constraints so they won't affect the next render; any better idea????
; 	]

unused
; list-ctx/item-box: function [list i [integer!]] [
; 	if word? list [list: get list]
; 	ofs: list/margin
; 	if i > 1 [
; 		guide: select [x 1x0 y 0x1] list/axis
; 		ofs: ofs + (guide * list/size/only 1 i - 1)
; 	]
; 	reduce [ofs list/size/only i i]
; ]

this doesn't work if word = 'value, silly mistake
; anonymize: func [
; 	"Return WORD bound in an anonymous context and set to VALUE"
; 	word [word!] value [any-type!]
; ][
; 	bind word object compose [(to set-word! word) :value]
; ]

doesn't work if value is a set-word
; anonymize: func [
; 	"Return WORD bound in an anonymous context and set to VALUE"
; 	word [word!] value [any-type!]
; ][
; 	bind word construct/only compose/only/into [(to set-word! word) (:value)] clear []
; ]

didn't use it
; grid-ctx: context [
; 	;-- grid is like list - simply arranges spaces given to it
; 	;@@ should grid/list be called grid/row or not? technically it may be grid/column as well...
; 	spaces/grid: make-space/block 'list [
; 		;-- `items` should contain lists to display, though these lists are not exposed in the map
; 		axis: 'y			;-- items = rows by default
; 		pinned: 0x0			;-- how many rows/columns to pin (move data to the head to make it pinned)

; 		draw: function [/only xy1 xy2] [
; 			;@@ keep this in sync with `list/draw`
; 			r: make [] 10
; 			guide: select [x 1x0 y 0x1] axis
; 			clear map
; 			max-size: 0x0									;-- size of the biggest item in a column/row
; 			i-item: 1										;-- item (column by default) index
; 			p: margin
; ;@@@ SHIT so much useless low level code here! how to generalize? how not to write grid-view after list-view? how to lay out items in one expression?
; 			while [max-size/x >= 0] [						;-- becomes <0 when no more items
; 				max-size: -1x-1
; 				foreach list-name items [
; 					list: get list-name
; 					item-name: pick list/items i-item
; 					item: get item-name
; 					drawn: none
; 					skip?: if only [
; 						unless item/size [drawn: render item-name]	;-- prerender to get the size
; 						max-size: max max-size item/size
; 						p2: p + item/size
; 						isec: (min p2 xy2) - (max p xy1)			;-- intersection size
; 						isec <> max isec 1x1						;-- optimized `any [isec/x <= 0 isec/y <= 0]`
; 					]
; 					unless skip? [
; 						;@@ TODO: style selected-item?
; 						compose/only/into [translate (p) (any [drawn  render item-name])] r
; 						compose/deep/into [(item-name) [offset (p) size (item/size)]] tail map
; 					]
; 				p: p + (spacing + item/size * guide)
; 				p: max p item/size
; 			]
; 			self/size: p + margin
; 			r

; 		]

; 		on-change*: function [word old [any-type!] new [any-type!]] [
; 			if word = 'axis [
; 				if :old = :new [exit]
; 				normal: select [x y x] axis
; 				foreach item items [		;-- dynamically switch each list's direction
; 					spc: get item
; 					spc/axis: normal
; 				]
; 			]
; 		]
; 	]
; ]

tabbing is trickier than expected:
when I move focus in `key-down` to another face (e.g. field)
next `key` event goes to that face instead
so I need to delay focus change until `key` event fires
cannot use `key-up` since it does not repeat
can use `key` directly but will miss Ctrl-Tab, used by field/area
option: use `key`, miss Ctrl-Tab, but let area/field have some 'unfocused' state changed by Esc/Enter
(this will help spatial navigation as well)
; register-finalizer [key-down] function [space [object!] path [block!] event [event!]] [

this didnt scale:
in the end I had to include style name into the definition block,
else define-handlers doesn't have the name and thus can't accept inner styles
also error reporting was inferior
; extend-handlers: function [
; 	"Extend event handlers of STYLE"
; 	style [path! word! map!] "Style name, path or a map of it's event handlers"
; 	def [block!] "A block of: on-event-name [spec..] [code..]"
; ][
; 	all [
; 		not map? map: style
; 		none? map: get as path! compose [handlers (style)]
; 		map: #()
; 	]
; 	#assert [map? map]
; 	r: copy-deep-map map							;@@ BUG: copy/deep does not copy inner maps unfortunately
; 	while [not tail? def] [
; 		either word? :def/1 [						;-- on-event [spec] [body] case
; 			set [name: spec: body:] def
; 			def: skip def 3
; 			list: any [r/:name r/:name: copy []]
; 			#assert [								;-- validate the spec to help detect bugs
; 				any [
; 					parse spec [
; 						word! opt quote [object!]
; 						word! opt quote [block!]
; 						word! opt [quote [event!] | quote [event! none!] | quote [none! event!]]
; 						opt [if (name = 'on-time) word! opt quote [percent!]]
; 						opt [/local to end]
; 					]
; 					(?? handler  none)				;-- display handler to clarify what error is
; 				]
; 				"invalid handler spec"
; 			]
; 			append list function spec bind body commands
; 		][											;-- substyle: [handlers..] case
; 			#assert [not map? style]				;-- cannot be used without named style
; 			#assert [set-word? :def/1]
; 			set [name: spec:] def
; 			def: skip def 2
; 			unless r/:name [r/:name: copy #()]
; 			; name: to word! name
; 			substyle: as path! compose [(style) (to word! name)]
; 			r/:name: extend-handlers substyle spec
; 		]
; 	]
; 	r
; ]


list-view's infinite space logic is now decoupled from the list logic
; ;@@ TODO: chat will need reverse indexing... though how about `source` function gets -1 -2 -3 ... ?
; ;-- there's a lot of logic in this space only to make it fast
; ;-- list items may vary in size, and not knowing the size of each item
; ;-- we can't just multiply the index by some number, we have to traverse the whole list
; ;-- but list can be huge, and all these functions try to minimize the size estimation effort
; list-view-ctx: context [
; 	spaces/list-view: make-space/block 'scrollable [
; 		source: []		;@@ or a function [index]? or support both?
; 		data: function [/pick i [integer!] /length] [
; 			either pick [source/:i][length? source]
; 		]
; 		index: 1										;-- index of the first item within source
; 		;-- geometric constraints:
; 		;-- * it will display at least 1 item but no more than max-items
; 		;-- * it will drop items starting after max-length along the axis
; 		;-- setting max-length to big enough value makes list size constant = max-items
; 		;-- big enough max-items makes list always show all of the items
; 		max-items:   200
; 		max-length:  10000
; 		jump-length: 100								;-- how much more to show when rolling (px)
; 		look-around: 50									;-- zone after begin and before tail that triggers roll-edge (px)
; 		roll-timer: make-space 'space [rate: 4]			;-- how often to call roll-edge when dragging (can't override scrollable/rate)
; 		list:  make-space 'list [axis: 'y]				;-- list/axis can be changed to get a horizontal list
; 		content: 'list
; 		;@@ TODO: on-change or assertions should ensure max-items >= 1, and sane values for the rest

; 		append map [roll-timer [offset 0x0 size 0x0]]		;@@ any better way to have a separate rate?

; 		filled?: no										;-- true when items are cached
; 		invalidate: does [set-quiet 'filled? no]		;-- call this to force items update

; 		wrap-data: function [item-data [any-type!]][
; 			spc: make-space 'data-view []
; 			set/any 'spc/data :item-data
; 			if list/axis = 'y [spc/width: size/x - (list/margin/x * 2)]		;@@ what data width to use for horizontal lists?
; 			anonymize 'item spc
; 		]

; 		scrollable-draw: :draw
; 		draw: function [] [
; 			any [filled? fill-items]
; 			scrollable-draw
; 		]
		
; 		add-items: function [
; 			"Insert items into list from position WHERE"
; 			where [word!] "head, tail or over"
; 			ext-len [integer!] "Min extension length in pixels (if enough available)"
; 			/local idata
; 		][
; 			x:         list/axis
; 			spc:       list/spacing/:x
; 			items:     list/items
; 			new:       clear []
; 			target:    either where = 'over [items][new]
; 			offset:    switch where [tail [index - 1 + length? items] over [index - 1] head [index]]
; 			available: either where = 'head [index - 1][data/length - offset]
; 			if 0 = available [return [0 0]]						;-- optimization
; 			;@@ it should not know list's internal spacing logic (in case we change the list).. but how?
; 			added-len: either empty? items [list/margin/:x * 2 - spc][0]
; 			+-:        either where = 'head [:-][:+]
; 			repeat i min max-items available [
; 				set/any 'idata data/pick offset +- i
; 				either item: target/:i [
; 					#assert [in get item 'data  "item should have a /data facet to be used in list-view"]
; 					set/any in get item 'data :idata
; 				][
; 					change at target i item: wrap-data :idata
; 				]
; 				item: get item
; 				unless item/size [render 'item]					;-- render it to get the size
; 				added-len: added-len + spc + item/size/:x
; 				if added-len >= ext-len [break]
; 			]
; 			added-num: any [i 0]
; 			switch where [
; 				head [insert items reverse new]
; 				tail [append items new]
; 				over [clear skip items added-num]
; 			]
; 			reduce [added-num added-len]
; 		]

; 		cut-items: function [
; 			"Remove items until list size is within constraints"
; 			where [word!] "head or tail"
; 			limit [integer!] "Enforce min number of items to keep"
; 		][
; 			items: list/items
; 			num1: length? items
; 			size: list/size
; 			x: list/axis
; 			len2: len1: size/:x
; 			; #assert [max-items >= limit]		;-- min shouldn't be bigger than max
; 			min-rem: num1 - max-items					;-- num items over max-items
; 			pick-item: select [head [first items] tail [last items]] where
; 			rem-item:  select [head [take items]  tail [take/last items]] where
; 			repeat i num1 - limit [
; 				item: get do pick-item
; 				item-size: item/size
; 				len3: len2 - item-size/:x - (list/spacing/:x)
; 				all [len3 < max-length  i >= min-rem  break]	;-- check if after removal list will be too short
; 				do rem-item
; 				len2: len3
; 			]
; 			num2: length? items
; 			reduce [num1 - num2  len1 - len2]
; 		]

; 		at-head?: does [(0 - origin/(list/axis)) <= look-around]
; 		at-tail?: function [] [
; 			x:     list/axis
; 			csize: list/size
; 			max-origin: csize/:x - map/list/size/:x
; 			(0 - origin/:x) >= (max-origin - look-around)
; 		]

; 		roll-edge: function [
; 			"Move position of ITEMS within DATA if origin has approached one of the edges"
; 			/head "Force adding items at the head"
; 			/tail "Force adding items at the tail"
; 			; return: [logic!]							;-- whether actually refilled or not
; 		][
; 			unless any [head tail] [head: at-head?  tail: at-tail?]
; 			if all [tail head] [return no]				;-- empty list or less than the viewport
; 			case [
; 				head [
; 					set [add-n: add-len:] add-items 'head jump-length
; 					cut-items 'tail add-n
; 					self/origin: origin - (add-len * 0x1)
; 					set-quiet 'index index - add-n
; 				]
; 				tail [
; 					set [added:] add-items 'tail jump-length
; 					set [cut-n: cut-len:] cut-items 'head added
; 					self/origin: origin + (cut-len * 0x1)
; 					;@@ BUG: we should trigger on-change/index so it can be detected by other spaces
; 					;@@ OTOH if we do, we cause another add-items/over call and lose the added items
; 					;@@ so how to solve this?
; 					set-quiet 'index index + cut-n
; 				]
; 				'else [return no]
; 			]
; 			yes
; 		]

; 		fill-items: does [
; 			add-items 'over max-length
; 			set-quiet 'filled? yes
; 		]

; 		;-- when to fill?
; 		;-- - width changes => new length
; 		;-- - text of one of the items changes => new length -- can't track this automatically
; 		;-- - source index changes => new content for each item
; 		scrollable-on-change*: :on-change*
; 		on-change*: function [word [word! set-word!] old [any-type!] new [any-type!]] [
; 			scrollable-on-change* word :old :new
; 			if find [source width index] word [invalidate]
; 		]
; 	]
; ]

development (non-reduced) version of extend-layout in case I break it later
; extend-layout: function [dir [word!] amount [integer!] /keep where [block!]] [
; 	; print ["extend" dir amount]
; 	lt: list/make-layout
; 	unless empty? list/items [amount: amount - lt/spacing/(list/axis)]
; 	switch dir [
; 		n w [+-: :-  n-max: (base: index) - 1]
; 		s e [+-: :+  n-max: data/length - base: index - 1 + length? list/items]
; 	]
; 	#assert [(select [n y s y e x w x] dir) = list/axis]
; 	repeat i n-max [
; 		name: wrap-data data/pick base +- i		;-- guarantee at least 1 item (else spacing could be bigger than the requested amount)
; 		#assert [not find/same list/items name]
; 		render name
; 		lt/place select get name 'size
; 		if keep [append where name]
; 		if lt/content-size/(list/axis) >= amount [break]
; 	]
; 	lt
; ]

; window/fill: function [xy1 [pair!] xy2 [pair!]] [
; print ["fill" xy1 xy2]
; 	;@@ TODO: e / w support
; 	#assert [0 = xy1/x]
; 	#assert [window/size/x = xy2/x]
; 	#assert [any [xy1/y = 0  xy2/y = window/size/y]]

; 	initial?: window/map/list/offset = 0x0				;-- on first fill, do not align with the lowest/rightmost edge
; 	x: list/axis
; 	dir: select
; 		pick [ [x e y s] [x w y n] ] xy2/:x = window/size/:x	;-- s/e = tail fill (or head to tail), n/w = head fill
; 		x
; 	switch dir [				;-- get already rendered parts out of the requested window
; 		n w [xy2/:x: xy2/:x - extra? dir]
; 		s e [xy1/:x: xy1/:x + extra? dir]
; 	]
; 	;-- window now lies purely outside of the list
; 	req-size: xy2 - xy1
; 	?? req-size
; 	lt: extend-layout/keep dir req-size/:x clear new: []
; 	#assert [not empty? lt/items]

; 	ext-size: lt/content-size/:x + either empty? list/items [0][lt/spacing/:x]

; 	offset: window/map/list/offset				;-- we can count invisibles right now from list/offset
; print [dir offset "new:" length? new "lt/size:" lt/content-size]
; 	rem: 0
; 	foreach': switch dir [n w [:foreach-reverse] s e [:foreach]]	 ;@@ should be for-each/reverse
; 	foreach' [name: geom:] list/map [			;-- count the number of invisible spaces
; 		o: geom/offset + offset
; 		visible?: bbox-overlap?  0x0 window/size  o o + geom/size
; 		either visible? [break][rem: rem + 1]
; 	]

; 	switch dir [										;-- add items
; 		n w [
; 			#assert [not empty? new]
; 			insert list/items reverse new
; 			self/index: self/index - length? new
; 		]
; 		s e [
; 			append list/items new
; 			maybe self/index: self/index + rem			;-- rem can be 0
; 		]
; 	]

; 	rem-size: 0
; 	if rem > 0 [
; 		removed: switch dir [								;-- add items, remove invisibles from `items` & `map`
; 			n w [
; 				take/last/part list/items rem
; 				take/last/part list/map rem * 2
; 			]
; 			s e [
; 				remove/part list/items rem
; 				take/part list/map rem * 2
; 			]
; 		]

; 		rem-1st: removed/2
; 		rem-last: last removed
; 		rem-size: rem-last/offset + rem-last/size - rem-1st/offset + lt/spacing
; 		rem-size: rem-size/:x
; 	]
; 	;-- now that we know removed size we can calculate the new list offset
; 	offset: switch dir [
; 		n w [
; 			ext-size * select [n 0x1 w 1x0] dir
; 		]
; 		s e [
; 			rem-size * -1 * select [s 0x1 e 1x0] dir
; 		]
; 	]

; 	foreach [name geom] list/map [					;-- relocate the visible spaces now that we know the offset
; 		geom/offset: geom/offset - offset
; 		;-- impossible to verify visibility here because we don't know list/offset until we get the size
; 		;-- and don't know the size until we render it and we can't render it until we relocate the items
; 		; o: window/map/list/offset + geom/offset: geom/offset - offset
; 		; expect [bbox-overlap?  0x0 window/size  o o + geom/size]
; 		; #assert [bbox-overlap?  0x0 window/size  o o + geom/size]
; 	]

; 	; unless list/size [render/only 'list xy1 xy2]	;-- refreshes list/size after removal ;@@ TODO: possible to get rid of it and use `lt`?
; 	; render/only 'list xy1 xy2		;-- refreshes list/size after removal ;@@ TODO: possible to get rid of it and use `lt`?
; 	either new-size: list/size [
; 		;-- update the size, without re-rendering anything
; 		new-size/:x: new-size/:x - rem-size + ext-size
; 		maybe list/size: new-size
; 		; render/only 'list xy1 xy2
; 	][
; 		;-- render the list to get it's size - should only be needed first time it's shown
; 		render/only 'list xy1 xy2
; 	]

; 	#assert [list/size]
; 	; lgeom: window/map/list
; 	window/map/list/size: list/size
; 	window/map/list/offset: switch dir [
; 		n w [0x0]
; 		s e [
; 			either initial? [0x0][
; 				window/size - list/size * select [s 0x1 e 1x0] dir
; 			]
; 		]
; 	]
; ]

got rid of this; now map name = style name
; get-style-name: function [
; 	"Transform MAP name into STYLE name"
; 	name [word!]
; ][
; 	space: get name
; 	all [
; 		new-name: select space 'style 					;-- allow space to enforce it's style
; 		name <> new-name
; 		;-- enforced name has to not to leak into globals and should have the same value as the name in map
; 		return anonymize new-name space					;@@ any easier way?
; 	]
; 	name
; ]

closures are now style/after
; get-style: function [
; 	"Fetch styling code for the current space being drawn"
; 	/named path [path! block!] "Path to look for (defaults to current-style)"
; 	/closing "Fetch a closure instead"
; ][
; 	table: either closing [closures][styles]
; 	path: tail as path! either named [path][current-style]
; 	#assert [not head? path]
; 	until [												;-- look for the most specific fitting style
; 		p: back path
; 		style: any [find/only table p  style]
; 		head? path: p
; 	]
; 	unless style [return []]
; 	style: first find style block!
; 	#assert [block? style]
; 	space: get last path								;-- need to expose it's context to the style
; 	; print ["style for " head path "is" mold style]
; 	compose/deep bind style space			;@@ how slow this bind will be? any way not to bind?
; ]

now powered by trap mezz, simpler
; do-handler: function [spc-name [path!] handler [function!] path [block!] args [block!] /local result] [
; 	path: cache/hold path							;-- copy in case user modifies/reduces it, preserve index
; 	space: get path/1
; 	code: compose/into [handler space path (args)] clear []
; 	error: try/all [set/any 'result do code  'ok]
; 	cache/put path
; 	unless 'ok == error [
; 		msg: form/part error 400					;@@ should be formed immediately - see #4538
; 		print #composite "*** Failed to evaluate (spc-name)!"
; 		print msg
; 	]
; 	:result
; ]
; do-global: function [map [map!] path [block!] event [event! none!] type [word!]] [
; 	unless list: map/:type [exit]
; 	kind: either map =? previewers ["previewer"]["finalizer"]
; 	foreach fn list [
; 		pcopy: cache/hold path					;-- copy in case user modifies/reduces it, preserve index
; 		error: try/all [(fn get path/1 pcopy event)  'ok]
; 		cache/put pcopy
; 		unless 'ok == error [
; 			print #composite "*** Failed to evaluate event (kind) (mold/part/flat :fn 100)!"
; 			print form/part error 400
; 		]
; 	]
; ]

this style design can't be bound - didn't work
; cell [
; 	bgnd: [
; 		fill-pen (svmc/panel)
; 		box 0x0 (size)
; 	]
; 	render: function [] [
; 		before: compose/deep self/before
; 		?? draw
; 		drawn:  draw
; 		bgnd:   compose/deep self/bgnd
; 		after:  compose/deep self/after
; 		compose [(bgnd) (before) (drawn) (after)]	;-- composed order differs from evaluation order
; 	]
; ]

render now can accept a host face directly, and split into parts
; set 'render function [
; 	space [word! object!] "Space name; or host face as object"
; 	; /as style [word!]
; 	/only xy1 [pair! none!] xy2 [pair! none!]
; 	; /draw cmds [block! function!]
; 	; /root "Apply the styles/root as well (for topmost spaces)"
; ][
; 	either word? space [
; 		unset 'prefix
; 	][
; 		prefix: bind get-style 'host		;-- apply styles/root for topmost spaces
; 	]

; 	space: get name: space
; 	append current-style name			;-- used by get-style
; 	#assert [space? space]
; 	style: get-style					;-- call it before calling draw or draw/only, in case it modifies smth
	
; 	trap/all/catch [					;-- traps compose and draw calls errors
; 		if value? 'prefix [prefix: compose/deep prefix]
; 		either block? :style [
; 			style: compose/deep bind style space		;@@ how slow this bind will be? any way not to bind? maybe construct a func?
; 			draw: select space 'draw
; 			all [
; 				only
; 				function? :draw
; 				find spec-of :draw /only
; 				draw: draw/only xy1 xy2
; 			]
; 			render: compose [(style) (draw)]			;-- call the function if not called yet, inline blocks
; 		][
; 			#assert [function? :style]
; 			render: (style space)						;@@ TODO: /only support for it?
; 		]
; 	][
; 		msg: form/part thrown 400						;@@ should be formed immediately - see #4538
; 		print #composite "*** Failed to compose the style of (name)!^/(msg)"
; 		render: copy []
; 	]
; 	take/last current-style									;-- draw should be called before take/last, in case `draw` relies on current-style
; 	compose/only [(:prefix) push (render)]					;-- push should shield from style propagation
; ]

this fails because it considers context of the word, but we don't care about it
; same-paths?: function [p1 [block! path!] p2 [block! path!]] [
; 	to logic! all [
; 		(length? p1) = length? p2
; 		find/match/same p1 p2							;@@ won't work in master branch yet (#4165)
; 	]
; ]

this is too naive
; same-paths?: function [p1 [block! path!] p2 [block! path!]] [
; 	to logic! all [
; 		p1 == as p1 p2									;-- spelling & length match
; 		(
; 			repeat i n: length? p1 [					;-- values sameness
; 				unless same? get/any p1/:i get/any p2/:i [return no]
; 			]
; 			yes
; 		)
; 	]
; ]

REP #104 experiments, have no use for them anyway
; same-scalar?: function [v1 [any-type!] v2 [any-type!]] [
; 	to logic! any [
; 		:v1 =? :v2
; 		all [
; 			series? :v1
; 			(type? :v1) = type? :v2
; 			(length? :v1) = n: length? :v2
; 			(repeat i n [unless same-scalar? :v1/:i :v2/:i [return false]]  true)
; 		]
; 	]
; ]
; ;-- `find/match` using `same-scalar?` comparator
; find-match-same-scalar: function [series [series!] match [any-type!]] [
; 	if series? :match [
; 		repeat i n: length? match [
; 			unless same-scalar? :series/:i :match/:i [return none]
; 		]
; 		return skip series n
; 	]
; 	all [same-scalar? :series/1 :match  next series]
; ]
; ;-- `find` using `same-scalar?` comparator
; find-same-scalar: function [series [series!] value [any-type!]] [
; 	; while [series: find/case series :value] [		can't be used because find will never match nans
; 	while [not tail? series] [
; 		if find-match-same-scalar series :value [return series]
; 		series: next series
; 	]
; 	none
; ]
; #assert [same-scalar? 1.#nan 1.#nan]
; #assert [same-scalar? reduce [1.#nan] reduce [1.#nan]]
; #assert [r: find-match-same-scalar reduce [0.0 / 0.0 1.0 * 1.#inf] 0.0 / 0.0  'r]
; #assert [r: find-match-same-scalar b: reduce [0.0 / 0.0 1.0 * 1.#inf] copy b  'r]
; #assert [r: find-match-same-scalar b: reduce [0.0 / 0.0 reduce [1.0 * 1.#inf]] copy/deep b  'r]
; #assert [2 = index? r: find-same-scalar reduce [0.0 / 0.0 1.0 * 1.#inf] 1.0 * 1.#inf  'r]
; #assert [2 = index? r: find-same-scalar b: reduce [0 0.0 / 0.0 reduce [1.0 * 1.#inf]] copy next b  'r]

from grid/draw: this broke tabbing because cell objects were replaced after redraw
thus making keyboard/focus point to invalid object
of course it couldn't have a clue - replaced objects must be treated as different ones
;@@ TODO: this should be documented in the widget builders guide
; unless mcspace [
; 	render mcspace: rcache/:mcell: wrap-space mcell-content-name
; ]

from events/dispatch - causes stack overflow and crashes as expected (when UI lags a bit)
; if commands/update? [
; 	face/draw: render face
; 	do-events/no-wait
; ]

this window model was too convoluted to work with
; last-origin: last-size: none							;-- geometry during previous call to `renew`
; renew: function [] [
; 	unless all [last-origin last-size = max-size] [		;-- first ever invocation or size changed
; 		self/last-origin: origin
; 		self/last-size: max-size
; 		fill 0x0 max-size
; 		exit
; 	]
; 	if 0x0 = offset: origin - last-origin [exit]		;-- has not been moved
; 	self/last-origin: origin
; 	unless caching? [
; 		clear map
; 		fill 0x0 max-size
; 		exit
; 	]

; 	remove-each [name geom] map [				;-- clear the map of invisible spaces
; 		o: geom/offset: geom/offset + offset	;-- and relocate visible ones
; 		not bbox-overlap?  0x0 max-size  o o + geom/size
; 	]
; 	case [										;-- fill top/bottom before left/right (random decision)
; 		offset/y > 0 [fill  0x0  as-pair max-size/x top: offset/y]
; 		offset/y < 0 [fill  as-pair 0 btm: max-size/y + offset/y  max-size]
; 	]
; 	default top: 0
; 	default btm: max-size/y
; 	case [										;-- left/right excludes already drawn top/bottom regions
; 		offset/x > 0 [fill  as-pair 0 top  as-pair offset/x btm]
; 		offset/x < 0 [fill  as-pair max-size/x + offset/x top  as-pair max-size/x btm]
; 	]
; ]
; draw: function [/only xy1 [pair!] xy2 [pair!]] [
; 	old-origin: origin							;-- renew may change origin, in which case we don't wanna miss the viewport
; 	renew
; 	either only [
; 		visible: []
; 		foreach [name geom] map [				;@@ should be map-each
; 			if bbox-overlap? 0x0 max-size xy1 xy2 [append visible name]
; 		]
; 		r: compose-map/only/limits map visible xy1 - old-origin xy2 - old-origin
; 		clear visible							;-- let GC free it up
; 	][
; 		r: compose-map map
; 	]
; 	self/size: either empty? map [
; 		0x0
; 	][
; 		item-last: last map
; 		min max-size item-last/offset + item-last/size
; 	]
; 	r

(dispatch) this was supposed to provide real time updates but due to #4881 totally blocked the UI
; if commands/update? [
; 	face/draw: render face
; 	;@@ TODO: fix the lag once #4881 gets a solution
; 	do-atomic [									;-- uses reactivity to unroll the recursion and prevent stack overflow
; 		do-events/no-wait						;@@ this still does not prevent GUI huge lags :(
; 	]
; ]

now that there's proper grid-view, this list of lists hack is not needed anymore
; table-ctx: context [
; 	;@@ TODO: func to automatically balance column widths to minimize table height
; 	; balance: function [] 

; 	spaces/table-row: make-space/block 'list [
; 		spacing: 4x3
; 		margin: 0x0
; 		data: none
; 		table: none				;-- should be set by the table

; 		make-layout: has [r] [
; 			r: make row-layout [
; 				pinned: table/pinned/x
; 				widths: table/widths
; 				axis: 'x
; 			]
; 			r/axis:    axis
; 			r/margin:  margin
; 			r/spacing: spacing
; 			r
; 		]

; 		;@@ TODO: unify this with data-view block variant somehow
; 		fill: function [] [
; 			#assert [block? data]
; 			n: length? data
; 			repeat i n [
; 				value: :data/:i
; 				unless item: items/:i [
; 					append items item: anonymize 'item make-space 'data-view []
; 				]
; 				item: get item
; 				maybe item/width: table/widths/:i
; 				set/any 'item/data :value
; 				item/set-content
; 			]
; 			clear skip items n
; 		]

; 		list-draw: :draw
; 		draw: function [] [
; 			fill		;@@ TODO: caching
; 			list-draw
; 		]
; 	]

; 	;@@ TODO: spacers between pinned and not pinned data
; 	spaces/table: make-space/block 'list [
; 		pinned: 0x1							;-- pinned columns x rows (headers)
; 		margin: 0x0	
; 		data-columns: [1 2]					;-- indexes of visible DATA columns in the order of appearance
; 		;-- NOTE: don't use #() here because it's ignored by copy/deep
; 		widths: make map! [1 100 2 100]		;-- data column index -> it's visible width
; 		axis: 'y

; 		source: []										;-- block of blocks or a function returning one
; 		;-- user can override `data` for more complex `source` layouts support
; 		data: function [/pick x [integer!] y [integer!] /size] [
; 			s: source									;-- eval in case it's a function
; 			case [
; 				pick [if row: s/:y [row/:x]]			;-- s/:y can be `none`
; 				empty? s [0x0]
; 				'else [
; 					#assert [block? s/1]
; 					as-pair  length? s/1  length? s
; 				]
; 			]
; 		]

; 		prep-data-row: function [
; 			"preps data row for display, independent of `source` format"
; 			y [integer!]
; 		][
; 			dsize: data/size
; 			if any [y <= 0  y > dsize/y] [return none]	;-- out of data limits case
; 			ncol: length? data-columns
; 			if 0 = ncol [return []]						;-- empty row case (no allocation needed)

; 			;@@ TODO: make a free list of blocks for this
; 			r: make [] ncol
; 			repeat x ncol [append/only r data/pick data-columns/:x y]	;@@ should be map-each, but it's slow
; 			r
; 		]

; 		headers: make-space 'list-view [hscroll/size/y: 0]
; 		columns: make-space 'list-view []
; 		headers/data: func [/pick i /length] [
; 			either pick
; 				[prep-data-row i]
; 				[min pinned/y second data/size]
; 		]
; 		columns/data: func [/pick i /length] [
; 			either pick
; 				[prep-data-row i + pinned/y]
; 				[max 0 (second data/size) - pinned/y]
; 		]
; 		headers/wrap-data:
; 		columns/wrap-data: function [item-data [block!]] [
; 			anonymize 'row make-space 'table-row compose/only [table: (self) data: (item-data)]
; 		]

; 		items: [headers columns]

; 		list-draw: :draw
; 		draw: function [] [
; 			maybe headers/origin: as-pair columns/origin/x headers/origin/y	;-- sync origin/x
; 			; headers/invalidate
; 			; columns/invalidate
; 			render 'headers
; 			render 'columns
; 			;-- don't let headers occupy more than half of height
; 			maybe headers/size: min headers/list/size size / 1x2 - (margin * 2x1)
; 			maybe columns/size: size - (headers/size * 0x1) - (margin * 2x2) - (spacing * 0x1)
; 			list-draw
; 		]

; 		;@@ do this as a function called inside draw!
; 		; on-change*: function [word old [any-type!] new [any-type!]] [
; 		; 	if word = 'dimensions [						;-- automatically show just added columns
; 		; 		#assert [pair? :old]
; 		; 		#assert [pair? :new]
; 		; 		set-quiet 'columns union columns rng: range old/x new/x
; 		; 		foreach i rng [widths/:i: 100]			;@@ externalize the default width?
; 		; 	]
; 		; ]
; 	]
; ]

this was crazy complex
; list-view-ctx: context [
; 	spaces/list-view: make-space/block 'inf-scrollable [
; 		source: []		;@@ or a function [index]? or support both?
; 		data: function [/pick i [integer!] /length] [
; 			either pick [source/:i][length? source]
; 		]
; 		index: 1										;-- index of the first item within source
		
; 		wrap-data: function [item-data [any-type!]][
; 			spc: make-space 'data-view []
; 			set/any 'spc/data :item-data
; 			if list/axis = 'y [spc/width: window/max-size/x - (list/margin/x * 2)]		;@@ what data width to use for horizontal lists?
; 			anonymize 'item spc
; 		]

; 		list: make-space 'list [axis: 'y]				;-- list/axis can be changed to get a horizontal list ;@@ but then setup becomes wrong
; 		window/map: [list [offset 0x0 size 0x0]]

; 		window/max-size: 1000x1000		;@@ this is where sizing strategy would be cool to have

; 		extra?: function [dir [word!]] [			;-- measure dangling extra size along any direction
; 			if empty? map: window/map [return 0]
; 			#assert [2 = length? map]
; 			r: max 0x0
; 				switch dir [
; 					w n [negate map/2/offset]
; 					e s [map/2/offset + map/2/size - window/max-size]
; 				]
; 			r/x + r/y
; 		]

; 		window/available?: function [dir [word!] requested [integer!]] [
; 			#assert [0 < requested]
; 			if any [
; 				all [list/axis = 'y  find [e w] dir]
; 				all [list/axis = 'x  find [n s] dir]		;@@ not sure about this yet, /width doesn't guarantee it
; 			] [return 0]
; 			reserve: extra? dir
; 			requested: requested - reserve

; 			r: 0
; 			if requested > 0 [
; 				lt: extend-layout dir requested
; 				r: lt/content-size/(list/axis)
; 				unless empty? lt/items [r: r + lt/spacing/(list/axis)]
; 			]
; 			r: max 0 r + reserve
; 			; print ["avail?" dir "=" r "of" requested "(reserve:" reserve ")"]
; 			r
; 		]

; 		;@@ ensure this one is called only from inf-scrollable/draw
; 		extend-layout: function [dir [word!] amount [integer!] /keep where [block!]] [
; 			; print ["extend" dir amount]
; 			lt: list/make-layout
; 			unless empty? list/items [amount: amount - lt/spacing/(list/axis)]
; 			switch dir [
; 				n w [+-: :-  n-max: (base: index) - 1]
; 				s e [+-: :+  n-max: data/length - base: index - 1 + length? list/items]
; 			]
; 			#assert [(select [n y s y e x w x] dir) = list/axis]
; 			repeat i n-max [
; 				name: wrap-data data/pick base +- i		;-- guarantee at least 1 item (else spacing could be bigger than the requested amount)
; 				#assert [not find/same list/items name]
; 				render name
; 				lt/place select get name 'size
; 				if keep [append where name]
; 				if lt/content-size/(list/axis) >= amount [break]
; 			]
; 			lt
; 		]

; 		;-- this func is quite hard to get right, many aspects to consider
; 		;-- * window moves list within it's map before calling `fill`,
; 		;--   but we'll have to move list back and move all items within list accordingly
; 		;-- * move offset can be used right away to know what spaces will be hidden
; 		;-- * list may have extra dangling items partially clipped by window (before the move), which now become visible
; 		;--   i.e. list/size may be > window/max-size because it contains whole items, not necessarily aligning to window borders
; 		;-- * these hidden parts should be subtracted from the xy1-xy2 area to know how much to extend the list itself
; 		;-- * there may be no new items to add, just the hidden area to show
; 		;-- * list may initially be empty (spacing to consider), or not rendered (undefined size)
; 		;-- * when filling from above, list should be aligned with the top border, when from below - the opposite
; 		;@@ and I haven't considered the case where window/max-size <= list-view/size (it isn't working)
; 		window/fill: function [xy1 [pair!] xy2 [pair!]] [
; 			; ?? size print ["fill" xy1 xy2]
; 			;@@ TODO: remove these or add x=opposite support
; 			#assert [0 = xy1/x]
; 			#assert [window/max-size/x = xy2/x]
; 			#assert [any [xy1/y = 0  xy2/y = window/max-size/y]]

; 			unit: select [x 1x0 y 0x1] x: list/axis
; 			dir: select
; 				pick [ [x e y s] [x w y n] ] xy2/:x = window/max-size/:x	;-- s/e = tail fill (or head to tail), n/w = head fill (partial)
; 				x
; 			negative?: none <> find [n w] dir
; 			either negative? [											;-- get already rendered parts out of the requested area
; 				xy2/:x: xy2/:x - extra? dir
; 			][	xy1/:x: xy1/:x + extra? dir
; 			]
; 			lgeom: window/map/list

; 			;-- xy area now lies purely outside the list, so we can fill it
; 			lt: extend-layout/keep dir (xy2/:x - xy1/:x) clear new: []

; 			;-- sometimes it's possible that `new` is empty and `fill` should only move the list to show `extra?` (hidden) area
; 			unless empty? new [
; 				;@@ TODO: some automatic extension calculation? right now it won't work for arbitrary layout
; 				pixels-added: lt/content-size/:x + either empty? list/items [0][lt/spacing/:x]

; 				offset: lgeom/offset						;-- we can count invisibles right now from list/offset
; 				initial-fill?: offset = 0x0					;-- on first fill, do not align with the lowest/rightmost edge
				
; 				n-remove: 0									;-- count how many invisible spaces to remove
; 				foreach': switch dir [n w [:foreach-reverse] s e [:foreach]]	 ;@@ should be for-each/reverse
; 				;@@ list should have no timer in the map, else we'll have to check names for `item`
; 				foreach' [_: geom:] list/map [
; 					o: geom/offset + offset
; 					visible?: bbox-overlap?  0x0 window/max-size  o o + geom/size
; 					either visible? [break][n-remove: n-remove + 1]
; 				]

; 				either negative? [									;-- insert new items
; 					insert list/items reverse new
; 					self/index: self/index - length? new
; 				][
; 					append list/items new
; 					maybe self/index: self/index + n-remove			;-- n-remove can be 0
; 				]

; 				pixels-removed: 0									;-- along the list/axis
; 				if n-remove > 0 [
; 					removed: either negative? [						;-- remove invisibles from `items` & `map`
; 						take/last/part list/items n-remove
; 						take/last/part list/map n-remove * 2
; 					][
; 						remove/part list/items n-remove
; 						take/part list/map n-remove * 2
; 					]

; 					rem-1st: removed/2
; 					rem-last: last removed
; 					pixels-removed: rem-last/offset + rem-last/size - rem-1st/offset + lt/spacing		;@@ TODO: automatic calculation if possible?
; 					pixels-removed: pixels-removed/:x
; 				]

; 				;-- now that we know removed size we can calculate how much to shift the list in window/map
; 				offset: unit * either negative? [pixels-added][pixels-removed * -1]

; 				foreach [_ geom] list/map [					;-- relocate visible spaces now that we know the offset
; 					geom/offset: geom/offset - offset
; 				]

; 				either new-size: list/size [
; 					;-- update the size, without re-rendering anything
; 					new-size/:x: new-size/:x - pixels-removed + pixels-added
; 					maybe list/size: new-size
; 				][
; 					;-- render the list to get it's size - should only be needed first time it's shown
; 					render/only 'list xy1 xy2
; 				]
; 			]
; 			#assert [list/size]

; 			;-- update list geometry inside the window
; 			lgeom/size: list/size
; 			lgeom/offset: either any [negative? initial-fill?] [
; 				0x0												;-- align to top-left corner of the window
; 			][	min 0x0 window/max-size - list/size * unit		;-- to bottom-left, but only if list > window(!)
; 			]
; 		]

; 		setup: function [] [
; 			if size [									;-- if size is defined, adjust the window (paragraphs adjust to window then)
; 				pages: 10								;@@ make this configurable?
; 				unit: select [x 1x0 y 0x1] list/axis
; 				maybe window/max-size: size + (pages - 1 * size * unit)
; 			]
; 		]

; 		inf-scrollable-draw: :draw
; 		draw: function [] [
; 			setup
; 			inf-scrollable-draw
; 		]
; 	]
; ]

call to `available?` to window's limits is very expensive - renders whole window
; window/draw: function [/only xy1 [pair!] xy2 [pair!]] [
; 	#debug grid-view [#print "window/draw is called with xy1=(xy1) xy2=(xy2)"]
; 	#assert [word? content]
; 	map/1: content								;-- rename it properly
; 	cspace: get content
; 	geom: map/:content
; 	o: geom/offset
; 	;-- there's no size for infinite spaces so we use `available?` to get the drawing size
; 	s: max-size
; 	foreach x [x y] [s/:x: available? x 1 (0 - o/:x) s/:x]
; 	default xy1: 0x0
; 	default xy2: s
; 	geom/size: s - o
; 	self/size: s							;-- limit window size by content size
; 	cdraw: render/only content xy1 - o xy2 - o
; 	compose/only [translate (o) (cdraw)]
; ]

no longer relevant in the new styles design
; set 'closures reshape [		;-- closures come after the main drawing code
; 	; hscroll/thumb vscroll/thumb [
; 	; 	(when focused?/parent [compose/deep [
; 	; 		push [
; 	; 			;@@ MEH DOESNT WORK YET -- CHECK PATTERN PEN WHEN IT"S FIXED
; 	; 			; pen pattern 4x4 [line-width 0 fill-pen black box 0x0 2x2 box 2x2 4x4]
; 	; 			; fill-pen 0.100.200.200
; 	; 			; line-width 0
; 	; 			; box 0x0 (size)
; 	; 			; line-width 2
; 	; 			line-width 0
; 	; 			fill-pen !(svmc/text + 0.0.0.100)
; 	; 			box 4x3 (size - 4x3)
; 	; 			line-width 2
; 	; 		]
; 	; 	]])
; 	; ]	
; ]

too complicated, hard to support reordering (e.g. left-to-right placement)
; tube-layout-ctx: context [
; 	~: self

; 	place: function [layout [object!] item [word!]] [
; 		sz: select get item 'size
; 		#assert [sz]									;-- item must have a size
; 		data: tail layout/raw-map
; 		x: switch layout/align/1 [n s ['x] w e ['y]]
; 		y: select [x y x] x
; 		rw: data/-1/:x									;-- row width accumulated so far
; 		cs: layout/content-size
; 		sp: layout/spacing

; 		if rw > 0 [rw: rw + sp/:x]						;-- add size to row
; 		rw: rw + sz/:x
; 		if all [
; 			rw > sz/:x									;-- put at least 1 item per row, even if it's wider
; 			layout/margin/:x * 2 + rw > layout/width	;-- jump to next row if needed
; 		][
; 			cs/:y: cs/:y + sz/:y						;-- count height in content-size
; 			if 3 < index? data [cs/:y: cs/:y + sp/:y]
; 			data: insert insert/only data copy [] 0x0
; 			rw: sz/:x
; 		]
; 		if all [
; 			rw > sz/:x
; 			0 < added: sz/:y - data/-1/:y
; 		][cs/:y: cs/:y + added]
; 		data/-1/:x: max data/-1/:x rw					;-- update row size
; 		data/-1/:y: max data/-1/:y sz/:y
; 		layout/content-size: max data/-1 cs				;-- update content size (x from row-size, y from cs)

; 		guide: select [x 1x0 y 0x1] x
; 		ofs: rw - sz * guide
; 		compose/deep/into [(item) [offset (ofs) size (sz)]] tail data/-2
; 	]

; 	build-map: function [layout] [
; 		al: layout/align
; 		x: switch al/1 [n s ['x] w e ['y]]
; 		y: select [x y x] x
; 		; guide: select [x 1x0 y 0x1] y
; 		sign: switch al/1 [n w [1] e s [-1]]
; 		move-items: sign * (switch al/3 [n w [-1] c [0] e s [1]]) + 1 / 2	;@@ use -1/+1 instead of nw/es pairs?
; 		move-rows:  sign * (switch al/2 [n w [-1] c [0] e s [1]]) + 1 / 2
; 		pos: layout/margin
; 		r: make [] 20
; 		foreach [row row-size] layout/raw-map [
; 			gap: layout/width - (layout/margin/:x * 2) - row-size/:x	;-- can be negative, still correct
; 			pos/:x: to 1 gap * move-rows
; 			if layout/dir < 0 [reverse/skip row 2]
; 			foreach [name geom] row [
; 				if move-items <> 0 [
; 					gap: row-size/:y - geom/size/:y
; 					geom/offset/:y: geom/offset/:y + to 1 (move-items * gap)
; 				]
; 				geom/offset: geom/offset + pos
; 			]
; 			append r row
; 			pos/:y: pos/:y + layout/spacing/:y + row-size/:y
; 		]
; 		; set 'xx layout
; 		; ?? layout
; 		r
; 	]

; 	set 'tube-layout object [
; 		;-- interface
; 		width:   100
; 		; origin:  0x0			;@@ TODO - if needed
; 		margin:  0x0
; 		spacing: 0x0
; 		align:   [n w n]		;-- 3 alignments: tube itself (nesw), then list within row (neswc), then item within list (neswc)
; 		dir: 1

; 		content-size: 0x0
; 		size:  does [margin * 2 + content-size]
; 		place: func [item [word!]] [~/place self item]
; 		map:   does [~/build-map self]

; 		;-- used internally
; 		raw-map: [[] 0x0]		;-- accumulated map so far (make object! copies this deeply)
; 	]

; 	#assert [not same? tube-layout/raw-map/1 (first select make tube-layout [] 'raw-map)]
; ]

old attempt to hack the grid via list of lists, nothing to do with new row (stretch-list) layout
; row-layout-ctx: context [
; 	place: function [layout [object!] item [pair!]] [
; 		set [ofs: siz: org:] list-layout-ctx/place layout item
; 		guide: select [x 1x0 y 0x1] x: layout/axis
; 		index: (length? layout/items) / 3
; 		if w: layout/widths/:index  [siz/x: w]			;-- enforce size if provided
; 		if h: layout/heights/:index [siz/y: h]
; 		if index > pinned: layout/pinned [				;-- offset and clip unpinned items
; 			either pinned > 0 [
; 				plim: skip items pinned - 1 * 3
; 				lim: plim/1 + plim/2 + layout/spacing * guide
; 			][
; 				lim: 0x0
; 			]
; 			ofs: ofs + (layout/origin * guide)
; 			if ofs/:x < lim/:x [
; 				org: org - dx: (lim - ofs) * guide
; 				siz: max 0x0 siz - dx
; 				ofs/:x: lim/:x
; 			]
; 		]
; 		layout/content-size/:x: ofs/:x + siz/:x - layout/margin/:x
; 		;-- content-size height accounts for all items, even clipped (by design)
; 		reduce/into [ofs siz org] clear skip tail layout/items -3
; 	]
; 	set 'row-layout make list-layout [
; 		origin: 0
; 		pinned: 0
; 		widths: []				;-- can be a map: index -> integer width
; 		heights: []				;-- same

; 		place: function [item [pair!]] [row-layout-ctx/place self item]
; 	]
; ]

old render code, before /on introduction (apply kludge)
; all [
	; only
	; function? :draw
	; find spec-of :draw /only
	; do copy/deep [draw: draw/only xy1 xy2]	;@@ workaround for #4854 - remove me!!
; ]

tube layout code before autosizing
; cache: []				;-- various values used by `place`
; raw-map: [[] 0x0]		;-- accumulated rows and row-sizes so far (make object! copies this deeply)
; #assert [not same? tube/raw-map/1 (first select make tube [] 'raw-map)]
; ;; fills a set of flags that are used by `place` func every time
; ;; flags do not change so no need to recompute them
; fill-cache: function [layout [object!]] [
	; data: tail layout/raw-map
	; y: anchor2axis layout/axes/1
	; x: anchor2axis layout/axes/2
	; xvec: axis2pair x
	; yneg?: find [n w] layout/axes/1
	; xneg?: find [n w] layout/axes/2
	; #assert [y <> x]								;-- have to be normal to each other
	; cs: layout/content-size
	; sp: layout/spacing
	; maxw: layout/width - (layout/margin/:x * 2)

	; cache-names: [data x y cs sp maxw xvec xneg? yneg?]
	; reduce/into cache-names layout/cache
; ]
; place: function [
	; "Add ITEM space to LAYOUT"
	; layout [object!] item [word!]
; ][
	; sz: select get item 'size
	; #assert [sz]									;-- item must have a size
	; if tail? layout/cache [fill-cache layout]
	; set [data: x: y: cs: sp: maxw: xvec: xneg?: yneg?:] layout/cache
	; rsz: data/-1									;-- row size accumulated so far
	; first?: 0 = rw: rsz/:x							;-- row width accumulated so far
	
	; rw: rw + sz/:x
	; unless first? [
		; rw: rw + sp/:x
		; if rw > maxw [								;-- jump to next row if needed
			; cs/:y: cs/:y + sp/:y
			; data: insert insert/only data make block! 16 rsz: 0x0
			; rw: sz/:x
			; first?: yes
		; ]
	; ]
	; if 0 < added: sz/:y - rsz/:y [cs/:y: cs/:y + added]
	; rsz: max rsz sz									;-- update row size
	; rsz/:x: rw
	; layout/content-size: max data/-1: rsz cs		;-- update content size (x from row-size, y from cs)

	; ofs: rsz - sz * xvec
	; if yneg? [ofs/:y: 0 - ofs/:y - sz/:y]
	; if xneg? [ofs/:x: 0 - ofs/:x - sz/:x]
	; reduce/into [data x y cs sp maxw xvec xneg? yneg?] clear layout/cache
	; compose/deep/into [(item) [offset (ofs) size (sz)]] tail data/-2
; ]
; build-map: function [
	; "Produce a final MAP from LAYOUT accumulated so far"
	; layout [object!]
; ][
	; al: layout/align
	; set [data: x: y: cs: sp: maxw: xvec: xneg?: yneg?:] layout/cache
	; ox: anchor2pair layout/axes/2
	; oy: anchor2pair layout/axes/1
	; shift: 0x0
	; if ox/:x < 0 [shift/:x: maxw]
	; if oy/:y < 0 [shift/:y: cs/:y]
	; pos: shift + mg: layout/margin
	; move-items: al/2 + 1 / 2
	; move-rows:  al/1 + 1 / 2
	; r: make [] length? layout/raw-map
	; foreach [row row-size] layout/raw-map [
		; gap: maxw - row-size/:x						;-- can be negative, still correct
		; row-shift: gap * move-rows * ox
		; if move-items <> 0 [
			; foreach [name geom] row [
				; gap: row-size - geom/size * oy
				; geom/offset: geom/offset + (move-items * gap)
			; ]
		; ]
		; foreach [name geom] row [
			; geom/offset: geom/offset + pos + row-shift
		; ]
		; append r row
		; pos: pos + (sp + row-size * oy)
	; ]
	; r
; ]

layouts old design
; layouts: context [

	; list: none											;-- reserve names
	; row:  none
	; tube: none

	; ;@@ TODO: free list of these
	; list-layout-ctx: context [
		; ~: self

		; place: function [layout [object!] item [word!]] [	;-- held separately to minimize the size of list-layout itself
			; sz: select get item 'size
			; #assert [sz]									;-- item must have a size
			; guide: select [x 1x0 y 0x1] layout/axis
			; cs: layout/content-size
			; if 0x0 <> cs [cs: cs + (layout/spacing * guide)]
			; ofs: cs * guide + layout/margin + layout/origin
			; cs: cs + (sz * guide)
			; cs: max cs sz
			; layout/content-size: cs
			; compose/deep/into [(item) [offset (ofs) size (sz)]] tail layout/map
		; ]

		; set 'list object [
			; origin:  0x0			;-- used by list-view
			; margin:  0x0
			; spacing: 0x0
			; axis:    'x

			; content-size: 0x0
			; size: does [margin * 2 + content-size]
			; map: []			;-- accumulated map so far
			; place: func [item [word!]] [~/place self item]
		; ]
	; ]
	
	; tube-layout-ctx: context [
		; ~: self
		
		; place: function [layout [object!] item [word!]] [
			; append layout/items item
		; ]
		
		; build-map: function [layout [object!]] [
			; ;; to support automatic sizing, each item's constraints has to be analyzed
			; ;; obviously there can be two strategies:
			; ;;  1. fill everything with max size, then shrink, and rearrange as possible
			; ;;  2. fill everything with min size, then expand within a single row
			; ;;  2nd option seems more predictable and easier to implement
			; ;; constraint presence does not mean that space can reach that size,
			; ;; so it should only be used as hint (canvas size) to obtain min size
			; ;; then, every item that has a nonzero weight has to be rendered twice:
			; ;; once to get it's minimum appearance, second time to expand it
			; ;; other items also has to be rendered twice - to fill the row height
			
			; ;; obtain constraints info
			; ;@@ info can't be static since render may call another build-map; use block-stack!
			; info: make block! length? layout/items
			; i: 0 foreach item layout/items [			;@@ use for-each when becomes native
				; i: i + 1
				; space: get item
				; min-size: all [space/limits space/limits/min]	;@@ REP #113
				; max-size: all [space/limits space/limits/max]	;@@ REP #113
				; ;@@ this is inconsistent with list which does NOT render it's items:
				; drawn: render/on item min-size			;-- needed to obtain space/size
				; #assert [pair? space/size]
				; weight: any [select space 'weight 0.0]
				; #assert [number? weight]
				; available: case [
					; weight <= 0  [0]					;-- fixed size
					; not max-size [2e9]					;-- unlimited extension possible
					; 'else [max-size/x - space/size/x / weight]	;@@ REP #113
				; ]
				; append/only info reduce [				;@@ use block stack
					; i item space drawn space/size max-size 1.0 * available weight
				; ]
			; ]
			
			; ;; split info into rows
			; rows: copy []								;@@ use block-stack
			; row:  copy []
			; row-size: layout/spacing/x * -1x0			;@@ not gonna work for empty rows
			; row-max-width: layout/width - (2 * layout/margin/x)
			; canvas: layout/width - (2 * layout/margin/x) by 2e9		;@@ use canvas ?
			; foreach item info [
				; set [_: name: _: _: item-size:] item
				; new-row-size: as-pair
					; row-size/x + item-size/x + layout/spacing/x
					; max row-size/y item-size/y
				; row-size: either all [					;-- row is full, but has at least 1 item?
					; new-row-size/x > row-max-width
					; not tail? row
				; ][
					; reduce/into [row-size copy row] tail rows
					; clear row
					; item-size
				; ][
					; new-row-size
				; ]
				; append/only row item
			; ]
			; reduce/into [row-size row] tail rows
			
			; ;; expand row items - facilitates a second render cycle of the row
			; foreach [row-size row] rows [
				; free: row-max-width - row-size/x
				; if free > 0 [							;-- any space left to distribute?
					; ;; free space distribution mechanism relies on continuous resizing!
					; ;; render itself doesn't have to occupy max-size or the size we allocate to it
					; ;; and since we don't know what render is up to,
					; ;; we can only "fix" it by re-rendering until we fill whole row space
					; ;; but this will be highly inefficient, and not even guaranteed to ever finish
					; ;; so a proper solution in this case should be to use a custom layout or resize hook
					; ;@@ this needs to be documented, and maybe another sizing type should be possible: a list of valid sizes
					; weights: clear []
					; extras:  clear []
					; foreach item row [
						; append weights item/8
						; append extras  item/7
					; ]
					; exts: distribute free weights extras
					
					; i: 0 foreach item row [				;@@ should be for-each
						; i: i + 1
						; set [_: name: space: drawn: item-size: max-size: available: weight:] item
						; new-size: item-size/x + exts/:i by row-size/y
						; item/4: render/on name new-size
						; item/5: space/size				;@@ or use new-size in a map?
					; ]
				; ]
			; ]
			
			; map: clear []
			; margin:  layout/margin
			; spacing: layout/spacing
			; row-y: margin/y
			; total-length: 0
			; foreach [row-size row] rows [
				; ofs: margin/x by row-y
				; foreach item row [
					; set [_: name: space: drawn: item-size: max-size: available: weight:] item
					; ofs/y: to integer! row-size/y - item-size/y / 2 + row-y
					; geom: reduce ['offset ofs 'size item-size]
					; repend map [name geom]
					; ofs/x: ofs/x + spacing/x + item-size/x
				; ]
				; total-length: total-length + row-size/y + spacing/y
				; row-y: margin/y + total-length
			; ]
			; total-length: total-length - spacing/y
			; layout/content-size: row-max-width by total-length
			; layout/size: 2x2 * margin + layout/content-size
			; copy map
		; ]

		; size: function [layout [object!]] [
			; ;-- does not contract size if it's > width
			; ;-- does not expand it either if some item is > width, otherwise can get this picture:
			; ;-- [  ] = width
			; ;-- XXXXXXXXXX
			; ;-- X X        <- if expanded, these rows will look like they're half filled
			; ;-- X X           instead, let the big item stick out
			; sz: layout/margin * 2 + layout/content-size
			; switch layout/axes/1 [
				; n s [layout/width by sz/y]
				; w e [sz/x by layout/width]
			; ]
		; ]

		; set 'tube object [
			; ;-- interface
			; width:   100			;@@ TODO: use canvas instead?
			; origin:  0x0			;@@ TODO - if needed
			; margin:  0x0
			; spacing: 0x0
			; ;@@ align can be a pair, total 9 options; though pair is interpreted in XY coordinate terms usually..
			; align:   [-1 -1]		;-- 2 alignments: list within row (-1/0/1), then item within list (-1/0/1)
			; axes:    [s e]			;-- 4x2 total; default placement order: top-down rows, left-right items

			; content-size: 0x0
			; place: func [item [word!]] [~/place self item]
			; map:   does [~/build-map self]
			; size:  0x0

			; ;-- used internally
			; items: []
		; ]
	; ]
; ]

singular get-cache & set-cache - no use, even list-view renders each space on 2 canvases
; get-cache: function [space [object!] canvas [pair! none!] xy1 [pair! none!] xy2 [pair! none!]] [
	; all [
		; true =? select space 'cache?
		; space/size
		; cached: find/only/same space-cache space
		; cached/2 =? canvas
		; cached/3 =? xy1
		; cached/4 =? xy2
		; cached/5
	; ]
; ]
; set-cache: function [space [object!] canvas [pair! none!] xy1 [pair! none!] xy2 [pair! none!] drawn [block!]] [
	; reduce/into [space canvas xy1 xy2 drawn] data: clear []
	; cached: any [
		; find/only/same space-cache space
		; tail space-cache
	; ]
	; change cached data
; ]

list layout settings as object support - probably wont be needed as object is heavy
; either object? settings [
	; bound: append clear [] words
	; set words bind bound settings
; foreach word [			
	; axis: margin: spacing: canvas: origin:
	; viewport: cache-visible?: cache-invisible?:
; ][
	; set word select settings word
; ]

part of cell/draw - this makes cleaner draw blocks but does not make it any faster and adds complexity 
; clip?: not 0x0 +<= free
; move?: offset <> 0x0
; if any [clip? move?] [
	; buf: clear []
	; if clip? [repend buf ['clip 0x0 space/size]]
	; if move? [repend buf ['translate offset]]
	; drawn: copy append/only buf drawn
; ]

this cache idea didn't work well since it has to deeply visit all tree nodes which is 10x slower than rendering
; ;; cache format for now: [space-object space-path canvas xy1 xy2 drawn-size drawn-code ...]
; ;;   from find/tail:           -1           1        2    3   4      5           6         
; ;@@ once #5116 gets fixed, check if find/same .. #static-reduce [..] is going to be faster
; space-cache: make hash! 4096

; find-cache: function [space [object!] path [path!] canvas [pair! none!] xy1 [pair! none!] xy2 [pair! none!]] [
	; cached: space-cache
	; while [cached: find/only/same/tail cached space] [		;@@ watch out for #5116 fix, or use for-each
		; all [												;@@ also maybe search in reverse?
			; cached/2 =? canvas
			; cached/3 =? xy1
			; cached/4 =? xy2
			; same-paths? cached/1 path
			; return back cached
		; ]
	; ]
	; none
; ]

; ;; assumes that given the same canvas & xy1/2, inner spaces will not be resized/relocated
; children-cached?: function [space [object!] path [path!]] [
	; if map: select space 'map [						;-- composite space?
		; foreach [name geom] map [
			; inner: get name
			; cached: space-cache
			; while [cached: find/only/same/tail cached inner] [		;@@ watch out for #5116 fix, or use for-each
				; unless child-cached?: all [							;@@ also maybe search in reverse?
					; ;@@ this is not gonna work for scrollables which are using xy1 xy2 too?
					; geom/size =? cached/5
					; geom/size =? inner/size 
					; same-paths? cached/1 path
					; (
						; append path name
						; also children-cached? inner path
						; remove top path
					; )
				; ] [return no]
			; ]
		; ]
	; ]
	; yes
; ]

; get-cache: function [space [object!] path [path!] canvas [pair! none!] xy1 [pair! none!] xy2 [pair! none!]] [
	; all [
		; true =? select space 'cache?
		; space/size
		; cached: find-cache space path canvas xy1 xy2
		; children-cached? space path
		; cached/7
	; ]
; ]

; ;@@ TODO: limit number of caches per single space somehow, e.g. for list which has limitless xy1/xy2 combos!
; set-cache: function [
	; space [object!] path [path!] canvas [pair! none!] xy1 [pair! none!] xy2 [pair! none!] drawn [block!]
; ][
	; either cached: find-cache space path canvas xy1 xy2 [
		; cached/6: space/size
		; cached/7: drawn
	; ][
		; repend space-cache [space copy path canvas xy1 xy2 space/size drawn]
	; ]
; ]

; clear-cache: function [space [object!]] [
	; while [pos: find/same/only space-cache space] [
		; unless pos =? other: skip tail space-cache -7 [change pos other]
		; clear other
	; ]
; ]

version of constrain that does not accept `none` canvas size
; constrain: function [
	; "Sets TARGET to SIZE clipped within LIMITS"
	; 'target [set-word! set-path!]
	; size    [pair!]
	; limits  [none! word! object!]
	; /force "Set it even if it's equal, to trigger reactions"
; ][
	; case [
		; limits = 'fixed [size: get target]				;-- cannot be changed ;@@ need to think more about this
		; range? limits  [
			; case [
				; none = min: limits/min [min: 0x0]
				; number? min [min: min by 0]				;@@ should numbers only apply to X, or to main axis (harder)? 
			; ]
			; case [
				; none = max: limits/max [max: 2000000000x2000000000]
				; number? max [max: max by 2e9]
			; ]
			; size: clip [min max] size
		; ]
		; ;-- rest is treated as `none`
	; ]
	; set target size
	; if any [force  not size == get target] [set target size]
	; size
; ]

working tube until alignments/axes were added
; tube: context [
	; ;; settings for tube layout:
	; ;;   axes          [block! none!]   2 words, any of [n e] [n w] [s e] [s w] [e n] [e s] [w n] [w s]
	; ;;                                  in essence, any of n/e/s/w but both should be orthogonal, total 4x2
	; ;;                                  default = [s e] - top-down rows, left-to-right items
	; ;;   align         [block! none!]   2 integers, any of [-1 0 1]: list within row, then item within list
	; ;;                                  default = [-1 -1] ??????
	; ;@@ TODO: reverse or rework alignment order, it's awkward and impossible to understand
	; ;;   margin           [pair!]   >= 0x0
	; ;;   spacing          [pair!]   >= 0x0
	; ;;   canvas         [none! pair!]   > 0x0, cannot be none as tube needs to know it's width
	; create: function [
		; "Builds a tube layout out of given spaces and settings as bound words"
		; spaces [block! function!] "List of spaces or a picker func [/size /pick i]"
		; settings [block!] "Any subset of [axes align margin spacing canvas cache]"
		; ;; settings - imported locally to speed up and simplify access to them:
		; /local axes align margin spacing canvas
	; ][
		; func?: function? :spaces
		; count: either func? [spaces/size][length? spaces]
		; if count <= 0 [return copy/deep [0x0 []]]
		; foreach word settings [						;-- free settings block so it can be reused by the caller
			; set bind word 'local get word			;@@ check that only allowed words are overwritten, not e.g. `count`
		; ]
		; #debug [typecheck [
			; axes     [none! block! (find/only [[n e] [n w] [s e] [s w] [e n] [e s] [w n] [w s]] axes)]
			; align    [none! block! (all [find [-1 0 1] align/1 find [-1 0 1] align/2])]
			; margin   [      pair! (0x0 +<= margin)]
			; spacing  [      pair! (0x0 +<= spacing)]
			; canvas   [none! pair! (0x0 +< canvas)]
		; ]]
		; default axes:  [s e]
		; default align: [-1 -1]	;@@
		; y: ortho x: anchor2axis axes/1
		
		; ;; to support automatic sizing, each item's constraints (`limits`) has to be analyzed
		; ;; obviously there can be two strategies:
		; ;;  1. fill everything with max size, then shrink, and rearrange as possible
		; ;;  2. fill everything with min size, then expand within a single row
		; ;;  2nd option seems more predictable and easier to implement
		; ;; constraint presence does not mean that space can reach that size as content affects it too,
		; ;; so it should only be used as hint (canvas size passed to render) to obtain real min size
		; ;; then, every item that has a nonzero weight has to be rendered twice (so cache is not supported):
		; ;; once to get it's minimum appearance, second time to expand it along the row
		; ;; other items also has to be rendered twice - to fill the row height, even though width is constant
		
		; ;; constraints question is also a tricky one
		; ;; I decided to estimate min. size of each space by using 0x2e9 and 2e9x0 canvases (best fit for text/tube)
		; ;; then each space will report the "narrowest" possible form of it, suiting tube needs
		; ;; when limits/min is set, it overrides the half-unlimited canvas
		; ;; when only limits/max is set, it's "height" overrides the infinite 2e9, "width" stays zero
		; ;@@ for this to work, buttons/radios/etc must never wrap or ellipsize their text,
		; ;@@ and single-line generic text style is desirable with the option to: always show full text, ellipsize it, or clip
		; ;@@ also 4th cached canvas may be needed!
		
		; ;; obtain constraints info
		; ;; `info` can't be static since render may call another build-map; same for other arrays here
		; ;; info format: [space-name space-object draw-block drawn-width ]
		; info: obtain block! count * 5
		; #leaving [stash info]
		
		; stripe: 0 by infxinf/x						;-- thinnest canvas possible, used to estimate min. space/size
		; repeat i count [
			; space: get name: either func? [spaces/pick i][spaces/:i]
			; drawn: render/on name stripe			;-- 1st render needed to obtain min *real* space/size, which may be > limits/max
			; weight: any [select space 'weight 0]
			; #assert [number? weight]
			; available: 1.0 * case [					;-- max possible width extension length, normalized to weight
				; weight <= 0 [0]						;-- fixed size
				; not max-size: all [space/limits space/limits/max] [infxinf/x]	;-- unlimited extension possible ;@@ REP #113
				; pair? max-size [max-size/x - space/size/x / weight]
				; number? max-size [max-size - space/size/x / weight]		;@@ only use on vertical tubes
			; ]
			; ;; if width is infinite, this 1st `drawn` block and `space/size` will be used as there's no meaningful width to fill
			; ;; otherwise they're just drafts and will be replaced by proper size & block
			; repend info [name space drawn available weight]
		; ]
		
		; ;; split info into rows according to found min widths
		; rows: obtain block! 40
		; row:  obtain block! count * 5
		; row-size: -1x0 * spacing					;@@ not gonna work for empty rows
		; allowed-row-width: either all [canvas canvas/x < infxinf/x] [canvas/x - (2 * margin/x)][infxinf/x]
		; peak-row-width: 0							;-- will be used to determine full layout size
		; canvas: layout/width - (2 * margin/x) by 2e9		;@@ use canvas ?
		; foreach [name space drawn available weight] info [
			; new-row-size: as-pair					;-- add item-size and check if it hangs over
				; row-size/x + space/size/x + spacing/x
				; max row-size/y space/size/y			;-- height will only be needed in infinite width case (no 2nd render)
			; peak-row-width: max peak-row-width new-row-size/x
			; row-size: either any [					;-- row either fits allowed-row-width, or has no items yet?
				; new-row-size/x <= allowed-row-width
				; tail? row
			; ][										;-- accept new width
				; new-row-size
			; ][										;-- else move this item to next row
				; append (new-row: obtain block! length? row) row
				; repend rows [row-size new-row]
				; clear row
				; space/size
			; ]
			; repend row [name space drawn available weight]
		; ]
		; repend rows [row-size row]
		; #leaving [foreach [_ row] rows [stash row]  stash rows]
		
		; ;; expand row items - facilitates a second render cycle of the row
		; if allowed-row-width < infxinf/x [			;-- only if width is constrained
			; forall rows [							;@@ use for-each
				; set [row-size: row:] rows
				; free: allowed-row-width - row-size/x
				; if free > 0 [						;-- any space left to distribute?
					; ;; free space distribution mechanism relies on continuous resizing!
					; ;; render itself doesn't have to occupy max-size or the size we allocate to it
					; ;; and since we don't know what render is up to,
					; ;; we can only "fix" it by re-rendering until we fill whole row space
					; ;; but this will be highly inefficient, and not even guaranteed to ever finish
					; ;; so a proper solution in this case should be to use a custom layout or resize hook
					; ;@@ this needs to be documented, and maybe another sizing type should be possible: a list of valid sizes
					; weights: clear []				;-- can be static, not used after distribute
					; extras:  clear []
					; foreach [_ _ _ available weight] row [	;@@ use 2 map-eachs
						; append weights weight
						; append extras  available
					; ]
					; extensions: distribute free weights extras
					
					; row-size: -1x0 * spacing		;@@ not gonna work for empty rows
					; peak-row-width: 0
					; repeat i length? extensions [	;@@ use for-each
						; set [name: space:] item: skip row i - 1 * 5
						; desired-size: space/size/x + extensions/:i by row-size/y
						; item/3: render/on name desired-size
						; item/4: space/size			;-- use real `space/size` for positioning, not `desired-size`
						; row-size: as-pair			;-- update row size with the new render results
							; row-size/x + space/size/x + spacing/x
							; max row-size/y space/size/y
					; ]
					; rows/1: row-size
					; peak-row-width: max peak-row-width row-size/x
				; ]
				; rows: next rows
			; ]
		; ]
		
		; ;; build the map & measure the final layout size using results of 1st or 2nd render
		; map:   clear []
		; row-y: margin/y
		; total-length: 0
		; foreach [row-size row] rows [
			; ofs: margin/x by row-y
			; foreach [name space drawn _ _] row [
				; ofs/y: to integer! row-size/y - space/size/y / 2 + row-y
				; geom: reduce ['offset ofs 'size space/size 'drawn drawn]	;@@ use alignment
				; repend map [name geom]
				; ofs/x: ofs/x + spacing/x + space/size/x
			; ]
			; total-length: total-length + row-size/y + spacing/y
			; row-y: margin/y + total-length
		; ]
		; total-length: total-length - spacing/y
		
		; size: 2x2 * margin + (peak-row-width by total-length)
		; #assert [size +< infxinf]
		; reduce [size copy map]
	; ]

; ]

this invalidation doesn't work if space contains itself (or another space with this space inside) - overflows
; set 'invalidate-cache function [
	; "If SPACE's draw caching is enabled, enforce next redraw of it and all it's ancestors"
	; space [object! tag!] "Use <everything> to affect all spaces"
; ][
	; either tag? space [
		; #assert [space = <everything>]
		; clear render-cache
	; ][
		; if pos: find/same parents-list space [		;-- no matter if cache?=yes or no, parents still have to be invalidated
			; foreach [node parent] pos/2 [
				; while [node: find/same/tail node space] [
					; change/dup at node 3 'free slots		;-- remove cached draw blocks but not the children node!
				; ]
				; #assert [not space =? parent]
				; if parent [invalidate-cache parent]			;-- can be none if upper-level space
			; ]
		; ]
	; ]
; ]

grid-cell is no longer needed as general cell is available
; spaces/grid-cell: make-template 'space [
	; map: [space [offset 0x0 size 0x0]]
	; map/1: make-space/name 'space []
	; draw: function [] [
		; spc: get name: map/1
		; cdrawn: render name
		; map/2/size: spc/size
		; unless size [self/size: spc/size]
		; compose/only [
			; box 0x0 (size)	;-- already done in styles
			; (cdrawn)
		; ]
	; ]
; ]

parts of the prehistoric data-view template, now handled by box and on-change
; invalidate: does [set-quiet 'valid? no]
; set-content: function [] [
	; case [
		; block? :data [								;-- only recreates item spaces as necessary
			; unless content = 'list [set-quiet 'content make-space/name 'list []]
			; list: get content
			; maybe list/margin: 0x0					;-- fit the list contents tightly, as we already have a margin
			; maybe list/spacing: spc: spacing * 1x1	;-- ensure a pair value
			; mrg: margin * 1x1
			; n: length? data
			; ;-- evenly distribute the items	only when width is fixed:  ;@@ any better idea??
			; ;@@ also how to or should we apply width to images?
			; item-width: all [width  to 1 width - (n - 1 * spc/x) - (2 * mrg/x) / n]
			; repeat i n [
				; value: :data/:i
				; unless item: list/item-list/:i [
					; append list/item-list item: anonymize 'item make-space 'data-view []
				; ]
				; item: get item
				; maybe item/width: item-width
				; set/any 'item/data :value
				; item/set-content
			; ]
			; clear skip list/item-list n
		; ]
		; image? :data [
			; unless content = 'image [set-quiet 'content make-space/name 'image []]
			; img: get content
			; img/data: data			;@@ copy or not? images consume RAM easily; need them at least GC-able to copy
			; img/data: copy data
		; ]
		; 'else [
			; text: either string? :data [copy data][mold :data]		;@@ limit it or not?
			; unless content = 'paragraph [set-quiet 'content make-space/name 'paragraph []]
			; para: get content
			; maybe para/margin: margin
			; maybe para/text: text
			; unless para/font =? font [para/font: font]
		; ]
	; ]
	; set-quiet 'valid? yes
; ]
; draw: function [/on canvas [pair! none!]] [
	; unless valid? [set-content]
	; obj: get content
	; cdraw: render/on content canvas					;-- apply style to get the size
	; sz: (mrg: margin * 1x1) * 2 + obj/size
	; fsz: any [canvas sz]							;-- adapts it's size to canvas, if provided
	; foreach x [x y] [								;-- but if it's unlimited, uses rendered size
		; if fsz/:x >= 2e9 [fsz/:x: sz/:x]
	; ]
	; self/size: fsz
	; change/only change map content compose [offset: (mrg) size: (sz - mrg)]
	; compose/deep/only [
		; clip 0x0 (sz) [				;@@ clipping should be done automatically somewhere for all spaces
			; translate (mrg) (cdraw)
		; ]
	; ]
; ]

attempt to make click+drag UX for radial menus - not so good		
; radial-visible?: no
; register-finalizer [up down] function [				;-- finalizer so other spaces can eat the event
	; space [object! none!] path [block!] event [event! none!]
	; /extern radial-visible?
; ][
	; either event/type = 'down [
		; if all [
			; menu: find-field path 'menu block!
			; has-flag? :menu/1 'radial
		; ][
			; offset: face-to-window event/offset event/face
			; reset-hint event
			; show-menu event/window 1 offset menu
			; start-drag/with path event/offset
			; radial-visible?: yes
		; ]
	; ][
		; if radial-visible? [
			; radial-visible?: no
			; picked: all [pos: find find path 'radial-menu 'round-clickable]
			; ?? path
			; ?? picked
		; ]
	; ]
; ]

attempt in on-time to work around #5130, but it's slower, text is not smooth
and image cannot filled with transparent color using draw (need change/dup which is an extra draw)
; face/image: any [face/image make image! face/size]
; draw face/image compose [pen off fill-pen white box 0x0 (face/size)]
; draw face/image render face
; maybe face/draw: none
 
old 'expected' custom parse rule - it lead to very cryptic code I couldn't read myself 
; ;; parse helper: reshape [ !(expected block!) or !(expected [integer! | float!]) ]
; expected: function ['rule] [
    ; reshape [!(rule) | p: (ERROR "Expected (mold quote !(rule)) at: (mold/part p 100)")]
; ]

rendering as it was in the tree model that proved not so useful
; context [
	; ;; render cache format: [space-object [children] last-write-index 4x [canvas space-size map drawn] ...] (a tree of hashes)
	; ;;   it holds rendered draw block of all spaces that have /cache? = true
	; ;;   such cache only has slots for 4 canvas sizes, which should be enough for most cases hopefully
	; ;;   otherwise we'll have to iterate over all cached canvas sizes which is not great for performance
	; ;;   last write index helps efficiently fill the cache (other option - use random 4, which is less efficient)
	; ;;   space-size is required because `draw` usually changes space/size and if draw is avoided, /size still must be set
	; ;;   unused slots contain 'free word to distinguish committed canvas=none case from unused cache slot
	; ;; parent cache format: [space-object [containing-node parent-object ...] ...] (flat 2-leveled)
	; ;;   parent cache is used by `invalidate` to go up the tree and invalidate all parents so the target space gets re-rendered
	; ;;   it holds rendering tree of parent/child relationships on the last rendered frame
	
	; ;; caching workflow:
	; ;; - drawn spaces draw blocks are committed to the cache if they have /cache? enabled
	; ;; - render checks cache first, and only performs draw if cache is not found
	; ;;   each block corresponds to a particular canvas size (usually 3: unlimited, half-unlimited and limited, but tube uses 3 except none)
	; ;; - spaces should detect changes in their data that require new rendering effort and call `invalidate`
	; ;;   invalidate uses last rendered parents tree to locate upper nodes and invalidate them all
	; ;;   (there can be multiple parents to the same space)
	; ;@@ TODO: document this in a proper place
	
	; hash!: :block!
	; period:         4									;-- size occupied by a single cached entry
	; slots:          16									;-- size occupied by cache of single space - a multiple of period!
	; ;@@ TODO: both render-cache and parents-list require cleanup on highly dynamic layouts, or they slow down
	; ;@@ will need a flat registry of still valid spaces
	; render-cache:   make hash! slots + 3 * 3
	; parents-list:   make hash! 2048
	
	; visited-nodes:  make block! 32						;-- stack of nodes currently visited by render
	; visited-spaces: make block! 32						;-- stack of spaces currently visited by render
	; append/only visited-nodes render-cache				;-- currently rendered node (hash) where to look up spaces
	
	; ;@@ a bit of an issue here is that <everything> doesn't call /invalidate() funcs of all spaces
	; ;@@ but maybe they won't be needed as I'm improving the design?
	; set 'invalidate function [
		; "Invalidate SPACE content and cache, or use <everything> to affect all spaces' cache"
		; space [word! object! tag!] "If contains `invalidate` func, it is evaluated"
	; ][
		; if word? space [
			; space: get space
			; #assert [object? space]
		; ]
		; invalidate-cache space
		; all [
			; object? space
			; any-function? custom: select space 'invalidate
			; custom
		; ]
	; ]
	
	; invalidation-stack: make hash! []
	
	; set 'invalidate-cache function [
		; "If SPACE's draw caching is enabled, enforce next redraw of it and all it's ancestors"
		; space [object! tag!] "Use <everything> to affect all spaces"
		; /only "Do not invalidate parents (e.g. if they are invalid already)"
	; ][
		; #debug profile [prof/manual/start 'invalidation]
		; either tag? space [
			; #assert [space = <everything>]
			; dump-parents-list parents-list render-cache
			; ;@@ what method to prefer? parse or radical?
			; clear render-cache
			; clear parents-list
			; parse render-cache rule: [any [skip into rule skip slots change skip 'free]]
		; ][
			; unless find/same invalidation-stack space [			;-- stack overflow protection for cyclic trees 
				; #debug cache [#print "Invalidating space=[(mold/part/only/flat body-of space 80)]"]
				; if pos: find/same parents-list space [			;-- no matter if cache?=yes or no, parents still have to be invalidated
					; append invalidation-stack space
					; foreach [node parent] pos/2 [
						; while [node: find/same/tail node space] [
							; change/dup at node 3 'free slots	;-- remove cached draw blocks but not the children node!
						; ]
						; #assert [not space =? parent]
						; all [
							; not only
							; parent								;-- can be none if upper-level space
							; invalidate-cache parent
						; ]
					; ]
					; remove top invalidation-stack
				; ]
			; ]
		; ]
		; #debug profile [prof/manual/end 'invalidation]
	; ]
	
	; find-cache: function [
		; "Find location of SPACE in the currently rendered cache node"
		; space [object!]
	; ][
		; find/same last visited-nodes space
	; ]
	
	; get-cache: function [
		; "If SPACE's draw caching is enabled and valid, return it's cached draw block"
		; space [object! word!] canvas [pair! none!]		;-- word helps debugging
	; ][
		; if word? space [space: get name: space]			;@@ remove me once cache is stable to speed it up
		; r: all [
			; cache: find-cache space								;-- must have a cache
			; find/skip/part skip cache 3
				; any [canvas 'none] period slots					;@@ workaround for #5126
			; find/skip/part skip cache 3 canvas 3 slots			;-- search for the same canvas among 3 options
			; print mold~ copy/part cache >> 2 slots
		; ]
		; if cache [print rejoin ["cache=" map-each/eval [a b _] copy/part skip cache 3 slots [[a b]]]]
		; #debug cache [
			; name: any [name 'space]
			; either r [
				; #print "Found cache for (name) size=(space/size) on canvas=(canvas): (mold/flat/only/part to [] r 40)"
			; ][
				; reason: case [
					; cache [rejoin ["cache=" mold to [] extract copy/part skip cache 3 slots period]]
					; not space/size ["never drawn"]
					; not select space 'cache? ["cache disabled"]
					; 'else ["not cached or invalidated"]
					; 'else [probe~ last visited-nodes "not cached or invalidated"]
				; ]
				; #print "Not found cache for (name) size=(space/size) on canvas=(canvas), reason: (reason)"
			; ]
		; ]
		; r
	; ]
	
	; commit-cache: function [
		; "Save SPACE's Draw block on this CANVAS in the cache"
		; space  [object! word!]							;-- word helps debugging
		; canvas [pair! none!]
		; drawn  [block!]
	; ][
		; if word? space [space: get name: space]			;@@ remove me once cache is stable to speed it up
		; unless select space 'cache? [exit]				;-- do nothing if caching is disabled
		; cache: find/same last visited-nodes space
		; #assert [cache]
		; canvas: any [canvas 'none]						;@@ workaround for #5126
		; unless pos: find/skip/part skip cache 3 canvas period slots [
			; pos: skip cache 3 + (cache/3 * period)
			; change at cache 3 cache/3 + 1 % (slots / period)	;@@ #5120 ;-- rotate slot for the next canvas
			; pos/1: canvas								;@@ #5120
			; change pos canvas
		; ]
		; pos/2: drawn									;@@ #5120
		; #assert [pair? space/size]
		; rechange next pos [space/size select space 'map drawn]
		; #debug cache [
			; name: any [name 'space]
			; #print "Saved cache for (name) size=(space/size) on canvas=(canvas): (mold/flat/only/part drawn 40)"
		; ]
	; ]
	
	; set-parent: function [
		; "Mark parent/child relationship in the new parents cache"
		; child  [object!]
		; parent [object! none!]							;-- parent=none is allowed to mark top level spaces as cacheable
	; ][
		; #assert [not child =? parent]
		; node: last visited-nodes						;-- tree node where current `child` is found
		; either parents: select/same parents-list child [
			; pos: any [
				; find/same/only parents node				;-- do not duplicate parents
				; tail parents
			; ]
			; rechange pos [node parent]					;-- each parent contains different node with this child 
		; ][
			; repend parents-list [child reduce [node parent]]
		; ]
	; ]
	
	; enter-cache-branch: function [
		; "Descend down the render cache tree into SPACE's branch"
		; space [object!] "Branch is created if doesn't exist"
	; ][
		; set-parent space last visited-spaces 			;-- once set, next renders will look it up in the cache
		; append visited-spaces space
		; append/only visited-nodes any [
			; select/same level: last visited-nodes space
			; also branch: make hash! 3 + slots * 2
				; append/dup repend level [space branch 0] 'free slots
		; ]
	; ]
	
	; leave-cache-branch: function [
		; "Ascend up the render cache tree"
	; ][
		; remove top visited-nodes
		; remove top visited-spaces
	; ]

	; #debug cache [										;-- for cache creep detection
		; cache-size?: function [node [any-block!]] [
			; size: length? node
			; forall node [
				; inner: node/2
				; size: size + cache-size? inner
				; node: skip node 2 + slots
			; ]
			; size
		; ]
		; parents-size?: function [] [
			; size: length? parents-list
			; foreach [_ block] parents-list [size: size + length? block]
		; ]
	; ]

	; #if true = get/any 'disable-space-cache? [
		; clear body-of :invalidate-cache
		; append clear body-of :get-cache none
		; clear body-of :commit-cache
		; clear body-of :set-parent
		; clear body-of :enter-cache-branch
		; clear body-of :leave-cache-branch
	; ]
	
	; ;-- draw code has to be evaluated after current-path changes, for inner calls to render to succeed
	; with-style: function [
		; "Draw calls should be wrapped with this to apply styles properly"
		; name [word!] code [block!]
	; ][
		; append current-path name
		; trap/all/catch code [
			; msg: form/part thrown 1000					;@@ should be formed immediately - see #4538
			; #print "*** Failed to render (name)!^/(msg)^/"
		; ]
		; take/last current-path
	; ]
	
	; render-face: function [
		; face [object!] "Host face"
		; /only xy1 [pair! none!] xy2 [pair! none!]
	; ][
		; #debug styles [#print "render-face on (face/type) with current-path: (mold current-path)"]
		; #assert [
			; is-face? :face
			; face/type = 'base
			; in face 'space
			; empty? current-path
		; ]

		; host: face										;-- required for `same-paths?` to have a value (used by cache)
		; with-style 'host [
			; style: compose/deep bind get-current-style face	;-- host style can only be a block
			; drawn: render-space/only/on face/space xy1 xy2 face/size
			; #assert [block? :drawn]
			; unless face/size [								;-- initial render: define face/size
				; space: get face/space
				; #assert [space/size]
				; face/size: space/size
				; style: compose/deep bind get-current-style face	;-- reapply the host style using new size
			; ]
			; render: reduce [style drawn]
		; ]
		; #debug cache [#print "cache size=(cache-size? render-cache) parents size=(parents-size?)"]
		; any [render copy []]
	; ]

	; render-space: function [
		; name [word!] "Space name pointing to it's object"
		; /only xy1 [pair! none!] xy2 [pair! none!]
		; /on canvas [pair! none!]
	; ][
		; if name = 'cell [?? canvas]
		; #debug profile [prof/manual/start 'render]	
		; space: get name
		; if canvas [canvas: max 0x0 canvas]				;-- simplifies some arithmetics; but subtract-canvas is better
		; #assert [space? :space]
		; #assert [not is-face? :space]					;-- catch the bug of `render 'face` ;@@ TODO: maybe dispatch 'face to face
		; #assert [
			; any [
				; none = canvas canvas +<= (1e6 by 1e6) canvas/x = 2e9 canvas/y = 2e9
				; also no #print "(name): canvas=(canvas)" 
			; ] "Oversized canvas detected!"
		; ]
		; #assert [
			; any [
				; none = canvas  0x0 +<= canvas
				; also no #print "(name): canvas=(canvas)" 
			; ] "Negative canvas detected!"
		; ]

		; with-style name [
			; style: get-current-style
			; ;@@ this does not allow the style code to invalidate the cache
			; ;@@ which is good for resource usage, but limits style power
			; ;@@ so maybe compose styles first, then check the cache?
			
			; either all [
				; not xy1 not xy2							;-- usage of region is not supported by current cache model
				; cache: get-cache name canvas
			; ][
				; set [size: map: render:] next cache
				; #assert [pair? size]
				; maybe space/size: size
				; if in space 'map [space/map: map]
				; set-parent space last visited-spaces	;-- mark it as cached in the new parents tree
				; #debug cache [							;-- add a frame to cached spaces after committing
					; render: compose/only [(render) pen green fill-pen off box 0x0 (space/size)]
				; ]
			; ][
				; if name = 'list [print ["canvas:" canvas mold space/item-list]]
				; #debug profile [prof/manual/start name]
				; enter-cache-branch space
				
				; either block? :style [
					; style: compose/deep bind style space	;@@ how slow this bind will be? any way not to bind? maybe construct a func?
					; draw: select space 'draw
					
					; ;@@ this basically cries for FAST `apply` func!!
					; if function? :draw [
						; spec: spec-of :draw
						; either find spec /only [only: any [xy1 xy2]][set [xy1: xy2: only:] none]
						; canvas': either find spec /on [		;-- must not affect `canvas` used by cache, thus new name
							; constrain canvas space/limits
						; ][
							; on: none						;-- don't constrain if no /on refinement
						; ]
						; code: case [						;@@ workaround for #4854 - remove me!!
							; all [canvas' only] [[draw/only/on xy1 xy2 canvas']]
							; only               [[draw/only    xy1 xy2        ]]
							; canvas'            [[draw/on              canvas']]
						; ]
					; ]
					; draw: either code [do copy/deep code][draw]	;-- call the draw function if not called yet
					; #assert [block? :draw]
					
					; if empty? style [unset 'style]
					; render: compose/only [(:style) (:draw)]		;-- compose removes style if it's unset
				; ][
					; #assert [function? :style]
					; ;@@ this basically cries for FAST `apply` func!!
					; spec: spec-of :style
					; either find spec /only [only: any [xy1 xy2]][set [xy1: xy2: only:] none]
					; canvas': either find spec /on [		;-- must not affect `canvas` used by cache, thus new name
						; constrain canvas space/limits
					; ][
						; on: none						;-- don't constrain if no /on refinement
					; ]
					; code: case [					
						; all [canvas' only] [[style/only/on space xy1 xy2 canvas']]
						; only               [[style/only    space xy1 xy2        ]]
						; canvas'            [[style/on      space         canvas']]
					; ]
					; render: either code [do copy/deep code][style space]	;@@ workaround for #4854 - remove me!!
					; #assert [block? :render]
				; ]
				
				; leave-cache-branch
				; unless any [xy1 xy2] [commit-cache name canvas render]
				; commit-cache space canvas render
				
				; #debug profile [prof/manual/end name]
				; #assert [any [space/size name = 'grid] "render must set the space's size"]	;@@ should grid be allowed have infinite size?
			; ]
		; ]
		; #debug profile [prof/manual/end 'render]	
		; either render [
			; reduce ['push render]						;-- don't carry styles over to next spaces
		; ][
			; []											;-- never changed, so no need to copy it
		; ]
	; ]

	; set 'render function [
		; "Return Draw code to draw a space or host face, after applying styles"
		; space [word! object!] "Space name, or host face as object"
		; /only "Limit rendering area to [XY1,XY2] if space supports it"
			; xy1 [pair! none!] xy2 [pair! none!]
		; /on canvas [pair! none!] "Specify canvas size as sizing hint"
	; ][
		; render: either word? space [:render-space][:render-face]
		; render/only/on space xy1 xy2 canvas
		; drawn: either word? space [					;@@ workaround for #4854 - remove me!!
			; render-space/only/on space xy1 xy2 canvas
		; ][
			; render-face/only space xy1 xy2
		; ]
		; #debug draw [									;-- test the output to figure out which style has a Draw error
			; if error? error: try/keep [draw 1x1 drawn] [
				; prin "*** Invalid draw block: "
				; attempt [copy/deep drawn]				;@@ workaround for #5111
				; probe~ drawn
				; do error
			; ]
		; ]
		; drawn
	; ]
; ]

simpler flat cache model, but I'm afraid it won't work with fixed number of slots
because if the same e.g. image is shared multiple times around, 4 slots now become a bottleneck
since it may be given a vast variety of canvases
I could apply limits before fetching canvas, but it's still not a solution but a kludge
what if limits are undefined, but size is fixed anyway?
; ;; after changing cache format multiple times, I'm using named constants now:
; prefix:         2									;-- size before the first slot
; period:         4									;-- size occupied by a single cached entry
; slots:          period * 4							;-- size occupied by cache of single space - a multiple of period!
; ;@@ TODO: both render-cache and parents-list require cleanup on highly dynamic layouts, or they slow down
; ;@@ will need a flat registry of still valid spaces
; render-cache:   make hash! slots + prefix * 3
; parents-list:   make hash! 2048

; free-list:      copy/deep block-stack				;-- used to reduce memory pressure
; free-list/size: slots

; ;@@ a bit of an issue here is that <everything> doesn't call /invalidate() funcs of all spaces
; ;@@ but maybe they won't be needed as I'm improving the design?
; set 'invalidate function [
	; "Invalidate SPACE content and cache, or use <everything> to affect all spaces' cache"
	; space [word! object! tag!] "If contains `invalidate` func, it is evaluated"
; ][
	; if word? space [
		; space: get space
		; #assert [object? space]
	; ]
	; invalidate-cache space
	; all [
		; object? space
		; any-function? custom: select space 'invalidate
		; custom
	; ]
; ]

; invalidation-stack: make hash! []

; set 'invalidate-cache function [
	; "If SPACE's draw caching is enabled, enforce next redraw of it and all it's ancestors"
	; space [object! tag!] "Use <everything> to affect all spaces"
	; /only "Do not invalidate parents (e.g. if they are invalid already)"
; ][
	; #debug profile [prof/manual/start 'invalidation]
	; either tag? space [
		; #assert [space = <everything>]
		; ;@@ what method to prefer? parse or radical (clear)?
		; clear render-cache
		; clear parents-list
		; parse render-cache rule: [any [skip into rule skip slots change skip 'free]]
	; ][
		; unless find/same invalidation-stack space [			;-- stack overflow protection for cyclic trees 
			; #debug cache [#print "Invalidating space=[(mold/part/only/flat body-of space 80)]"]
			; if node: find/same rendering-cache space [
				; fast-remove node prefix + slots
			; ]
			; ;; no matter if cache?=yes or no, parents still have to be invalidated
			; if all [
				; not only
				; parents: select/same parents-list space
			; ][
				; append invalidation-stack space
				; #assert [not find/same parents space]
				; foreach parent parents [invalidate-cache parent]
				; remove top invalidation-stack				;@@ not using take/last for #5066
			; ]
		; ]
	; ]
	; #debug profile [prof/manual/end 'invalidation]
; ]

; find-cache: function [
	; "Find location of SPACE in the currently rendered cache node"
	; space [object!]
; ][
	; find/same render-cache space
; ]

; get-cache: function [
	; "If SPACE's draw caching is enabled and valid, return it's cached slot for given canvas"
	; space [object! word!] canvas [pair! none!]		;-- word helps debugging
; ][
	; if word? space [space: get name: space]			;@@ remove me once cache is stable to speed it up
	; r: all [
		; cache: find-cache space						;-- must have a cache
		; find/skip/part skip cache prefix canvas period slots
	; ]
	; if cache [print rejoin ["cache=" map-each/eval [a b _] copy/part skip cache prefix slots [[a b]]]]
	; #debug cache [
		; name: any [name 'space]
		; either r [
			; #print "Found cache for (name) size=(space/size) on canvas=(canvas): (mold/flat/only/part to [] r 40)"
		; ][
			; reason: case [
				; cache [rejoin ["cache=" mold to [] extract copy/part skip cache 3 slots period]]
				; not space/size ["never drawn"]
				; not select space 'cache? ["cache disabled"]
				; 'else ["not cached or invalidated"]
			; ]
			; #print "Not found cache for (name) size=(space/size) on canvas=(canvas), reason: (reason)"
		; ]
	; ]
	; r
; ]

; commit-cache: function [
	; "Save SPACE's Draw block on this CANVAS in the cache"
	; space  [object! word!]							;-- word helps debugging
	; canvas [pair! none!]
	; drawn  [block!]
; ][
	; if word? space [space: get name: space]			;@@ remove me once cache is stable to speed it up
	; unless select space 'cache? [exit]				;-- do nothing if caching is disabled
	; cache: find/same render-cache space
	; #assert [cache]
	; #assert [pair? space/size]
	; map: select space 'map							;-- doesn't have to exist
	; either node: find/skip/part skip cache prefix canvas period slots [
		; rechange next node [space/size map drawn]
	; ][
		; node: skip cache cache/:prefix * period + prefix
		; rechange back node [
			; cache/:prefix + 1 % (slots / period) 	;-- rotate slot for the next canvas
			; canvas space/size map drawn
		; ]
	; ]
	; #debug cache [
		; name: any [name 'space]
		; #print "Saved cache for (name) size=(space/size) on canvas=(canvas): (mold/flat/only/part drawn 40)"
	; ]
; ]

; set-parent: function [
	; "Mark parent/child relationship in the parents cache"
	; child  [object!]
	; parent [object! none!]
; ][
	; #assert [not child =? parent]
	; unless parent [exit]							;-- no parent for top level spaces = no need to hold it
	; either parents: select/same parents-list child [
		; any [
			; find/same/only parents parent			;-- do not duplicate parents
			; append/only parents parent
		; ]
	; ][
		; append/only append parents-list child reduce [parent]
	; ]
; ]

timers that took 100% CPU time in tube-test
; foreach-space [path space] face/space [
	; unless all [
		; rate: select space 'rate				;-- no rate facet
		; positive? rate							;-- disabled
	; ] [continue]
	; #assert [any [time? rate  float? rate  integer? rate]]
	; if number? rate [rate: 0:0:1 / rate]		;-- turn rate into period
	
	; pos: find/same/tail marks space
	; set [prev: bias:] any [pos [0:0 0:0]]
	; delay: either pos [difference time prev + rate][0:0]		;-- estimate elapsed delay for this timer
	; if delay < negate timer-resolution / 2 + bias [continue]	;-- too early to call it?
	
	; args: reduce/into [to 1% delay / rate] clear []
	; path: new-line/all as [] path no
	; ;; even if no time handler, actors or previewers/finalizers may be defined
	; events/do-previewers top path event args
	; forall path [
		; compose/into [handlers (path) on-time] clear hpath		;-- not allocated
		; unless block? try [list: get hpath] [continue]			;-- no time handler ;@@ REP #113
		; foreach handler list [									;-- call the on-time stack
			; #assert [function? :handler]
			; events/do-handler next hpath :handler top path event args 
		; ]
	; ]
	; events/do-finalizers top path event args
	
	; unless pos [pos: tail append marks space]
	; delay: min delay rate * 5					;-- avoid frame spikes after a lag or sleep
	; change change pos time bias + delay			;-- mark last timer call time for this space
	; ;@@ TODO: cap bias at some maximum, for 50+ fps cases, so it won't run away
	
	; time: now/utc/precise						;-- update time after handlers evaluation
; ]

turns out touch-clicks generate `over over down over` event chain, so no need to catch `down` since `over` hides the menu
actually, I need to catch also `up` and not generate `click`, but doesn't seem worth it
; ;; eats touch events outside the visible menu window
; register-previewer [down] function [				;-- previewer so it takes precedence on menu things
	; space [object! none!] path [block!] event [event!]
; ][
	; stack: get-popups-for event/window
	; if all [
		; menu: stack/2								;-- menu exists
		; find/same event/window/pane menu			;-- menu visible
		; not same? event/face menu					;-- click didn't land on menu host
	; ][
		; hide-popups event/window 1
		; stop										;-- eat the event, closing the menu
	; ]
; ]

wanted to use this for grid but reconsidered, decided to support explicit return instead
; fit-pair: function [
	; "Fit pair XY into SIZE/X if it sticks out horizontally"
	; xy   [pair!]
	; size [pair! none! unset!]
; ][
	; if all [
		; pair? :size
		; xy/x > size/x
	; ][
		; xy/y: xy/y + to integer! xy/x - 1 / size/x
		; xy/x: xy/x - 1 % size/x + 1
	; ]
	; xy
; ]

; #assert [
	; 3x2 = fit-pair 3x2 none
	; 3x2 = fit-pair 3x2 10x10
	; 3x2 = fit-pair 3x2 3x3
	; 3x2 = fit-pair 7x1 4x0
	; 1x3 = fit-pair 3x2 2x3
; ]

original field handlers
; field: [
	; ;-- `key-down` supports key-combos like Ctrl+Tab, `key` does not seem to
	; ;-- OTOH `key` properly reflects Shift state in chars
	; ;-- so we have to use both
	; on-key [space path event] [				;-- char keys branch (inserts stuff as you type)
		; k: event/key
		; either space/active? [					;-- normal input when active
			; unless all [
				; char? k
				; any [
					; k >= #" "						;-- printable char
					; k = #"^-"						;-- Tab
					; if k = #"^M" [k: #"^/"]			;-- Enter -> NL
				; ]
			; ] [exit]
			; ;@@ allow new-line char only when multiline?
			; ;@@ TODO: input validation / filtering
			; t: space/text
			; ci: space/caret-index:
				; 1 + clip reduce [0 length? t]		;-- caret-index may be >len if text was changed
					; space/caret-index
			; insert at t ci  k
			; space/invalidate						;@@ TODO: should be caught maybe automatically?
			; update
		; ][										;-- has to handle Enter, or both key-down and key will handle it, twice
			; either k = #"^M" [
				; maybe space/active?: yes			;-- activate it on Enter
				; update								;-- let styles change
			; ][
				; pass								;-- pass keys in inactive state (esp. tab)
			; ]
		; ]
	; ]
	
	; on-key-down [space path event] [			;-- control keys & key combos branch (navigation)
		; k: event/key
		; unless space/active? [pass exit]			;-- keys should be passed thru (tab, arrows, ...); Enter is in on-key
													; ;-- else, keys should be used on content (e.g. arrows)
		; if all [
			; char? k									;-- ignore chars without mod keys
			; not any [
				; find "^[^H" k						;-- use only Esc and BS
				; event/ctrl?
			; ]
		; ] [pass exit]

		; len: length? t: space/text
		; ci: clip [0 len] space/caret-index			;-- may be >len if text was changed
		; switch/default k: event/key [
			; left   [ci: ci - 1]			;@@ TODO: ctrl-arrow etc logic
			; right  [ci: ci + 1]
			; home   [ci: 0]
			; end    [ci: len]
			; delete [remove skip t ci]
			; #"^H"  [remove skip t ci: ci - 1]		;-- backspace
			; #"^["  [maybe space/active?: no]		;-- Esc = deactivate
		; ][exit]									;-- not supported yet key
		; maybe space/caret-index: clip reduce [0 length? t] ci		;-- length may have changed, <> len
		; update
	; ]

	; on-key-up [space path event] []				;-- eats the event so it's not passed forth

	; on-click [space path event] [
		; #assert [space/paragraph/layout]
		; maybe space/caret-index: offset-to-caret space/paragraph/layout path/2
		; maybe space/active?: yes					;-- activate, so Enter is not required
		; update										;-- let styles update
	; ]

	; on-focus [space path event] [
		; maybe space/caret/visible?: yes
		; update
	; ]

	; on-unfocus [space path event] [
		; maybe space/caret/visible?: no
		; update
	; ]
; ]

window/max-size was a super messy concept, not needed after adding canvas to window (good riddance)
it's persistence just didn't work together with the volatility of /sizes, at all 
; autosize-window: function [] [
	; size: any [self/size if self/limits [self/limits/min]]
	; if 0x0 +< size [maybe window/max-size: pages * size]	;-- don't ever make window empty
	; #debug sizing [#print "autosized window to (window/max-size)"]
; ]
; ;; this initializes window size to a multiple of list-view sizes (paragraphs adjust to window then)
; ;; overrides inf-scrollable's own autosize-window because `list-view` has a linear `pages` interpretation (not 2D)
; autosize-window: function [lview [object!]] [
	; size: any [lview/size lview/limits/min]			;@@ rethink how to better handle integer or invalid limit
	; unit: axis2pair lview/list/axis
	; ;; account for scrollers size, since list-view is meant to always display one along main axis
	; ;; this will make window and it's content adapt to list-view width when possible
	; ;@@ it's a bit dumb to _always_ subtract scrollers even if they're not visible
	; ;@@ need more dynamic way of adapting window size
	; scrollers: lview/hscroll/size * 0x1 + (lview/vscroll/size * 1x0) * reverse unit
	; #assert [0x0 <> size]
	; maybe lview/window/max-size: lview/pages - 1 * unit + 1 * size - scrollers
	; #assert [0x0 <> lview/window/max-size]
	; #debug sizing [#print "autosized window to (lview/window/max-size)"]
; ]

glossy triangles - decided against it, less code
; make-triangular-shape: function [
	; "Make a curved triangle"
	; size [pair!]
	; dir  [word!]  "n/s/e/w"
; ][
	; size: size * 4 / 3
	; box: size - 2
	; corners: reduce select [
		; n [2 by box/y  size/x / 2 by 2  box]
		; s [2x2 size/x / 2 by box/y  box/x by 2]
		; w [box/x by 2  2 by (size/y / 2)  box]
		; e [2x2 box/x by (size/y / 2)  2 by box/y]
	; ] dir
	; centers: reduce [
		; corners/1 + corners/2 / 2
		; corners/2 + corners/3 / 2
		; corners/3 + corners/1 / 2
	; ]
	; shape: reduce [
		; 'move centers/2
		; 'qcurve corners/3 centers/3 corners/1 centers/1 corners/2 centers/2 
	; ]
	; mul: select [n 1x2 s 1x0 w 2x1 e 0x1] dir
	; ofs: size / -4 * mul / 2
	; compose/deep/only [translate (ofs) [shape (shape)]]
; ]
; draw-triangular-frame: function [
	; "Draw a glossy triangular frame"
	; size [pair!]
	; bgnd [tuple!] "Background color"
	; dir  [word!]  "n/s/e/w"
; ][
	; shape: make-triangular-shape size dir
	; compose/deep/only [
		; line-width 2
		; pen (bgnd) fill-pen (bgnd)
		; (shape)
		
		; fill-pen off
		; pen s4 translate -1x-1 (shape)
		; pen s0 translate  1x1  (shape)
		; line-width 1
		; pen w3 (shape)
	; ]
; ]
; draw-triangular-sheen: function [
	; "Draw a bumpy triangular sheen"
	; size  [pair!]
	; dir   [word!]  "n/s/e/w"
	; sheen [percent! float!] "How pronounced is the sheen, 0-100%"
; ][
	; shape: make-triangular-shape size dir
	; edge: max size/x size/y
	; scolor: 0.0.0.255 * (100% - sheen) + white
	; sheen: switch dir [
		; s [size / 2x4 - (1x1 * edge / 2)]
		; n [size * 2x2 / 4x3 - (1x1 * edge / 2)]
		; e [size / 4x2 - (1x1 * edge / 2)]
		; w [size * 2x2 / 3x4 - (1x1 * edge / 2)]
	; ]
	; compose/deep/only [
		; pen off
		; fill-pen radial (scolor) 0.0 glass 1.0 (1x1 * edge / 2) (to integer! 1.5 * edge / 2) (sheen)
		; (shape)
	; ]
; ]
; draw-glossy-triangle: function [
	; "Draw a glossy rounded triangle"
	; size  [pair!]
	; bgnd  [tuple!]
	; sheen [percent!]
	; dir   [word!]  "n/s/e/w"
; ][
	; compose/deep [
		; (draw-triangular-frame size bgnd dir) 
		; (draw-triangular-sheen size dir sheen)
	; ]
; ]
