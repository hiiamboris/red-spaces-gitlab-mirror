TODOS
+ event handling system - standard way to react to clicks, clicks-and-holds, keypresses, etc.
keys binding to each UI item?
+ focused items should be highlighted using styles
+ decouple styles from the objects
+ demo+test of rotated scrollable space (mb rotate it with time and demo proper origin)
demo: chatlog with smooth scrolling and an interactive bot
	needs reversal of list items and a custom wrapper (sender/time+paragraph)
	also buttons to remove & edit messages
+ scrollbar should generate page events periodically until LMB is up
+ styles should be deep, e.g. paragraph! <> list-view!/paragraph!
need to try 2 types of KB navigation: tabbed and spatial, how they apply
	this navigation, at least tabbed, should be able to work across different *faces*
	so: mixed transparent tabbing across spaces and faces
+ if `map` is defined `into` should not be needed, when none is defined it is a final space (non-composite)
	or leave `into` always there? afraid of inheritance errors
draggability of spaces (e.g. table columns) - this will require temporary offsets in the map
disabled items, and they should not be focusable!
if an item gets hidden, it should not receive keyboard events even if it's still in focus
	(there will be no 'hidden', there will be 'not drawn')
+ how to decouple KB navigation from the dispatcher?
+ make content: 'a-word ! make `make` return a word with a style value!
how to compose styles from the old ones? need a clear mechanism
handler spec validation and auto addition of typesets - to help learning, minimize mistakes
list & doc ideas that improve over vid/view, key differences
debug func to list handlers for this or that space (with all path variants)
should events receive full paths (from `screen`) or relative to host (from it's `space`)??
in event handlers `self` =? `commands` right now, should be set to `space`? and get rid of `space` arg?
	this will be problematic as will require a `bind` before every handler call
+ can I externalize list-view's rolling logic to be able to utilize it in other spaces?
table demo with wavy animated layout: each row would slide left and right in a sine manner - will be a killer demo!
	and it's columns should be draggable! :D
high-level table that would extend minimal table with advanced features
maybe a plugin mechanism:
	each space would list possible features and each of them would be a separate code, that can be turned on/off
	or it's not worth it, even for the table?
demo templates for all useful styles, like small static table, huge table for csv, etc etc
	so others can take those and build upon
+ separate space for an icon+text combo -- very common thing nowadays
	or `list` will be enough?
+ VID extension for spaces:
	on-created (possible?) global event handler
	will scan each host face's worst actor and create a space tree from it's spec
rename host/space to host/content for consistency with scrollable?
	or make it host a scrollable always?
	or make separate faces for all spaces? - best idea to keep layout clean.. e.g. host.list, host.scrollable ..
+ decide on resize model (though ideally it should cover View wholly)
+ what if I devise a standard way child sizes can be propagated into parent sizes? (headers-list dilemma)
+ make multi-cell span
	how can cell span multiple rows vertically?
	perhaps separate grid style will be required
	or I just make a span: field and disable clipping everywhere (except scrollable)
	no, disabled clipping won't work as we need hittest to deliver events
	however disabled clipping may be useful for a different thing: casting wide outside shadows, but be able to click thru them
table cells should know their coordinate, to be able to modify original data
styles should be able to rearrange UI items 
	maybe by changing the map before it's rendered? but that's a bit limited
	e.g. we split `draw` into `draw` and `prep`, style would apply after prep, draw will read the map
	that complicates `space` design
	OTOH it will be possible to get the `size` without actually composing draw blocks
	like this!: if `prep` exists, it's called, if not then `draw` will do it's work
				and styles will be limited in their rearrange ability
	though then one will be unable to call prep to get the size.. maybe default prep will call draw?
+ click event should only be produced when pointer didn't travel long (i.e. it's not a drag event)
will it be possible to minimize style/event lookup time if I detect changes to the tree and to style/event tables
	and then just cache the lookup results?
optional scrollbars for infinite space:
	logarithmic, linear near the current offset
	cyclic, inertial, wheel-like in appearance
trooper-like zooming into infinite canvas? although it may take quite a time to prerender it... useless unless realtime
demo: interactive plot of some downloadable btc price
	will require a color picker (Red doesn't have one) - to edit colors, and also need to edit labels, width..
demo: neon text
demo: fractal explorer on infinite canvas
describe a set of challenges to invite other to play with it and learn
maybe scrollable should be the default container for everything layout creates? or at least for lists?
add inertia to scrollable to easier hunt the spider (maybe as a separate style or pluggable trick)
	otherwise it demonstrates how inefficient scrollbars are, as a UI element
this is a good idea though: easy way to make every scrollable area draggable with inertia
demo: jedi librarians betting game (assisted), to see how this all works in 2D games, and as a template
optimize `translate 0x0`
hints (tooltips) for everything, pluggable
demo: better console, extensible, paragraph-oriented
	it could have editable commands that re-evaluate everything below when edited 
scrollbar should work as a separate space too (e.g. influence some external value)
+ demo: infinitely zoomable table, each cell is the table itself
+	will require limiting rendering depth (or < 1 pixel size), so it won't stackoverflow
+	and resetting the zoom, else we'll hit that depth sooner or later
+	and rotating slowly, for total mind blow - gonna need `clip [circle ..]` to be the clipping region of rotor
+ truly rich text (hypertext) widget - where text is mixed with other (interactive) spaces
rename grid-view to data-grid?
demo: debugger, need to mark functions, store values of all words during last iteration or 2-3 last iterations,
	and be able to explore those (where spaces come to help)
+ demo: round lists (like in games or sketchbook) - showing the power of container/layout
splitters for UI panels
inspect https://nicepage.com/nicepage-review for anything useful
allow size to be an integer in `field` - so it will infer height automatically from font and adjust it on the fly
demo: very basic layout designer for simple webpage-like shite, one others should be able to build upon
    good example: https://discuss.streamlit.io/t/dynamic-grid-layout-ui/2097
multi level popup menus (probably on separate borderless windows)
demo: example of a glossy style sheet
`arrange` func based on flow layouts that will work with faces?
web preview component to preview the links in the chat
widget: markdown renderer (unless Bolek adds it)
	even more value is in a truly rich editor that can be used for markdown, for email composition, wiki creation etc
consider removing double blocks from styles: just check if 1st word is func/function ?
is there an alternative to styles than draw-blocks? like a set of facets and a special facet `style` for draw commands?
let one define actors for static spaces (in VID or by adding them to the space manually)
in widget reference: create a quick-nav map, somewhat like TOC but with pictures and arranged as a table
UI where user can select table features and export code for this kind of table 
if only bgnd color is specified for a widget (e.g. label), use contrast-with to determine the text color
rename field to input - a low level embeddable input field, while field should be high-level
some help support for space types? in advanced console? maybe interactive, hyper-text?
deeper design docs should include visual examples (snippets + gifs) how this or that works
document resource usage howto:
	- draw can be heavy (10-20ms)
	- spaces do not redraw unless `update` or `invalidate` is called
	- cache? = yes usage
generative planet atlas to demo full-featured table widget; galaxy name hash used as random seed
	a bit of a problem with this: can't sort infinite data, so not so good for table widget..
lists (table) polymorphism: https://www.microsoft.com/en/microsoft-365/microsoft-lists
debug-draw should become a fully-featured layout explorer to help users understand the anatomy of their layouts
	+ and it should move the main window to the left
make tree-view widget a widget creation case study (document the whole process) ?
pekr's idea is to rename `host` to `spaces` in VID/S, and it's reasonable but.. has drawbacks too - need more consideration and input
	dsunanda's vote: "A SPAN is a collection of SPACES held in one VID face"
centered text style for (wrapped) captions, and h-alignment for text faces - controlled by para! [wrap?: on align: 'center]
	also 'strike' style is supported by RTD, need to add it
high level box-like container with caption support?
have this idea of a series of short documents, "design cards", where tricky algorithms will be explained
	on one hand, code will be more maintainable (algorithms get forgotten over the years) and others will be able to verify it
	on another, it will inspire confidence in the work
eventually field/area should have a blinking caret, but it's problematic because it should not cause redraws of everything
	e.g. if it's inside a grid's cell, blinking every 100ms, that's 10fps grid redraw and quite some CPU load
perhaps I could use base's panel to put popups/caret there instead of parent's pane?
	that would further limit the clipping region for popups, but for caret it should work, but only if it won't steal focus	
maybe a text-length? func that will measure size of any space's text as if it was not wrapped?
	aesthetically optimal paragraph size estimation may use sqrt of that for it's width	
use 'look to optimize list invalidation as well (maybe box too? any other space?) (grid is optimized)	
need to document sizing policy of all spaces (but it's not finally set in stone yet)
incorporate focus-space into set-focus
markdown viewer high-level widget with cross-paragraph selection capability and copying to clipboard


key aspects: draggable columns, rearrange by styles

QUIRKS

`into` allows to twist coordinates in any way, e.g. meaningfully react to clicks on a rotated/flipped face
	it's also simpler than hittest, so only carries the space's own logic, without duplicating generics
`map` and `into-map`, as well as caching of coordinates in `map`:
	- avoids duplication of the most widely used logic in each space
	- makes hittesting faster because of the cached offsets/sizes
	however `map` shouldn't be relied upon! `into` is the proper way to translate coordinates
	(e.g. think of non-rectangular or rotated areas)
`map` can't be of type `map!` because it should be ordered (e.g. for tab navigation) (can be a hash though!)
map names don't have to be unique (e.g. list may have 1000s of `item`s), just traversable
	but each of it's names has to lead to a unique object
	(unique names help working with each map item though, using path notation)
map/space/size <> space/size -- 1st is in parent CS, 2nd is in child CS (and may also be rotated/translated/...)
name (in a map) is not an identifier (unique) of a space, it's the class! e.g. `hscroll` is a class of horizontal scrollbars
	(however since name is bound to an object it's also an identifier under the hood)
content is a word!
	we want 'content' to appear in styles (and consequently in 'path') so we can process events for 'content'
	but we also want the space it refers to to appear in styles, for that style must process it's own events
	e.g. table inside scrollable - both scrollable/content and table are focusable and handle keys differently
	it's a bit of a special case though.. but it guarantees that inner item name won't clash in map with other names
	(in other words, we can't just put style name into map)
	however, can we maybe just define the events block for each space?
	at least we won't have to look for it..
	but if we do, we'll have to wrap generic spaces and replace events inside
	no... content+name looks cleaner to me
word/object dilemma
	though I've chosen to only have words inside spaces bodies, I'm not 100% convinced yet, not even 70%
	we need names for styling, we don't want dumps of all objects in a space tree (even though as a tree it has no cycles)
	but it creates an obstacle on the high level:
	instead of writing `space/thing/x: 1` we have to write `thing: get space/thing thing/x: 1`
	so far I haven't found a good workaround
	for debugging, I wrote a helper that rewrites paths, but in real time code this is not an option
	`with get space/thing [x: 1]` is the next option, but still not high-level
	I'm still keeping *some* objects, e.g. parts of scroller in itself, but that's it
	so another option to work with `list/items/1` and `space/content`-like paths is to use objects
	but keep the name somewhere as well, and hack `??` and `probe`,
	making them not dive into objects, or not dive into spaces & faces
	still doesn't look like overall win, but maybe I'm missing something
since no space knows it's parent, same space can be used multiple times in the tree
scrollable-space supports `draw/only xy1 xy2` for it's content - to minimize rendering effort by preemptive clipping
lot of parts in space become valid only after it's drawn (couldn't be any other way), e.g. it's map
style! could easily have been a kind of space! that wraps any other space, but it shouldn't be as:
	- that would mix functionality with styling
	- will be harder to change styling
	- styles will appear in the path
	or not??? ok bigger problem:
	- will have to sync style size with content size all the time
	  (can't be done from inside content, so how else? manually? or we resize style that resizes content? stupid..)
there are 2 ways styling can be applied:
	1) each space applies it's own name
	2) parent space applies names from it's own map
	2 has a drawback: e.g. scrollable-space doesn't know the type of it's content, so generic style applies
	then if we put thing into scrollable-space this thing loses it's style, and this is shitty
	but 2 has a benefit too: we can change inner parts without worry, styles will still apply
	e.g. think of scrollbar's thumb - it's a rectangle under the hood but we wanna style it as thumb
	solution? allowing a `style: 'name` field for spaces, which would override `content` generic name
	dumb? or will work?
funny thing about paths: example - we have 3 list-views on a window (a, b and c)
	- from styling POV they should all be called `list-view`
	- from focusing POV they should be `a`, `b` and `c` (i.e. unique)
	  this distinction applies only to faces, not anything inside (yes? maps provide enough uniqueness?)
	  also `root` should be parent to them all
	  ps. solved: faces can carry the name of their type but they're unique objects
	  however, styling faces differently will require some understanding
why keyboard/focus has to be a *deep* path containing focused face along with *all* of its parents:
	tabbed navigation can be done in 2 ways:
	- geometrically by finding nearest item along the path (but this is so called spatial navigation)
	- by finding next/prev node in the space tree
	  but this requires us to be able to transcend limits of one container and traverse all that is shown
	  (even other faces, so we need a parent that holds all space-hostin faces)
	it doesn't have to bother with names though (like content vs list, etc)
	as we're using it to navigate the tree only, so as long as each item leads to an object it's good
	(it could be just an object but then we won't be able to mold this path, easily)
focus is not selection:
	multiple lists can be shown with a selection (maybe multiple) but only one list has a focused item
	so to minimize code duplication and simplify styles we need `focused?` and `selected?` flags in styles
	`selected?` will be a property of `list`, while `focused?` is a global flag (func or logic)
what is root?
	for tabbing, we need to be able to focus both faces and spaces
		so naturally screen is the root for windows, then faces, then spaces
		so keyboard/focus should begin with a screen object
		(need to wrap those objects into words as [screen window face only then spaces] for mold friendliness)
		for styling however, we don't need screens or faces, `root` may refer to the (any) host face
		or should we assign a name to each host face and root will be parent to them all?
		it depends if we wish to style each host differently? no reason so far..
		besides, when one needs it, one just creates a container space with a `style: name` and addresses as root/name/...
		@@ rename root to host? or to face? for clarity
		@@ describe in docs how to style each host face differently
		for hittesting we want coordinates obviously, but what names?
		hittest has to be forceable (repeatable) so wee choose names from maps
		but root? screen? for compatibility with focus? probably no other point, could just start with the host
		[host space space ...] + coordinates (besides we can't translate into screen coordinates w/o R/S, and it's unneeded work)
	do we want tabbing across different windows of the same app?
		I think we do
		that means `keyboard/focusable` has to start with screen or list of screens
	do we wanna tab and scroll to hidden items?
		I think not
		e.g. scrollable [ 
			edit-box
			..1M edit boxes..
		]
		if we (on Tab) show next edit box that's 1M of them to traverse to get out of the `content`
		one will sooner die than finish this quest
		if we just allow skipping to the scrollbar however,
		one can just scroll one page down and tab back into edit boxes and this just works
		partially clipped edit box is still a corner case: we may wanna show it fully
		also, we certainly don't wanna tab to hidden panes of a tab-panel
pros and cons of each styles layout:
	item/subitem another/subitem [style..]       -- currently chosen
	 - have to be traversed once for each item in the path (which is 5+ items long)
	   because absense of 'subitem' in table doesn't guarantee absense of 'item/subitem'
	 + allows style grouping
	 + faster than other styles despite the extra work done
	upper item subitem [style..]
	 - requires another inner loop to ensure that when we look for `item` we don't also find `item subitem`
	 - styles can't be grouped
	 + no confusion on words vs paths, no `to path` or `as path` conversion needed
	 + finding `subitem` automatically finds `item subitem` and upper layers, but still slow (2-5 times)
	   parse can be used but it's even slower still (4-10 times),
	   and parse requires escaping each word in path (as lit-word)
event handlers are separated from space objects for:
	- memory efficiency: one event handler can serve multiple spaces
	- cognitive convenience: separation of code from data and structure from behavior
	- ?unsure? ease of extension: one handler can easily pass data into another (e.g. one that's overridden)
events are passed to the topmost layer that can handle them
	because upper layers have the whole context of how they are using their inner spaces, but not vice versa
	and lower layers may be used with or without upper layers, so they can not produce to the point results
	(at best they can just provide some better abstraction over event data, but most likely it's just dead code)
trickiness of keyboard focus and tabbing:
	e.g. we have layout: scrollable-space [content = list [edit-box ...] hscroll vscroll]
	we want:
	- h/v scrolls to handle keys separately (up=left, down=right, meaning defined by each scroll bar)
	- whole space to react to keys (page down/up, up<>left, down<>right)
	- spaces inside the list can be focused too, e.g. edit-box would handle keys on it's own
	so, focusable face can be a parent to another focusable face
	and we need to consider that during tree traversal,
	and also when assigning the focus - last space in the path is the one focused
	also: for 'content' to be focusable it is imperative that `focus` uses proper style names
there is not space geometry before it's drawn, no size no nothing, because what isn't drawn isn't existing
	and it makes sense, as we want animations and space may be moving in a complex way
	each frame of such move determines different geometry and reacts to events (like clicks) differently
following REP#80, event handlers return values do not control event flow,
	but their bodies are bound to commands that do
iteration over spaces
	there are 2 directions:
	- top-down from the root to the leaves, or bottom-up
	- forward from one leaf to adjacent leaf, or backward
	for tabbing to work properly we want fully reversable order
	i.e. if tab iteration is top-down forward, then shift-tab is bottom-up backward
	for this, listing a tree seems like much easier approach than recursively visiting nodes
unsolved problems of `content: 'name` design:
	to get content/size: `cspace: get content  cspace/size` is a bit complicated
	name changes in the map itself, which may theoretically lead to name collision (and I'm using path access)
reasons not to define `style: ... events: ...` in every space:
	want styles to be an isolated layer, so who defines styles does not have to poke around objects
	want styles names to be composite, like `this-space/that-space`,
		which is harder to map onto objects (and way harder to track after)
	objects can be numerous (= numerous links), while style is defined only once, so it saves some RAM
we need to use fonts in styles, as well as any other thing that may affect space's `size`
	including setting size directly from the style..
	this is all fine when styles are shallow, but what about deep ones?
	we have to somehow apply the tree of styles before `size` is called
	tricky thing: what if size is random or depends on time?
	then whatever we do, `size` and `draw` will not align
	unless we make `size` only available after `draw`... until the next `draw`...
why event handlers should be referred to by paths:
	example:
		item/subitem has handler: sub-item/on-event: [..if path/-1 = 'item .. [do smth]]
	this handler can't be copied into a new style,
	because `path/-1 = 'item` will not produce anything good
	if we however copy the whole tree of handlers, `path/-1 = 'item` is not needed at all
	and we become able to copy handlers together with the space tree
	as such we probably should allow simpler, literal, copying of events:
		events/handlers/item/subitem: 'item2/subitem2
handlers extensibility
	we will want some handlers to control visual behavior and be embedded into the lib
	while other handlers will be written by the user and follow user's logic
	how do we allow both to coexist?
	and how to simplify the extension of one style by another?
	actors should be lists?
	if so, what defined first should fire first
	but how to override? do we want to override?
	there may be levels, like lib-level and user-level, both with multiple handlers..
dynamic size vs draw/only
	it makes little sense to redraw possibly infinite number of invisible items of a list
	however if their sizes change, we can't know until we draw them
	so what to do? obviously we can't draw all the items (performance-wise)
	so it should be advised to re-render those items which size changes, before showing the list
	(TODO: document this limitation)
pinning
	list-view should support some pinned items
	but list is who renders those
	yet list is refilled with items from some offset, not from the head
	so is this even worth it to make list and list-view logic so complicated?
	vs just creating 2 lists, one pinned, one normal?
	scrollbar will be different: will span either the whole height or only of normal items
	2nd option is preferred: more natural
table structure
	2 grids with pinned rows?
	4 grids?
	we want pinned columns to have pinned headers and scrollable
	we want scrolling to be synced vertically, and horizontal scrolling only for the unpinned columns
	how to sync col/row widths?
table column order
	we can rearrange columns by dragging the UI
	and we don't rearrange the data, nor we should expect user-defined data pickers to all support ordering
	we rearrange the visual representation only
	so we should have an order defined in the UI itself: e.g. [2 6 1 5 4 3] (indexes may or may not exist)
	order will act as a simple filter too: what isn't present - isn't shown
	rearranging rows OTOH should be a change in the data, so should not be covered by UI... I think
headers - data or special value?
	I think table should provide a generic interface,
	and picker function should decide if row=1,2..etc is a header string or part of original data array
funny observation about table long/infinite in both directions (x and y):
	it will be impossible to infer row height, because we'll have to scan the whole (infinite) row every time
	without it, rows height will depend on what items are actually shown right now (i.e. where the scrolling window is)
	and rows height will jump around while scrolling left and right
	so such layout is only possible for fixed-size cells, or at least fixed-size row heights
hittest design shows that inner spaces should be named by their styles, not as generic `content`
	though that means that map has to hold those proper names as well, otherwise `hittest/force` isn't going to work
	proper style name is also required for `focusable` block
map: block or hash?
	list style has numerous `item`s which is bad for hash
	and lookups in a map should only be useful for small maps anyway
	so block wins
events chain: still undecided
	e.g.
		list-view
		list-view/hscroll
		          hscroll
		list-view/hscroll/thumb
		          hscroll/thumb
		                  thumb
	if list-view/hscroll takes event, and calls `pass`, should `hscroll` also receive it or only `thumb` variants?
	I think it should, because if specific handler didn't eat the event, generic one still can
logarithmic scroller
	problem of infinite space is that to know it's size we need to render it fully at least once
	otherwise scrollbars won't know how big the current viewport is within the whole
	but since it's infinite, we can't render it
	this is solved by list-view which makes itself a finite view on an infinite space
	and list-view's scrollbar doesn't map to infinity because of that
	but can scrollbar map to infinity? is this possible?
window inside scrollable: how generic it has to be
	one of the applications (apart from chatlog & table) is plot f(t), e.g. timeline of some exchange rate
	it can be huge and instead of rendering it fully (and making scrollbar uselessly imprecise)
	it makes sense to render only a window
	it remains to be seen how to make the plot interactive though
how to contain infinite-scrollable within content limits?
	ideally should be animated: e.g. scroll up, show some empty space, then realign during 0.5sec
	suggestion: let window have some empty space, but scrollable will contain itself using some replaceable algorithm
	however, then scrollbars will not look like they're at the head..
	`available? <direction> <max-lookup>` query func before offsetting?
	then window stays within available limits, but scrollable can optionally scroll itself out then animate
in grid layout, should row/columns sizes be a map or a vector?
	map makes sense because human can only configure a limited set of sizes manually (and prefers it to be less)
	so if one resizes 100000-th row only, map is tiny
	OTOH, if we want fast access to any i-th size, map is a hash lookup, while vector is a direct access
	benchmarks to the rescue: vector access is 90ns, map - 110ns (map miss is 90ns), so given map's other benefits, it wins
	in the future when we have native `sum`, vectors may still win when we want to get continuous sum of sizes
is it possible to auto infer row height in grid mode?
	clearly this case is a problem:
		|  |  |  |  |
		|  |  |  |  |       <- what height is this row? (if all it's cells have vertical span)
		|__|  |  |  |
		|  |__|  |__|
		|  |  |__|  |       <- this row is bound by one cell's span ending at it
	the idea for the 1st is to either:
	- make such row 1/N if it's 1st cell span is MxN
	- use smallest span cell instead of 1st (but why?)
	so, inspecting row cells from left to right:
	- if a cell has Nx1 span - skip next N-1 cells, and add it's height to constraints list
	- if a cell has NxM span, but doesn't end vertically after this row - ignore it, and skip N-1 cells
	- if it does end vertically on this row - subtract all previous rows from it's height and add result to constraints
	- if constraint list is empty, use 1/R of the 1st cell, where R - cell vspan minus rows above
	  (not sure, 1st or the closest rowspan below..)
	  still an issue: can lead to 0-height rows if below cells are empty (content ended)
	- so instead of 1/R it would be better to have a min-height constraint (and simpler)
another problem with span
	how to know which cell occupies XxY row/col?
	have to traverse the whole span map to ensure no other cell above has span big enough to include this cell
	so spanned cells should have span=0x0 if they belong to other cells above or to the left
	or better if they have a link to the starting coordinate
	idea: use negative span to point to the beginning of the multi-cell
	it aligns with the rule that any cell can only be occupied by a single multi-cell
	and then we can occupy & deoccupy it using some helper functions
yet one more gotcha about height cache
	calling `draw/only xy1 xy2` it makes sense to leave rows out of the viewport cached
	that is - to only calculate the size of rows we're actually about to show
	yet, to locate on which row xy1 point maps, we have to use the cached height of that row (and all those before it)
	we could invalidate caches of visible rows in advance if we knew what their numbers are, but we don't
	so the only reasonable solution (not considering full cache invalidation) is..
	to not invalidate the cache at all and let data modifying functions take care of it
	this means that if styles affect the size of the cell on each render,
	it won't be reflected unless those styles also clear the cache
	(such inertia is still a lesser evil than the absence of caching)
	render cache OTOH should be always invalidated as cells are likely going to be animated
how big is the grid layout? is it infinite?
	it'll be easy to limit it with integers
	but is it possible to infer the size from `cells`?
	if it's like 10 items long - easily, if it's 100k - a problem
	should show a warning in this case
	another issue: if it's infinite, how to `draw` it?
	ok so it HAS to be finite, and limit can't be none (but can be auto)
	then inf-scrollable can make it infinite.. but...
	in case row height is 'auto - it may resize itself while scrolling
should grid space contain origin and implement pinned row/col logic?
	normally I would let origin be handled by scrollable
	however, scrollable cannot pin cells without rewrite of the draw func
	so it seems more work.. although we'll see
layout of styles
	1. style: [prefix draw commands] closure: [postfix draw commands]
	this is limited! example: space created during draw of it's parent (one-off space)
	if style gets called before `draw` - it cannot know it's size because it's not rendered
	if it gets called after - then it can't influence draw (set font, rearrange stuff, etc)
	oops... but then it's 2 renders: one to get the size, another to let style influence it
	and then there's a discrepancy: style may have influenced the size, so it wasn't valid on the 1st call
	2. new idea - object:
	style: [
		init: [prefix draw commands]
		done: [postfix draw commands]
		render: function [] [compose [(init) (draw) (done)]]	;-- full pipeline that controls the order of style application
		font: ...
		other words to set in the space
	]
	with an alternative form - single block: style: [[prefix draw commands]] (as it's the most useful)
	an object will be created out of it, space set to it, then ??
	what about `self`? it should be bound to the space, not style
	has a problem! while bind body-of style binds blocks, it can't bind the function!
	if we make function a block - it will leak words...
	recreating an object with functions - too heavy, not acceptable
	3. collect words of style, set them to words of space, then bind is not needed
	but then if we call `draw` for example, draw drags some words from the space
	and bigger problem: some words are global but will be overridden..
	won't work
	4. let style contain only blocks, but compose them in the order they were defined
	then we have binding, ordering, and it's not heavy
	drawback is that styles will have no defaults, and will have to define everything they are using
	another: dynamic assignments are ugly: `before: [(font: ... ())]`
	instead of just `font: ...`
	@@ perhaps paren should be reserved for this.. e.g. `font: (...)`
	but then it requires custom constructor, not just `object`, and thus limits styles in it's own way
	why not just single styling function? it will be given space as an argument
	access to draw - check, custom eval order - check, minimum allocations - check, simplicity - check
	win!
grid cell background - how to draw?
	1) draw grid background => each cell background => each cell contents
	problem: when row height = auto, we don't know the cell/row size in advance
	so we need to render the cell first, but we can't draw it's background not knowing the size of it
	catch 22
	2) draw grid background => each cell contents => draw grid lines
	this way when drawing grid lines we already know the size of each row, so it's ok
	and actually less drawing commands.. M + N rather than M * N
	drawback(?): cells without content look like cells with empty spaces, no distinction
	huge drawback: grid lines will be drawn atop the multi-cell content - inacceptable
	3) so, we need to render cell content first, then estimate row size, then render cell itself
	how? grid lines are a way to hell here..
	maybe.. we cache the cell contents drawn cmds, to eliminate double render
	then: grid bgnd => each cell content => each cell bgnd => each cell content (cached, box sized, alignment applied)
focus has to consider sameness of each path item
	e.g. grid/cell -> other grid/cell look the same but differ in pointed to objects
grid/cell/space vs grid/space - which is better?
	initially cell style was introduced to draw cell background and see it's bounds
	but cells are volatile, and it's better to include them into map
	but do we always want that?
	grid may be used to position other spaces on the layout, not just data, and in that case no need to draw cell boxes
	* cells may help with alignment - global sizing system will work out of the box
	  without cells I would have to do alignment in the grid code, which is bad
	* one of the questions - if the grid is huge, do we want `cell` space for every empty cell?
	  although, most likely if the grid is huge - we either have the data, or *want* to draw cells (like spreadsheet does)
	  will have to ensure only visible cells are in the map - but this may still be a lot, to cover whole `window` of scrolling
	* cells may help with interactivity - in case one wants provide events for cells even if they have no data
	* maybe I could make an option controlling whether to wrap into cells or not..
data & cell wrappers: wrap-data & wrap-space
	are incompatible with the focus model that expects focusable spaces to remain the `same?`
	we can spawn spaces on the fly only if we cache and reuse them for the same visual UI element
	that applies to list items and grid cells
	so cache is the only solution, but it may become huge
	although to keep it small - we could destroy items that were hidden by scrolling
	scrolling out of the sliding window or out of the view?
	defocusing items on scroll is bad UX, so the answer is out of the window
	;@@ TODO: update list-view with window-local cache
	so there's a cached space per each cell - should it be removed when span changes?
	if cell gets eaten by a multicell it automatically disappears from view, so doesn't matter there
	if cell becomes a multicell, it may retain focus, why not
	so no need to destroy cells, but only mark them for full redraw (if that is required)
grid cells array models
	1) cells = map
		supports limits=auto:
		possible to just add cells into the map and limits are inferred
		when mapping data into grid, cells must be filled with a space for each data point
		(if data is truly infinite, will be impossible to fill it)
	2) cells = picker func [/pick xy /size] (that picks from a map by default)
		/size has to infer it from the map itself
		possible to pick from an infinite data array
		no need to pre-fill cells spaces, can be done as they are rendered (but should be cached)
		works for truly infinite data - best argument in favor of it
tricks of grid containing itself in each cell
	draw-ctx and ccache can (and should) be shared between inner and outer renders
	and should only be invalidated before the outermost render
	no static lists should be used in draw
list-view's list width - how to infer it?
	let it be locked to list-view's width?
	there's no width for an infinite list
	and adjusting width to a range of visible items is not great UX-wise
	(scrollbars will show and hide while scrolling)
	but it needs more thought.. esp. when I decide on sizing system
	maybe this will help autosize items' content
on resizing
	some spaces' dimensions are fully automatic - list, data-view (unless limited), image (in auto mode)
	some have only one dimension automatic - tube, paragraph (unless width = none), grid, list with fixed width
	some have only fixed dimensions - all scrollables, image (in fixed mode)
	let's call all these fixed dimensions "free dimensions"
	free as in "no inner constraints imposed" and "can be modified freely at any time"
	automatic are the constrained dimensions out of user's control
	ways to deal with free dimensions:
	1 use plain reactivity (very boring and clumsy way)
	2 define more high-level relations in terms of filling space and aligning in it
	  (also if defined as a function of time they become animations)
	3 use containers that will align/fill themselves with the inner space
	  this is less flexible than pure relations, as only limited to parent/child sizing
	  also floods the space tree with unnecessary entities (=> noise and slowdown)
	so best option seems to build a DSL on top of reactivity (2)
	OTOH some might expect predefined containers (3), esp. interactive ones,
	  e.g. splitters (2-4 panels divided by a draggable delimiter)
	  ? grid columns (draggable slim inter-column patch, inter-row too)
	    key here is that columns are not objects, their widths is part of a map (which is not reactive at all)
	    can be solved by using hash instead, but dealing with /skip is a headache (`map: map` is a lesser evil)
	  columns that fill available space (splitting it using weights) - not interactive, but can be (changing weights)
	what's also useful is expressing sizes in relative terms: window as part of the screen, widgets as part of the window
	and another thing to consider is how to export all this so it'll work on faces too
	  maybe a DSL that creates reactive relations from a description?
	1 more consideration: such free sizes may appear and disappear on the fly, e.g. alignment within visible cells
	  though that can be left to grid itself
	on-resize can be useful to adapt the layout to size, or when rotated
	  some use case: https://egghead.io/lessons/angularjs-angular-material-adaptive-layouts
	  basically, things to show and things to hide (instead of just resizing)
	  though it can be done simpler, by injecting a set of conditions into draw - to select which items to show
	DSL sketch:
	constrain [
		a/size/x -> b/size/x -> c/size/x
		a/size/x <-> a/size/y
	]
	creates 4 separate reactive relations:
		b/size/x: a/size/x
		c/size/x: b/size/x
		a/size/x: a/size/y
		a/size/y: a/size/x
	ideally, but in reality this won't trigger reactivity, so it should change `size:` every time
	constrain [
		split a [10% 100 20% *]		-- can be applied to lists, `*` = rest, `none` may mean "don't touch"
	]
	but this thing can be just added into list itself
	although then list will have a fixed size, so let's call it fixed-list or smth, maybe chain or stack or spring..
	question is, what to do with opposite direction? fill or leave?
	presumably, cases with split should all fill it
	gonna need to make a few UIs first, then try to apply this model to them
so next sizing steps, and considering "free dimensions" idea
	list dimensions that require sizing:
	  - list inside list-view: list width (or height) adjusts to that of list-view (is locked to it)
		or vice versa? one changes list size, list-view adapts? unlikely, since list-view size is fully free
		list itself doesn't change it's free size
		scroller problem: either we leave it's space free even when there's no scroller
		or list width gets reduced when scroller appears, stretching list even more
		these 2 strategies can be chosen by the user, preferably 1st one being the default
	  - grid inside grid-view: this has a lot of options
	    when grid-view size changes, 
	    we could stretch each column or only those configured as stretchable (split example above)
	    or we could default to static size, with the ability to easily define stretch mechanics on top of it
	    grid-view itself should not adapt to grid
	    same scroller problem exists here too, same solutions apply
	list dimensions that can be sized (by the user):
	  - lists in complex layouts, e.g. web ui (take gitter as example, though it's fully static)
	    it can be a grid with unified cells, and an ability to drag some columns/rows sizes
	    or it can be a grid of grids, more complex but may make sense if resulting tree is easier to work with
	    each grid cell then is a list-view and these adapt to cell size, forcing lists to adapt too
	    what's important is to define some kind of aliases to cells here
	    e.g. chatlog will be cell N, convo-list will be cell M, issues-list will be cell P, etc.
	    but that's not an issue, since each cell is a space, it works out of the box
	    (in fact grid can be composed with already named spaces)
	  - visual fx and animations where things get smaller and bigger but have anchors and func of time
	containers of other spaces:
	- grid cell is the most important one - for layouts esp (this includes splitters)
	- list cell is the next one, and list of lists (TODO: automatic switch of layout direction in this case h/v/h/..)
	  however list cell has only zero to one free dimension (depending on width), so it's limited in it's size propagation 
	- data-view usually adapts to it's content, like list
	we want the logic of all this unified by a single shared mechanism
	mechanism should allow fine control: each facet is a formula of other things
	most used forms of it have names and are leveraged everywhere, exposed into VID
biggest sizing question: how does grid cell size affect it's embedded space size?
	grid may deal with generative data, or it may contain named spaces, so there's dangerous duality
	it makes little sense to NOT adjust grid's cell space size to cell size?
	in that case size adjustment may be done by wrap-space itself on in the render func
	or, what is the use case for not adjusting the size? is it ever useful? and in that case, can it easily be switched off?
	types of content in lists:
		text line - e.g. for file view, whole space width is adapted to max line width 
		text paragraph - typical for chats and books, paragraph width is adapted to list width
		 (in chats though paragraph will be wrapped into a custom space with buttons and status and time)
		 (and that custom space will adapt to list width)
		image - usually before or after text, sometimes standalone, lists of icons (e.g. toolbar/appmenu, icons=buttons)
		 in this case we may want control whether each image adjusts to list or not, use-case dependent
		button/dropdown - tricky, we don't want a huge button but may want small button centered in big area
		 so it makes sense to either use a centering container or hardcode alignment logic into lists/gridcells
		 if it's a centering container, container adjusts to list width, but it's height is determined
		 lists of buttons are very common, esp. lists of image-buttons, likely of fixed size and list should adjust
		editbox - more likely we want to adjust it to list width or cell size
		check/radioboxes - will be adjusted
		sliders/progressbars - also
		 I guess there's value in a list that has no width and includes a few different spaces
		 but.. then one will have to either set each space's width manually, or use defaults
		 also, in any case heights should either be default or set manually
		 perhaps we need a common size constraint system, and make sure everything adheres to it
		orthogonal sublist - width is autosized anyway, height may or may not be automatic
		 again, we should both be able to set width from sublist length, or have it fixed
		 although it's more likely that sublist will be a list-view (with fixed dimensions)
	lists can be of two main forms:
		- list that is within list-view, of minimal size, extends indefinitely, shows scrollers if needed
		- elastic list that expands to layout size (or to own constraints), may stretch inner items (`band`? `row`?)
		  if text is wider, it is ellipsized - same as in cells! (see MD lists)
		  this list also may split itself into a few columns / rows
	need to write down how I want e.g. gitters layout be expressed (top-down), then figure out how to do this
	need to write some layouts of some websites and polish the declaration
		GH is a great example: https://s7.gifyu.com/images/GIF-13-Mar-22-17-33-21.gif
		great in that it does so many things and does them so pathetically that a comparison is a must have
		it also highlights the importance of `stretch` item in a list of fixed length, which controls alignment
		(means that we need to extend list to support fixed length, likely fixed by outside layout)
		and that each element may react to layout size, e.g. "Pulls"/"Pull requests"
		funny how tables react to resize: they rebalance, but do not keep the currently visible row
		browser resize is a funny stress test for most sites btw
		https://easings.net/ is interesting: it has 1-2 columns, consisting of 3 icons arranged in 1-2 rows
	"protip" line is most interesting: it contains markdown
		<code> of markdown is not part of paragraph, at best it's part of tube layout
		OTOH, tube cannot tell it's items to wrap, and we need to wrap text, so rich-paragraph is going to be quite a quest
	MD "chips" are also interesting in that they're part of an edit field's text by the look of it (needs rich content) 
	TODO: ask community for site or UI examples that are challenging to consider how spaces may approach these
	great flutter video: https://www.youtube.com/watch?v=kmZz_q7W2jI
possible size to constraint adaptation strategies
	e.g. for cells of a table, when contents does not fit in:
		any text: none / clip / ellipsize / downscale (but not infinitely)
			none is important as it enforces a minimum size of the item, not letting the container itself to shrink
		button/dropdown/check/radio: adapts it's own size, lets the text decide how it adapts
		editbox: adapts own size, for text probably nothing?
		progress bars: scale/stretch easily
		image: clip / downscale
		list: adapts own size, content decides for itself
		row/tube: tricky! inspects constraints of inner items, weights, may contract them
		grid: should not be affected, not automatically at least
		grid-view/list-view: do nothing, but constraints may be used by row to resize them
	but this applies to any other container
	upper constraint bigger than the contents is only useful for containers/editbox/etc
		ie anything that is arbitrarily scalable and/or allows varying content
		no upscaling is done in any case
	if we use tube as row, and to the 3 alignments: back/forth/center, we add fill
	then we have 2 weights:
		weight in a row - divided between all items
		weight in a cell - either expand or not
			alignment is set for a row, but we want to control this per item
			so the value of this is either 0 (don't expand) or non-zero (expand),
			which makes no sense to use a number for, but pair is still the best candidate
		default weight: 0x0 - fixed
		numeric weight: N = Nx0 - stretch along main axis
		pair weight: Nx1 - stretch and fill
		or, do we need weight for this?
	having sec axis constraints should be enough for deciding whether to fill or not!
	weight should not affect the secondary axis at all!
	is there a point in 'fill' alignment then?
		if constraint allows up to 80px, but row is 100px, we have to align the content, so alignment must be set
		then we either expand by default to 80, or don't
		expanding makes sense, because it's turned of by constraint, but if we don't expand, there's no switch to enable it
		similarly, row can be full, but it's extent is bigger than max constraints, so alignment should still be set
		so we must expand the content of each item too when possible
		'width' parameter should be replaced by 2D constraints set
		constraints is a long word, variants: bounds, limits, confines
		can we rename grid/limits?
		for grid it is the max number of cells in both directions, I'd rather use bounds/confines there
	this is still a mess... and what about `draw/on size`?
		image: only changes `size` if it's `none`, or if constaints require it, aims at `image/size` ?
		paragraph: size can be `none` or `size/x` may determine width
			`size/y` will be freely set or not?
			in a cell it should not extend itself, better to clip
			OTOH, if it's bigger it can be scaled down by the grid
			also grid wants it to draw itself down so it can be measured
			in a list we also want it maximized
			we don't want to reset size/y to 99999 before every render to make maximize text
			and we esp. don't want that after on-change
			so draw/on will be a much cleaner and predictable way to tell the size of the canvas
			also we should be able to automate constraining of draw/on argument, somehow
			also since some draws call other draws, this constraining should be done by the caller
			otherwise we end up with a series of constraining calls only first of which is useful
			maybe render/on will do the clipping?
on ranges: perhaps, instead of fixed 100 .. 200 or smth like that (which is shooting blindly)
	we should by default let the minimum e.g. for any text to be the size of that text ?
	OTOH do we ever want to stretch text labels? unlikely
	ranges are for stretches, fields, areas
on ranges and constraints:
	what should be the `canvas` to obtain the minimum space's size? none or limits/min? and if limits/min = none, 0x0?
	specifying canvas as 0x0 is bad idea, 0x0 should only be used internally in `constain` if no lower limit
	on the other hand, none is "infinite" canvas, so it does not really align with the minimum size idea
	it works because if canvas is infinite, there's no point in trying to fill it, so the minimum is taken
	so what about:
	- no limits/min => canvas=none as usual => min size
	- pair limits/min => canvas=limits/min => real size may be bigger or smaller depending on how space adjusts
	  (cell is never smaller, paragraph can be smaller vertically, list can be bigger horizontally and smaller/bigger vertically)
	- integer limits/min => canvas is half-unlimited => adjusts width only (of dubious use... - should it be supported?)
	problem with this is that `none` is different from any canvas in that it doesn't `fill` the space whatever it is
	e.g. paragraph with no min. size => one line, with min. size => will now fit into that min size, which is undesired
	so another idea: min. size is always obtained with `canvas=none` but further once canvas is specified, render constrains it
	in this case constrained canvas can easily be smaller than the size with `none`
	e.g. paragraph will lay itself out in one line with `none`, but will adjust to the width if given
	so, render should not constrain `none` canvas, only pair canvas
	so, tube will unroll any paragraphs into lines, even if they are wrapped into cells, which is also bad
	what if I assume tube only contains cells ever, and then use min-size ?
	list: on `none` will unroll paragraphs then fill it's own width, with `min-size` - will fit paragraphs
	biggest issue is: if no limits/min but have limits/max - unrolled text may be bigger than /max on 1st render
	I can't use 0x0 canvas here, nor it makes sense to use /max to obtain min size
	what in this case should be used? and tube behaves exactly like paragraph... except `none` may be forbidden for it
	this needs more thought...
	maybe really use 0x0 or 1x1? for text this will work for horizontal tubes only, vertical should use `none`
	if text is in vertical tube, it's "min" size will be that written in one line, or limits/max if it's defined
	which will lead to very wide tube
	there can also be different layout intents for text: lay out in one line, or make it as square as possible
	in other words, placing tube inside a tube is a bad idea overall, unless both of it's limits are defined
	also, rendering on `none` when limits/min is defined may make space bigger than /max, so canvas should be limited if possible
	also, /max may not be honored by text: with 1x1, size-text will still return full text size (single column)
	same with list: wide items that stick out of whatever /max is set, will make whole list wider than /max
	this means clipping will have to be done, even though not for every space
	okay for text 1x2e9 and 2e9x1 are most consistent/predictable "min" canvases, what of other spaces?
	btw, on VID side, /min can be `'fit` for text, esp. buttons, radio buttons etc. - meaning never clip the text
	because maybe we want to be able to clip button text? hmm that's unlikely - and possible using `cell`
	then button&co should always render their text in full even on 1x1 canvas
limits (ranges)
	to waste less RAM (each range is 468 bytes), a single range is used instead of two (X+Y)
	this limits us a little bit but not much:
	  no /limits defined in a space -- same as limits=none (any size is possible)
	  limits: 'fixed                                   -- size is locked and not to be touched ;@@ do I really support/use this??
	  limits: none                                     -- size is unconstrained (no limits, default)
	  limits: make range! [min: none  max: none]       -- ditto
	  limits: make range! [min: 0x0   max: none]       -- ditto
	  limits: make range! [min: 0x100 max: 999999x100] -- Y axis is fixed, X is practically unconstrained
	  limits: make range! [min: 50    max: 200]        -- main axis is constrained, secondary is not
	this allows to set each limit to a pair/number/none, where `none` means "fixed"
	but it's impossible to have e.g. min-x = none, but min-y = 100
	in this case zero (e.g. 0x100) should be used
	;@@ maybe a block will do? should not be any slower
on layout: with the introduction of spaces styles, it will blur the distinction between spaces and faces
	so compatibility has value in this context
	most likely I will need support of full set of VID commands and some superset will be spaces-only
drop-menus: how will they work, considering they place themselves above the other content when expanded (with occlusion)?
	idea is to have a popup layer, where a menu/tooltip is generated
	but such menu may produce additional menus/tooltips so it cannot be a single layer
	so we need to insert menu/tooltip into at the top of the stack (after all the other spaces)
		this choice will make tooltips reside fully within the drawing area (rich text)
		or possibly clipped by drawing area but scrollable to reveal the hidden parts (less useful)
	or we may create another host in case of menu/tooltip, and this host then can appear anywhere inside the screen
		drawback of this is overall bugginess of mouse event pipeline when new faces are spawned/shown
		also each menu and each tooltip will be a separate face, bloating the whole app
		and this face will have to be injected into the face tree, which is also not superb
		also transparency (for non-boxy tooltips) won't work on W7
		or better: it can be another window, but then this window should not be activated, 
			and parent window should stay active
			this will make possible to show tooltips outside of the window border, which is cool
			but in this case non-boxy tooltips become impossible as Red has no transparent windows
	ok new window is not an option, OS tooltips not supported, tried another face:
		view [base all-over on-over [tip/offset: event/offset + 15x15 tip/visible?: not event/away?] tip: base 60x20 hidden "Hello?"]
		view [button all-over on-over [tip/draw: either event/away? [[]][compose [fill-pen white box (pos: event/offset + 15x15) (pos + 60x20) text (pos) "Hello?"]]] at 0x0 tip: box 200x200]
		#1640 concludes tooltips as faces are possible
		a bit dangerous in that if it slows down, one can actually point at the tooltip,
		but this can be fixed by tooltip code
		since tooltip can only be single, it's just one reserved or spawned face, not resource hungry
		still clipped by the window, so alignment have to be calculated properly
		since the glass box way works, this opens possibilities for the menu as well
		but since menu may show submenus, it makes sense to adopt another strategy:
		fill whole window with a trasparent rich-text surface, use it to render all the spaces
		but #5104 shows that it's a problematic approach
		transparent layer is ruled out because it eats events on GTK at least
		(and I'm sure a lot of other bugs will surface with it)
		then spawning new faces on the fly (on the root window) is the best way so far
popup logic
	menus: have to appear under the pointer, so move away closes the window
	  one menu may open another menu and both should stay open until pointer leaves both
	  second layer menu may be replaced (hidden) by another second layer menu, and so on (any number of layers)
	  no need for hints on menus for now for simplicity
	  I do hate popup menus though, worst UX ever, maybe fuck them? so much trouble for me and users
	  main menu is supported natively, but it's shitty and naturally one may want to use a spaces-based one
	  and main menu is still widely used everywhere, no way around it..
	  ribbon? even worse, besides it's not a replacement but an addition to menu (maybe a replacement for toolbars)
	  menus are shown next to each other without gaps so mouse travel is possible across them
	radial menu: is an ok thing but has one level usually and stays only as long as LMB/RMB is down
	  also usually displayed around the pointer, even if gets clipped by the window, which makes it less useful around borders
	  but this is easy to fix
	  UX idea:
	    RMB to show menu until pointer leaves it's radius or another RMB or pick is made (by LMB)
	    LMB to show menu until LMB is up, then pick is made by LMB being up at it
	    this works fine for touchpad and touchscreen
	hints: should be away from the pointer so it doesn't obstruct the text
	  (and I never know the pointer's hotspot so better reserve ~16 px from both sides)
	  new hint always replaces old hint - no two hints are shown at the same time
	  trigger - delay for the first hint, but when one hint is visible next hint should be shown immediately on hover
	  then I need a way to check if other hint is visible or not, to decide the delay 
	so on the base level I want smth like show-popup: func [level layout] and a map of window->popup-face
	to allow hints on menus (esp radial menus) they have to have a special level, e.g. 0, while menus have level 1 and up
	- any level popup replaces popups of the same level
	- popups of level > 0 also hide popups of level above
	I need to:
	- determine if popup level 0 is visible (to adjust hint delay)
	- show popup of a certain level (to replace another popup of that level and hide upper levels)
	- get all visible popups of a certain level and above (to hide and replace popups)
	should hint display be automatic? having /hint inside any cell would show the hint on hover... makes sense
	hint showing logic:
	- timer must be used to display it
	- should hook to host's timer and over events:
	  - host itself because it should fire even when there's no space below the pointer
	  - over so on /away? it hides the hint
	  - timer so there can be a delay
	- hover over the hint itself must hide it, but only if the pointer moved, not if it was already upon the hint
	  should travel ~5px to be considered "moved" (not just ball vibration or sensor jitter)
	- I decided to add travel to hiding as well, otherwise even 1px distance between spaces requires another delay to show the next hint  
cells - idea how to simplify and unify alignment
	cell is a thin wrapper around single space
	cell includes alignment and it's size and alignment is set by the parent
	it then handles how to place it's content, when to cache or render it
	cell will be directly used in a grid and in tube
	on high level, vid styles will often declare a cell+content pair, with both alignment and content defined
	when canvas is not provided, cell should render in it's minimal size (required by tube and grid)
	cells are also needed by grid and maybe list-view to receive clicks on a cell (not on it's content)
	`stretch` becomes just an empty (content-less) `cell`
alignment - with cells and canvas, there's no need to `fill`
	but the question remains, what format to use?
	-1x-1 to 1x1 looks simplest option code-wise
	in vid, we'll use left/center/right/top/middle/bottom as usual
	but should we also use these high-level words in the space itself?
	it may be easier for the user to understand
	though it also may be much harder for him to work with (if he has to)
	e.g. it now has to be a block [center middle]
	separate options for handling X and Y (since words are different)
	also these words have to be often translated into numbers in computations
	question is, should cell also have margin? this would conflict with layout-provided margins
cells complicate tube:
	compare https://i.gyazo.com/3ebe22d96c8b5a6ae726bc3ffe3a63e7.png
	to https://i.gyazo.com/f89ea7c617a5da79dd703bab25579faa.png
	in a tube there's alignment: of every row, and of every item within row
	(2D alignment of rows within canvas should be dedicated to an external cell)
	if we use cells that stretch without restriction, all these alignments are no more:
	whole area is covered, every row is full, and every cell is expanded
	there's however still alignment of every item within it's cell (X/Y - 3x3 alignments)
	moreso, each cell's alignment can be differently configured by the user
	we could use tube's alignment to fill cells alignments, but this would override user's choice
	basically, tube's alignments still make sense for fixed items but become irrelevant once items stretch
idea behind layouts was to abstract geometry computations from container code and rendering
	also to be able to incrementally fill it, e.g. once we reach a certain size
	but this failed miserably because it's only applicable to lists,
	and lists are the only big enough layout where it makes sense
	circular list already breaks incrementality
	tube further complicates this by requiring two renders: first to get min. size, then to expand it's items
	we can still pre-render items without canvas, arrange them in tube layout, set sizes in the map
	and later render on sizes from the map, but this breaks the map idea a bit if rendered size is smaller
	and it certainly will break alignment in this case
	so rendering in the tube layout is a must, because we need to get the size
	or else, we can rely on cells to always occupy the allocated area fully
	for lists the point was to use old item size when possible, and not re-render hidden items, conserving resources
	for tubes, this point is lost - if tube is shown it's almost certainly shown in full or it doesn't matter
	so there appear to be different pipelines that each make sense in their context
	it's tempting then to move render into layout, let it have control
	but then it will have to know the viewport and maybe other gory details...
	an issue with list cache: if item in the viewport changes it's size during forced render,
	it's map geometry will be invalid as it was set for the old size
	this also can only be solved if layout does the rendering
	there must an option for list layout to disable the rendering (in case it's up to date)
	layout interface also changes: should just take a list & settings, spit out size & map
	the only critical feature for lists is to be able to render only selected (visible) items
	which is easy enough to do 
	another idea was that if layout renders, it discards the result, which is wasteful
	but this we can fix with a cache in every space (cache may be a map with key = canvas size)
TODO: for `area` space: it should be possible to do 2-3 renders to work around #5113 issues
	I don't see how this can be applied to a general list-view case though, without performance degradation
	maybe list-view can "learn" how it's content behaves and then apply this knowledge
	but it's no priority 
why drawn block should be copied:
	if I don't, the same style rendered twice in a tree will replace the first result with the second
	even if I had a static draw block per unique space, same unique space still may appear on different canvases
	so, caching is only possible in the sense "return previous result if nothing changed" (no static data involved)
	whether or not to centralize this mechanism I'm still thinking
	I'll need /cached facet to hold previous block and on-change clears it, as well as draw
	another facet will be required to hold canvas size
	alternately, global hash! can hold all that (key = space object),
	which is probably a good idea, because in the lack of apply, render wastes a lot of time
	this will also enable render to have more than one cache, but.. how to invalidate?
	/cache? = yes / /cache? = 'invalid ?
global caching is trickier than I thought 
	since a lot of spaces are composite - from `cell` & `scrollable` to `tube` to `grid-view` etc
	they cannot be directly cached as they never know if their `content` is changed
	so I have to check if all their inner spaces are unchanged, and if not - do a redraw
	so I either have to render all inner spaces (those in `map`) and check against cached code
	or to check if they all are in the cache and have /cache? = true (preferably, since render conditions are unknown)
	but this means to cache a composite space, all of it's inner spaces has to be cacheable as well
	and inner spaces of inner spaces too..
	a single uncacheable space inside a huge parent will nullify any caching attempt
	and of course this is happening, as I don't know what was drawn on canvas=none and what on a geom/size
	and I don't know even if space will look the same if rendered on none or geom/size (though reasonable assumption)
	extend cache with geom/size? then I can search by object and resulting size
	another issue is that I have paths in styles, and styles may differently paint the *same* space in different places
	so say I have a differently paragraph (same object, even same size) how can I cache it?
	the only way to ensure style uniqueness seems to be ensure path uniqueness
	but lookups by path are slow, so I need to lookup by object and then filter by path
	then if I have a path, do I still need xy1 xy2 canvas?
	canvas yes, because e.g. cell is drawn at least twice - on none then on fixed size, and results will differ
	as for scrollable, maybe xy1 xy2 are not that important? TODO: consider removing them
	crap.. `same-paths?` is 10x slower than all the renders, need some kind of render tree marking to not repeat it
	or arrange caches in a tree - should be much faster this way, but may still need marking
	any way to avoid deep tree visiting on render?
	space1 can contain space2 that contains space3 that is changed, and maybe even set cache? to 'invalid
	how does space1 know that without deep visiting?
	the only proper way to handle this is to have host render produce a tree
	then any invalidation will bubble up the tree invalidating all of it's parents
	then validity checking is simple and fast
	meaning that tree has to carry references from all spaces to parents
	but how each space will locate itself on that tree on invalidation?
	direct link to cache node will make spaces unmoldable
	just a path? invalidation will then have to traverse the whole path to find the node
	it's okay even if not ideal
	anonymous word referring to a cache node? that's 260 bytes more per space or ~2MB for 8k spaces (tube-test)
	maybe a path of words - reduced into a path of space objects - `get` natively?
	unfortunately `get` matches objects by content, not by pointer, and select/same is slower
	OTOH I have to invalidate it all up anyway, so I'm either going up from a cell, or down from root to cell
	so a path should be enough if I invalidate everything along it
	cache should then still contain space objects for quicker search (words are looked up by symbol)
	and be structured as a tree, containing rendering parameters, size and code for each node
	hmmm space cannot contain a path, since it may be at different tree nodes
	so how to invalidate it? it has to be invalidated on all nodes anyway
	idea: let cache still be flat, but each node will contain links to all it's last parents
	going to be unwieldy to keep it up to date, so let there be 2 caches:
	- cache of space object, render conditions and results
	- 2 tree caches for each host: one that is being built, another for validation lookups
	  and they're swapped on every host render
	  or one? I only need single validation lookup if it succeeds
	  but if it fails - it's subtree cannot be cleared as I wanna know what children are still valid
	on the bright side, no point in keeping render parameters except canvas (needed for double rendering) 
	no, damn, flat cache is ruled out because we have path styling
	TODO: hosts have to be roots of render-cache because styles may include host names
	but right now there's no support for that, all hosts appear as `host` in paths
	with this, cache? = 'invalid is not needed anymore, but a global `invalidate` function?
	tricky: if space appears multiple times in a tree, I cannot mark it as valid until it's rendered in all places
	thus /cache? = 'invalid is a bad strategy
	there's also these issues:
	- I save cache into new tree, but only look up in the old tree, thus re-rendering the same thing many times until tree is committed
	- I look it up in both trees, but then once I add render on one canvas to new tree, it's auto-validated for other canvases in old tree
	  which results in fetching the outdated look
	also after some thought, invalidation is a rare procudure and it can be slow
	only cache lookups should be optimized to the fullest
how to lay out rows? that is, should it be a block for data-view or row style or what?
	what's in the block? how to denote separators? should separator be a globally shared widget?
	e.g. image+heading+text+switch like on android?
	or label+hotkey+'>'marker like in menus?
	on a lower level this can be just a VID/S `row [image %img note "heading^/text" switch off]` or smth
	but can I leverage type richness to get rid of template declarations and fit row into a single template?
	easy: char!/file!/image! -> image, string! -> note, logic! -> switch, string! -> hotkey
	no need for separator, can just declare first string as weight=1, rest as weight=0, with possible overrides
	may still use issue for hotkeys, with the aim to automatically react to these hotkeys
	how does the row know it's has submenus? aha, menu layout does that
	also `>` stands in it's own column which hotkeys do not intersect, which makes it a bit too special
	how to generalize? hmm what about `pad` space which I assign the same size as `>` limits, so they align
	great!
	don't like the weight=1 for general row though, maybe lists will have a special kind of row?
	band? list-row? line? bar? strap? lane? band best hints at elasticity
	may ofc just use row and add a stretch space, may even call it `<->`, and let menu add it
	also menu may add `pad` or impose a limit on stretch, so hotkeys never get close to text
menu DSL:
	1st iteration:
	  menu: a block! [any menu-item]
	  menu-item: [layout opt hotkey action]
	  layout:    [string! | block!]
	  	string is interpreted simply as text,
	  	while block may include other data as accepted by data-view
	  hotkey:    [issue!] e.g. #Ctrl+O
	  action:    [code | menu] (block is a submenu in this case)
	  code:      [paren!]
	hotkey as issue is bad: e.g. `Ctrl+,` is not a word type
	but hotkey can be a string easily, why not? or tag.. let it be string for now until a better idea
	so 2nd iteration:
	  menu: a block! [opt flags any menu-item]
	  menu-item: [any content [code | submenu]]
	  content: [space | data]
	  data: [string! | char! | image!]	- | logic! ? for list rows/bands
	     question then can I use the same dialect for both menu and lists?
	     certainly, android rows are either submenus, toggles or actions (popups?)
	  space: [word!] - refers to an existing named space, e.g. <->
	  code: [paren!]
	  submenu: [ahead block! into menu]
	  flags: [ahead block! into [any flag]]
	  flag: ['radial] - the only supported flag for now
	  instead of text, menu/list will use `note` or.. how to name? message? record? all off
	  ah! label could support multiple lines out of the box!
	  `line` is a nice name for horizontal divisor, maybe `hline`, but only if `vline` makes sense, which I'm not sure
	  OTOH divisor doesn't have to be a line, it may be styled differently
	what other than string/char/image/logic (or word referring to these) can be data? (also a question for data-view)
	  block can be a sublist? but it makes little sense, unless it's somehow different from the outer list
	  besides, menus use blocks
	  url will need a special url style that is underlined and can be clicked (TODO)
	  other datatypes should be molded perhaps - as will be best for data-view
	  word should probably be formed too, and reduce used when needed - useful for data-view of arbitrary red content
	  data block is not a VID/S block - it doesn't support any space parameters or anything, just a plain list of stuff
	  data block should likely become a tube, not list, so it will go to the next line gracefully
is there a difference between tube and row? other than possibly applied style? row is only a VID style then
on radial menu UX
	click and drag UX:
	- on windows, up event is received by the same face that got down event
	  alt-up is not tied to alt-down though
	- on linux, both alt-up and up are tied to alt-down and down
	  so there's platform discrepancy
	right-click+drag on touchpad is not convenient, needs physical button press
	  then needs 2nd finger to make downward dragging, as buttons are at the bottom
	on touchscreen it's quite okay, with pen too
	I'll go with simple alt-up, as with other menus, for now
	but TODO: there must be some configurability in this
	  though how? maybe introduce some higher-level "events" like tap+drag+release gesture?
how different are VID/S widgets from space templates?
	VIDgets do not introduce a new template, so do not require a separate style defined,
	which helps keep style sheet clean and efficient
there's a collision in terms: styles, templates, themes - how to resolve?
	template is final, it's a space specification block
	"theme" makes sense to name color sets, i.e. look may be android-like but themed differently
	"skin" this is smth like stylesheet - a collection of styles (on wikipedia - same as theme)
	"look n feel" - wider, changes the way of interaction - not supported out of the box in spaces
	hmm maybe I just write "VID/S style" vs "space style" to make it clear
bug/limitation: adaptive space with a map cannot be shared at all, since map should be different for various canvases
	how can this be solved? and should it be?
	if the same space appears on various canvases simultaneously, it should have multiple sizes and maps
	for current spaces to be shared either size should be fixed or it should not be interactive (then who cares about size)
	this may yet cause issues if single generic/stretch appears everywhere, at least it's size will be invalid
	can size & map not be properties of the space itself? but properties of the tree?
	this needs more thought, maybe even entire change of model, though utility value of such sharing is tiny
	if I completely disable sharing, then parent list may have single parent per space
	also, render cache doesn't have to be a tree then
	it makes perfect sense to share simple spaces, like `empty` or some image of fixed size - quite often sensical
	"chips" (stupid name) may also be shared, fine
	stretch and frame - no reason to share really, because they have to be redrawn on a new canvas anyway
	sharing of adaptive container spaces looks even less useful - I can't see any good use for that
	so the rule will be clear: only spaces that do not depend on canvas can be shared
	TODO: ideally some kind of warning mechanism, but not sure how to detect unwanted sharing
	if I eventually find a reason every space can be shared, the model changes will include:
	- separate `tree` of spaces generated by last render
	- no /size or /map in spaces themselves - these will have to be in the tree
	- as such, tree navigation and work with spaces become a little more involved
	  e.g. global words assigned to spaces now will not have direct access to size, etc
	  maybe I'll then add a map [canvas -> [size map drawn]] into each space, or hold it separately, undecided
	- other properties like `limits` or `color` raise questions - how stable they are? or what else changes with canvas?
	  e.g. some space may adjust font to size
	- another dark side of sharing: if same spaces are in the same container, or even that container is multiplied
	  then focus system will go bananas, because it relies on uniqueness of the path
	  so, another requirement for now: focusable spaces are not shareable
timers and performance
	there was a bug in timers that made them jump to the last iteration
	when it was fixed, timers started taking 99-100% of tube-test time to simply iterate over 8k spaces 65 times per sec
	foreach-space 8000 items = 69ms wow
	list-spaces alone = 54ms
	obviously it's a no-go, how to speed up?
	need to somehow only iterate across spaces with /rate and have their paths ready and known
	may utilize it from cache? in this case may make sense to make cache more "official"
	other option is to hunt for "rate" facet change, but that doesn't give me path
	and has to be in space's most basic on-change to avoid duplication
	ok this may work: on-change keeps a registry of "rated" spaces, but paths come from the cache
	then each path is again tested incrementally against handlers list
	made a tree inside render-cache but it went badly: 2 hosts appear to have the same tree, timer events broken
	because top level spaces have no parent
	trying to introduce host parents.. nah this is too fragile.. as expected, I have to make a separate tree
	thing is, for timers invalidation should not affect the tree, but for further invalidation?
	if e.g. there was invalidate/only - next full invalidate should not be stopped
	if there was a full invalidate, child spaces of invalidated parents still may be invalidated
	so tree has to persist, and invalidation should go up to the root without any shortcuts
	if tree is not affected by invalidation, it then can be discrarded by render-face, swapped to a new tree
	the only trouble is how to at the same time, build a new tree and keep the old one for relations check
	if "emerging" tree is used by the builder, new relations will not be reflected on the old one
	have to at the same time add relations to both trees, then later discard the old one
	at least this will make cache more stable, though also slower
	another issue: emerging tree will not include cached (not rendered) subtrees, how to copy them?
	ideally it should be just a node that is attached together with it's children, but it's way more bookkeeping
	funny, both for invalidation and for timers all I need is path
	so if I have a path, I've no need for recursive calls
	and those paths can be generated in a way similar to list-spaces, just with added key and metadata
	and list-spaces can just reuse this tree, while foreach-space doesn't even have to copy it
	though single key will correspond to multiple paths (in rare cases), hashtable should handle it fine
	or maybe it's reasonable to group all paths into a single node?
	first need more high level path api to abstract the low level parts
	the question is one of ordering.. listed tree is ordered by map order
	but rendered tree is ordered by render call order, which is no good for tabbing
	so list-spaces will not reuse the render tree?
	or render may create ordered nodes for children, since it has access to the map?
	bigger question is, whether such complication of render is worth simplification of invalidation? quite unlikely
	during render no event should ever happen, so it invalidates only isolated immediate children
	they may be in the old cache, not in the new, but they have to be moved into the new anyway
	so all cached stuff will be moved, and nobody knows if it's still valid, so trees grow anyway dammit
note on size and reactivity:
	I wanted to put `quietly` before each /size: setting, but it disables reactive relations obv
	and those are used in VID quite a lot
	so, using `maybe` now 
fast hittesting over grid - how?
	problem: `cell` is a generic name, within a map search is linear, even if it was a hash
	thus into-map will be slow with thousands of cells
	to fix it, need some map of cell-object -> cell-offset
	tried to introduce scache (object->geom or object->offset) for this exactly
	but scache can't just return geometry or offset, because that may change with canvas!
	may make it return index into the map, but that has the same pitfall:
	last drawn map may not be the one render fetched from cache
	and though I may rely on it's length being unchanged, this is rather fragile and will fire back at me
	so for now, until a better idea, hittest on grid is slow 
	nor scache worked for pinned-or-not cell identification, because grid/cell style has no access to grid!
	as a result, pinned cells cannot have different size (only colors),
	because grid-ctx/pinned? does not affect rendering from calc-height (and locate-line)
	for the time being: using locate-point (until proven slow)
	oh shit it does affect it! 
pinned flag causes trouble in draw: cells are sized for bold (pinned) font style while they are not
	apparently pinned flag is true at the time hcache is filled, during calc-size
	since there's no way coordinate can be passed into style, only options:
	- have a func that given cell object gets it's coordinate (what if it's shared??)
	  such cells won't ever be GCed
	- each cell has a coordinate field (same problem!)
	  but that and above gives no info because cell doesn't know in which grid it is rendered, and only grid has /pinned info
	  handlers can at least use paths 
	- renew some pinned flag before each cell's render?
	  global? grid can include grids so it will mess everything up, needs a stack
	  per-grid? cell doesn't know what grid it's in
	- renew per-cell pinned flag before every cell's render? might work
	- have pinned-cell style separate from cell? give render a name that depends on coordinate?
	  seems like the most idiomatic and simple solution except..
	  pinned changes -> changes cell's name in focused path, in ccache -> it's not focused anymore
	  guess will have to live with this minor problem
	better idea: pass /extra parameter to render, let it pass it to style and eventually /draw
	this will be useful for lists as well, e.g. to render odd/even items with different background
	the only issue is this will heavily complicate render in absence of apply func
	so temporarily need another solution, global flag seems simplest
TODO: get rid of ccache, cache only one cell, or maybe last 10 focused cells
infinite canvas bores me to death already
	main reason - I'm treating infinite dimensions somewhere as 0, somewhere as alias to limits/max, it's a mess
	can I get rid of it? use only finite and 0?
	main actors:	
	- scrollables (incl. list-view, grid-view)
	  these either have min/max limits defining their size, 
	  otherwise should fill the available finite dimensions
	  infinite dimensions not applicable, use zero instead to minimize
	- cell/box
	  same as scrollables
	- paragraph/area
	  paragraph assumes finite width, so no problem here
	  height is ignored? should never assume height lesser than the text,
	  but may be made to expand vertically when canvas allows
	- text
	  for text the distinction between 0 and inf width is clear - sets wrapping margin
	  height is irrelevant/ignored
	  none is treated as inf canvas by rich-text, but not by spaces
	- tube/row/column
	  same as paragraph/text, 0 makes sense to stretch vertically, inf to stretch horizontally
	  fixed width to assume the wrap margin
	- hlist/vlist
	  ignore canvas size along main axis
	  finite secondary axis is filled, infinite makes no sense, at best works as zero
	- image
	  inf makes no sense, but should mean 1:1 display, that is different from 0x0
	  0x0 should mean either 1:1 or downscaled to 0 (preferably, because who wants an image with scrollers?)
	  current algo just downscales if canvas requires, but not upscales unless /min is not met
	so inf canvas is only applicable to flow layout, theoretically
	in practice, is it useful?
	rows are made to stretch to fixed width
	text? intent is to not wrap it, and get the actually needed size
	so infinity stays but must be treated by most spaces as zero
	exceptions: flow and image
	0xINF canvas is used by tube to hint the rendered item across what axis it should minimize itself
	grid/cell renders items on WIDTHxINF and items should minimize across inf but fill width
	ok, the issue I found was that row was rendering it's items on 0xN canvas, while list - on INFxN canvas
	made list same as row, but now how to lay out menus? vlist sets x size to 0, row follows suit, results in 2 rows
	somehow vlist must set x size to inf, but when? how?
	vlist's default canvas maybe none, but if it's inside a row, it will get 0x0 anyway, so I have to work with that
	some "wide" flag that would ignore the canvas width, set to inf? not good for resizeability
	default none to infxinf canvas and let row pass none to items too?
	ok so let vlist draw items on infx0
	let row on infx0 draw on infxinf - resulting in almost hlist-like layout
	while row on Nx0 will work as it does today - start from 0xinf, stretch, align
	vlist has alignment too, that doesn't break
	row in a row? normally, outer row will draw on 0xinf then stretch, this also works fine
	row within hlist? hlist will render it on 0xinf, and never stretches, and that's fine, use row in a row instead
	scrollables? should use infxinf, so rows don't wrap 
shit! timers are still a bottleneck, because e.g. `inspect system` creates 428 rated spaces (scroll/roll timers)
	and the culprit is paths-from-space, surprisingly
	anyway, not optimizable - have to turn off unused timers (when scrollbars are hidden)
field origin is tricky!
	can't modify it in the draw func, because every draw on zero canvas (in a row/list) will anchor origin to the beginning
	can't modify it in key events purely, because resizing would put caret out of view (though acceptable tradeoff)
	maybe fixate it in key events, but temporarily adjust during draw?
	now the problem is, a few key events may be processed in a row, 
	one invalidates the layout, others have no access to it now
	requiring a render cycle would slow down key input (which is already not so great)
	also, layout is not guaranteed to be aligned with /size - size may be fetched from cache
	possible to fix by tracking /size change and ensuring a layout exists or created
	OTOH, field is always single-line, so this problem only exists for `area`, which can wait
	layout invalidation without setting it to none?
	oh ez fix: look in /layouts for an existing one?
	nope, canvas can be 2e9, but size will be determined by the limits
	ok, it's a bug that canvas is not the same as size? no it's not, since it is used to determine if redraw is needed
	usage of 2e9 has another drawback: `constrain` in presence of upper limit, makes it finite
	but finite canvas gets filled
	maybe constrain should not affect infinite dimensions?
	really this canvas system is quite messy due to it's implicit assumptions
	maybe it would be better to rework it, pass an object with dimensions to fill and dimensions to minimize along
	or simply do not call constrain in render, call it in each space when setting size?
	on-change can't work here since this size should also apply to other things
	;@@ `none` canvas should probably be normalized to infxinf by render itself though; removes `default` from everywhere
	non-finalized origin leads to all kinds of glitches / unexpected behavior (e.g. on clicking)
	solution? what if origin is signed? when caret's on the left, it's positive, on the right it's negative
	problem then what if it's inbetween?
	origin could be anchored to the last caret-induced scroll (i.e. whether one moved right or left at the time)
	or what if it's anchored to the caret?
	or origin = caret's relative offset from one of the edges?
	what if there'll be a segment from left margin + 10px to right margin - 10px
	and origin will be relative position of caret within this segment (0..1 but can go negative and even >1)?
	segment width change would align caret relatively the same way: if it's at end it's at end
	risky a bit: area outside of 0..1 may result in caret hidden
	so less risky would be to map 0..1 to whole field, and keys/interaction may then jump a little but not much
	name? anchor would do, while origin will be a write-only thing, only used by offset-to-caret computation
	what will anchor be for area? can't have floating point pairs.. block of 2 floats? pair * 1e6?
	workflow? draw only adjusts origin knowing anchor, events adjust anchor within current origin and look-around
	or maybe to hell with it? why should draw adjust origin? let only events do that -- and this works good enough!
	ok the glitch was that text/layout (used for caret-to-offset) is invalid after `edit` and until redraw, have to force it immediately
scrollable origin is tricky too!
	when scrollable is inside tube - tube calls it on a 0 canvas and scrollable adjusts it's origin
	since this happens all the time, it becomes impossible to scroll after a certain length
found a problem in tubes
	I want them to fill the available limited canvas dimension (otherwise will have to set limits manually = boring)
	on the other hand, I want them to split into rows when they can't fit into one
	and these requirements conflict with one another, as split rows will then become bigger than should be
	here's an idea: render them on infinity first
	once rows are known, adjust the widths, then we know each row height
	then distribute available row height to rows according to weights (just modifies the 3rd render)
even bigger one
	column [paragraph] - if paragraph is long, goes out of the canvas, can be fixed but fix is a kludge
	column [row [paragraph]] - fix doesn't work
	test code for polygon: column [row [data-view wrap?= on data= "abc def ghi klm nop abc def ghi klm nop abc def ghi klm nop abc def ghi klm nop abc def ghi klm nop abc def ghi klm nop abc def ghi klm nop abc def ghi klm nop "]]
	but main issue is that this is so messy I can't even think of it
	have to redesign the canvas notion!
	idea is: have both canvas and explicit filling intent (which axes to fill or not)
	in simple form, single pair should be enough:
	WxH   - fill whole canvas
	-WxH  - fill vertically
	Wx-H  - fill horizontally
	-Wx-H - don't fill, just don't hang over
	0 will still be used for minimization
	+infinity will still be used for e.g. unconstrained text rendering inside horizontal list etc
	that means, finite dimensions may not mean "fill" but they will always mean "clip" at that point, which for flow layouts makes sense
	`none` will not be used explicitly, only when passing over from a function called without canvas
	lack of /on or canvas=none will be normalized to infxinf to simplify every other canvas handling code
	hmm encoding and decoding canvas all the time seems like quite an overhead
	maybe pass it as two arguments?
	or to hell with encoding, not need it, no need to pass fill flag?
	dammit, canvas should be passed as it was, with fill flags
	so best option then is to use test functions
	shit math is too complicated, subtraction, taking maximum etc
	better to have two arguments then: abs canvas and fill flags
	if fill flags are a block, it has to be copied, so pair should be a better fit
	encoding+decoding 2 pairs should be simple though
	let negative values mean 'fill=true' then for simplicity (since infxinf is positive and doesn't fill)
	most important point of introduction of canvas/fill split is to carry over info about outer canvases
	e.g. spaces within a column within a row should not be bigger than the row,
	and explicit rounding to zero/inf loses this info, so should be avoided when possible
	list of course is infinite by design
	so far encoding/decoding is fine.. nice properties of using negatives for fill and enabling fill = 0 and 1 for "no fill":
	- can pass fill=1x1 and if canvas is zero, fill will be set to 0 too
	- extend-canvas just works: no change needed
	- render cache needs no change while canvas is a single value, negative and positive canvas leads to different cache hits
	- encode-canvas is super easy operation
there's a problem with window autosizing (again)
	list-view sets window to a 1D multiple of it's sizes, so there's never a horizontal scroller
	even if content is bigger than the window!
	generic resize sets window to 2D multiple, so it becomes huge, much bigger than content
	need to think more on this aspect...
	what if: not only window gets smaller if it's content is smaller
	but it also gets larger if it's content is larger?
	what limits it is `available` returns up to max-size
	and max-size is the only way to tell it what size it should align to.. well, so far it was
	now there's canvas and window may use it! while max-size may stay big in 2D sense
	oh, list-view has it's own available which just uses canvas for width (as max size)
	I cannot resolve this after all?.. it's ambiguous
	list items either draw themselves to fit into canvas, or into infinity
	(list could have a controllable wrap flag)
	problem here is wrapping instead, why it's not wrapped (files are single words?)
	hmm... rethinking
	if there was no `available?`, only draw:
	list-view:
	1. has canvas and limits - adjusts canvas to limits, calls draw on adjusted canvas (fills width? yes)
	2. has no/inf canvas but limits - uses /min limit only, calls draw on it (may be 0x0) (fills width? yes)
	3. has no/inf canvas or limits - because content may be infinite, cannot infer the size, uses 0x0 as default /min limit
	   or rather passes canvas as is? if it's infinite so be it
	window: always receives canvas, maybe 0x0, or infxinf:
		list-view gives it 1x10*size canvas, to fill horizontally
		grid-view gives it 10x10*size canvas, not to fill (web too)
		in this case important part of the canvas is not lost, and no need in max-size too, or it can be set on the fly
		problem with max-size is that available may then return 0 if window is 0 sized: need to ensure available works with content, not window
	auto sets its max-size? there was a problem with this on 0x0/inf, but maybe it doesn't need explicit max-size anymore
	> remove max-size
	let it just multiply the canvas and pass it to the child? but then the original canvas will be lost
	hmm actually it's maxsize is the argument to draw/only, and /on can still carry original canvas and filling intent
	but clipping intent is the issue?
	grid: will be no clipping
	list: it's okay if it can clip at it's width
	what window passes on as canvas?
	may want to fill the original canvas (only if window is <= canvas), but not window
	worse case: I could expose a lever to control list-view's 1D/2D behavior which controls the filling
	also list itself fills it's width, but should it expand it's width to the canvas? for clickability of items, yes
	so, now I add `available`.. why? because rendering is so much slower
	what does it need?
	in list case:
		available takes canvas - why? because locate-line needs to render items to wrap around canvas width when they can
		vertically, it doesn't care about window and may render outside of it
		> horizontally, it should just tell how big is the current window (with all items rendered inside it's 1x10 size)
		so then it doesn't really need the canvas, but it needs window to render itself (and items)
		oops, it needs canvas for vertical estimation, because wrapping affects window height with limited content
		> but if it's already rendered to window size, then it's enough to use this size
		but first window renders get zero canvas, so how big should it render itself? how does it know 10x multiple of what it will take?
		need to take care not to call available before window gets it's final render?
		> also window maybe should not render anything if it's zero-sized
		previous available? design didn't use canvas - only window/max-size as canvas, so it was losing canvas and it didn't reach content
		this must change.. but still, available should not cause renders and use already rendered geometry!?
		except it can't: it's called on window edges, and requires to render items around the window, and canvas to wrap these items
		> so, roll will have to provide canvas, but roll is an event.. maybe it should use list-view's current size as canvas?
		possible danger: during tube rendering cycle, list-view gets rendered at various sizes and causes a roll incidentally
		> need to ensure, that roll is only called from timer events and never from the rendering chain itself
		> pages must be synced with list-view/grid-view pages or removed from them? I'm for removal
funny discrepancy found in window rendering:
	window over list needs to render all items within itself, so we know size of items and can adjust scrollers' look
	window over grid *must* not render all items, or it becomes way too slow
	however if it doesn't, and rows are autosized, then how will it estimate scrollers offset/portion?
	it's only simple on an infinite grid - just take the window size (though window knows nothing about that)
	moreover, draw itself is a serious performance hit, so it would be best to exclude clipped out items from it's block
	dammit.. another unsolvable puzzle
	so: window only has to be rendered on a canvas once, next time it's cached (rightfully)
	then cache doesn't work? or window gets invalidated?
	aw shit.. window receives /only xy1 xy2 so it's not cached, indeed, and same goes for grid
	but even if window gets cached, initial render of 10x10*size window is super slow (well, 100x times no shit)
	so in general /only idea just doesn't work, needs redesign
	initially meant for a scrollable over a container
	but then even for a list, cacheability of items is questionable unless canvas stays the same
	and even bigger issue is the initial render time.. just 5k text strings by 120ms take 6 seconds
	grid can only avoid that if has fixed line height and I limit the rendering region to the viewport
	so idea here is passing small region from window to the grid and list, and those will decide if they need to render more
	and for that they need to know max rendering area covered by window, so /only needs 4 args, not 2 (ok maybe 3 considering canvas)
	/window xy1 xy2 origin ? or simpler, 2 args: xy1 is always negative, origin is at 0x0, size up to canvas? nice!
	/window is a good name then
	XY1 is now coordinate before or at 0x0, left corner of the window relative to current window(!) location
	XY2 then is after window
	shit no! this is not simpler - same but reversed, old xy1-x2 were better (at least nonnegative)
	while grid/origin contains current viewport (canvas) offset within the window but if I limit drawing I can't cache window
	but if I don't limit, it'll be too slow to render and window size will have to be made too small
	omg! can't cache window for grid then, but have to - for list? at least I have a /cache? flag
	also, when not cached window is slow, let's see:
	1) each cell creation is 2 spaces creation, each ~100us, 2x120x100us=24ms
	   but wrap-data is not the culprit here, it's slow when approaching right bottom part of the window!
	   btw 2x2500x100us=500ms
	2) draw-range is indeed suspiciously increasing it's time towards bottom right! up to 350ms!
	   now that's dumb, it always draws content starting from the 1st unpinned cell! of course it's slow
	   solved! smooth now! 70fps @ 50x50 grid
	now just to restore window to it's positive xy1 xy2 coordinates...
problem with scrollers now...
	scrollable removes them from canvas so in case scrollers will be visible, content stays fit
	but then window (grid) only draws itself up to scrollers, and there's an empty band in case they're invisible
	ideally I would make a few renders to fit scrollers properly, but with a grid-view it's not an option
	~3x slowdown? or rather, exponential, since each scrollable will multiply it's subtree by two?
	grid knows nothing of scrollers size either, pity
	don't wanna use an adhoc kludge too, what to do?
	add an /over-render [pair!] facet to grid so it could be fixed in case default scroller's size is changed?
	or maybe grid's canvas should simply be increased, because why not? it doesn't align anything anyway
	(increase also increases the final size, so that doesn't work)
	can scrollable remember it's scrollers state to avoid extra re-renders? will in this case initial render still be too slow?
	also this auto-adjustment would be useless for grid, only applicable to lists.. so must be a configurable flag
	general scrollable doesn't know if it's applicable to it's content or not
	ok idea:
	/content-type (/extension ?) facet for all scrollables which can be:
	- 'planar - default, single render on a full canvas
	- 'vertical - for list-view, texts - 1st render on full canvas, 2nd (if doesn't fit) - without vertical scrollbar
	- 'horizontal - for (unused now) horizontal lists - 1st on full canvas, 2nd (if doesn't fit) - without horizontal scrollbar
	because I simply have no idea how to properly feed the canvas sizes to a content which extension strategy is unknown 
field/draw is quite sophisticated and an attempt to (deeply) style it requires duplicating it's logic
	initial idea was to base it on `text` to avoid two-way syncing of facets
	maybe field can render itself as text?
	but this would mean the same space appearing in the cache under varying style names, bad idea
	can /text be synced then between field and field/text-space?
	possible but will have to reassign it after every change
	or it could be the *same* series, just synced on assignment (but also two-way on-change mirroring for react support)
	in these however I would have to replicate: text, font, flags and color
	ok what if field didn't call render 'text, but text-draw, no that's exactly the current problem
	no way around mirroring then, like in label.. unless this can be solved generally by design somehow?
	a little problematic is only that unlike label, field can change rapidly in event handler or even by programmatic `edit` invocation
	which may work for a field, but will slow down `area` when I get to it
	it could probably hold a spare `text` (another object) and `set` it (which should be faster)
	and I will ensure edits are grouped and applied as one, to keep updates to minimum 
how will ellipsizing work on text/paragraph?
	on text I decided to make a function that takes facets of rich-text and uses offset-to-caret to estimate it's width
	it will have to measure `...` with the same facets first and subtract that from width
	for paragraph the mechanic will be more complex:
	- i: offset-to-caret at bottom right corner of the canvas
	- y: second caret-to-offset/lower i to get how far the last visible line extends
	if it extends a few px beyond the viewport, previous line is chosen to be ellipsized:
	- y: second caret-to-offset i tells where the current line starts
	- i: offset-to-caret y - 1 of right margin is on the previous line now
	then:
	- i0: offset-to-caret y - 1 or y of left margin (zero) is the start of the chosen line
	- measure `...` and then subtract it from right margin
	- i1: offset-to-caret y/y-1 of right margin minus `...` width is the last text char
	now, either text of the face itself is copied and ellipsized, or it's somehow imposed on top of the full text face
	presumably first way is faster and simpler
	maybe it should test if face/text is not *same* as space/text and append-clear instead of a copy
grid autofitting
	my initial simple attempt just tries tossing column widths around until they're even (and that's very prone to local minima)
	this only will work fine for flow layouts of many very small items
	for text best case would be to measure text length in each cell, then at least use that as a starting point
	of course, quite hard to predict where text will wrap (or too expensive to bother)
	maybe ideally it should inspect cells content names and decide from that?
	but even `image` may adapt it's size very non-trivially, this is going to be way too complex
	so maybe it should estimate each column at multiple widths from 5% (or chosen min) to 90% (or what's left) of the whole width in some steps
	that would attain approximate curves how each column resizes, turn discrete optimization task into a continuous one
	number of points may depend on the slope, e.g. limits first, then center, then centers of centers, until e.g. 5-10px vertical threshold
	then I just find a point where curves max is at the minimum using linear interpolation
	is there analytical solution? https://i.gyazo.com/74fa7ecc2e53170c7be9aa9c1ec65f28.png
	I plot sum(wi) over hi, find a point where sum(wi) = total-width, that gives me height
	then find each wi where hi=height, and I have all the column widths
	that'll work more or less for good grids, but cannot account for spanned cells
	any complex data, ideally needs many many random points, but that'll be slow esp if grid is big, may take seconds to minutes
	SO lists some rather naive methods too:
	https://stackoverflow.com/questions/22206825/algorithm-for-calculating-variable-column-widths-for-set-table-width
	but a good idea is to find the biggest word! - didn't occur to me, need to consider
	html uses min/max widths defined for each cell.. well.. I hate micromanagement
	but in case someone sets /limits for cells, e.g. via `cells` picker, it may be worthy of consideration
	https://drafts.csswg.org/css3-tables-algorithms/Overview.src.htm
	https://www.w3.org/TR/CSS2/tables.html#auto-table-layout
	a good note is that I should consider a case where the table doesn't fit into the given width, and must be extended
	what makes a minimum?
	- /limits of cells
	  I don't envy who's going to fill those lol, very low priority
	- cell may be complex and it's content may have explicit or implicit min limit
	- words
	  and this is shit - need to render every word separately, but don't know their fonts/styles
	  besides don't know how content behaves in regard of it's text - maybe there's padding around words or they're all differently styled
	  perhaps rich-text can be made to not wrap single words and size-text can be used by `paragraph` to determine it's min width
	  (I see one way: replace all spaces with new-lines and size-text it on infinite canvas)
	  in this case it will also work under the general algorithm, not text-specific
	  perhaps this should be decided by a flag in text spaces, not on table level
	  table will just render each cell on min canvas and use the achieved size for computations
	  also, text may have an ellipsize flag in which case it should never have a minimum width, or at least not bigger than ellipsis
	rendering accounts for all of this
	then question is whether to go beyond minimum if width is over given one, or respect minimum but go over width?
	clipping is usually bad, so going for the second option
	ignore spanned cells?
	btw, minimum column width may save quite a bit of renders - those between zero and minwidth won't be needed
	so there's extra-space = maxwidth - minwidth, if it's positive, can be divided by step (e.g. 10-50px)
	and each column rendered on widths minwidth + n*step
	one algorithm's idea, but `distribute` is not really a good fit here, as it doesn't aim for the minimum (although it's fast & precise):
	1. render all columns on zero, get their min widths W1i and heights H1i
	2. estimate space left SL = TW - sum(W1i), TW is total-width requested
	3. if SL <= 0, end here, set widths to found amounts
	4. SL > 0 case: render all columns on W1i + SL, now I have heights H2i
	5. have a vector of weights wi=(H1i-H2i)/(W2i-W1i), good thing is if H1i=H2i, weight is zero and column won't be expanded
	6. use `distribute` on SL width given W1i -> this gives a new width estimate WEi
	7. render all columns on their WEi, getting heights HEi
	more perfect algorithm:
	1. render all columns on zero, get their min widths W1i and heights H1i
	2. estimate space left SL = TW - sum(W1i), TW is total-width requested
	3. if SL <= 0, end here, set widths to found amounts
	4. SL > 0 case: render all columns on W2i = W1i + SL, now I have heights H2i
	5. arrange all heights H1i and H2i in a vector, sort it by height, remembering i and 1/2 for each height
	6. first point is the global minimum H0 = min(H2i)
	   (oops, unused)
	7. walk over this vector and for each point compute total width TWj (j now is sorted index on the vector)
	   this assumes linear H/W between H1 and H2 for each column, but that's an approximation for now
	8. save found total H/W coefficients kj of each segment in the vector, found as kj = Hj+1 - Hj / (TWj+1 - TWj)
	   (oops, this step is not needed even, just the total widths are used)
	9. during the scan, choose the segment j=m where TWm < TW < TWm+1
	10. on segment m linearly interpolate width TW = TWm+1 * f + TWm * (1 - f), f = (TW - TWm) / (TWm+1 - TWm)
	    this gives height estimate HE = Hj+1 * f + Hj * (1 - f)
	11. width estimates of all columns can be found by lerping as WEi = W1i + (W2i - W1i) * (HE - H1i)
	    they should in total sum to TW (need assertion here)
	12. render all columns on WEi, getting Wi and Hi
	    ideally Wi should equal WEi, but if it's stepwise, it can be a bit less that's fine
	13. result can be used already, but if more precision required, then Wi,Hi is a third point between W1i,H1i and W2i,H2i
	    and in the general case W1i will be less than WEi, so Wi,Hi vector may be renamed to new W1i, H1i and repeat from step 4
	    end condition may be the number 0+ of estimate repetitions, I think this makes most sense
	    alternatively, max (WEi-Wi) threshold
	what about constant-width columns? e.g. single word in a cell may set min & max width to the same amount
		their H1i and H2i appear next to each other in the vector, giving zero kj for the segment
		an exception can be made for such columns - their width should not be increased, i.e. their max width should be the same as min
		then more adaptable columns may be expanded in their stead, even though height won't be affected anymore past that
		(it should be an option, maybe not yet exposed but controllable)
	what about columns that have a reversed curve? e.g. a column of images may be small given zero width and big given big width
		perhaps these should be treated as constant-width ones,
		and maybe accounted for by some min-column-width setting (mb per-column)
		of course min-width is not a requirement, as one can always set /limits/min for the images or at least one
	spanned cells can either be ignored or their widths divided by the number of columns spanned
	in that case it may be rendered for each column where it appears
	how can I make a general algorithm, a functor over function that does all the renders and details?
		need lerp func and it's reverse, outside of the segment should be considered constant
		need function that takes a column index and width, renders it and returns total size, accounted for spans
	problem is that measurements have to apply full styles! e.g. host/grid-view/grid/cell
	otherwise it's not reliable
	so solution should be to *delay* fitting until next render, where draw will call it with canvas' width
	also this function will need the window size, as grid may be infinite or big, and it's also known to draw only
	but what if first canvas width is zero? should autofit only fire with fill/x flag?
	can/should it fire always with fill/x flag if sum of widths <> canvas/x? makes sense on resizing
	should there be another cache in the grid, widths-cache, wcache?
	OK this algorithm is almost okay, the only issue is H/W approximation should not be linear, but hyperbolic! H*W = const (area)
		then single iteration should suffice in most case
		how to modify it so?
		log(HW) = log(C) => log(H) + log(W) = log(C)
		won't work since TW is a sum of hyperbolae, but this sum is not a hyperbola itself
	easier then.. knowing all H1,H2,W1,W2(i) is enough to find the segment where TW lies, because TWj can be found
	then I just calculate all heights for that segment knowing widths
	since it's not a perfect hyperbola, H1*W1 <> H2*W2 generally, so how to express it?
	makes more sense to rely on H2,W2 than H1,W1 for const estimation, as W1 is usually random (whatever word sticks out)
	hyperbolic curve is then: H1*(W1+C) = H2*(W2+C) = const(unknown) => C(H1-H2) + H1*W1 - H2*W2 = 0
		=> C = (H1*W1 - H2*W2) / (H1 - H2), C specific for each curve, Ci
	so H*(W+C) = H2*(W2+C), and for individual curves inside their segment I can find H/W relations:
		H = H2*(W2+C)/(W+C),
		W = H2*(W2+C)/H - C
	TWj = sum(Wi(Hj)) over i = sum(W1i + (H2i*W2i/(Hj-H2i))) with the exception of constant-width regions outside segment of definition
	reverse task is impossible: find height estimate HE given TW, even when segment TWj..TWj+1 is known
	so have to numerically find an estimate (precision may suck because hyperbolae are approximate anyway)
	assuming it's still a hyperbola: Hj*(TWj + Cj) = Hj+1*(TWj+1 + Cj) = HE(TW + Cj)
		=> Cj = (Hj*TWj - Hj+1*TWj+1) / (Hj - Hj+1), however this estimation is much worse than binary search
		HE = Hj*(Wj+Cj)/(TW+Cj) => then find TWE as sum and compare to TW
		if too far, repeat with new TWj or TWj+1
	omg I thought making more than one iteration will be piece of cake, but it's not!
		how to choose the new W1/W2/H1/H2 for each column?
		W1/W2 I don't know what they should become, I only know total width
		H1/H2? perhaps choose the segment that gets intersected by newly found total height?
		and if total height is bigger than both H1 & H2?
		what if H1 is just near the total height? then by discarding H2 I lose the option to go beyond it
		which may still be better than nothing...
		ideally, I need to add another free parameter and have a 3-point hyperbola, then 4-point, etc, but that's too much trouble
	(W+C)*H = (W2+C)*H2
	WH+CH = W2H2 + CH2
	C(H - H2) = W2H2 - WH
	C = (W2*H2 - W*H) / (H - H2)
	it seems that browsers are using yet different algorithm:
	1. determine min widths
	2. determine max widths
	3. assign weights according to max widths only
	4. distribute space over min widths by assigned weights
	   linear or not?
	still 2 renders, and less optimal than hyperbolic, but the advantage is smooth column resizing
	other ideas:
	- golden ratio search, but maybe quite suboptimal for multiple columns
	- estimate HE, but on lower width (eg 80%) for all iterations except the last
	  this will increase the likelihood that found heights will bound the ideal from above
	- browser-like weight assignment but not above the minimum but intersecting it
	  something like what `distribute` does but with minimum instead of maximum
	  though maybe I can reverse it? unlikely
	  @@ need simpler distribute version (browser-like)
	  basically, looped simple distribute: reduce `free` space for each column that is over it
autofit+big/infinite data - dropped the idea
	although it's possible to choose rows used in autofitting, and it might even perform okay
	problem is identifying the rows range! because I only have window size and origin
	but window is translated into the rows/cols based on column widths
	so these widths must be set before such translation, and it's a catch-22
choice of algorithm to replace all spaces with newlines:
	>> s: "C u r a b i t u r   u r n a   m a u r i s ,   f a c i l i s i s   u t   s c e l e r i s q u e   v i v e r r a ,   f a c i l i s i s   n e c   n u n c"
	59.3 μs	[parse copy s [any [thru change #" " #"^/"]]]
	71.0 μs	[replace/all copy s #" " #"^/"]
	67.2 μs	[p: copy s while [p: find p #" "] [p: change p #"^/"]]
	66.3 μs	[p: copy s while [p: find p #" "] [p: change p #"^/"]]
	343 μs	[forparse [p: #" "] copy s [change p #"^/"]]		;) slow because of apply usage :(
	50.1 μs	[parse copy s [any [to #" " p: (change p #"^/") skip]]]
	>> s: "Sed vehicula, sapien et consectetur vulputate, turpis ipsum viverra sem, in efficitur quam erat sit amet ligula"
	11.9 μs	[parse copy s [any [to #" " p: skip (change p #"^/")]]]
	21.5 μs	[replace/all copy s #" " #"^/"]
	20.2 μs	[p: copy s while [p: find p #" "] [p: change p #"^/"]]
	25.0 μs	[parse copy s [any [thru change #" " #"^/"]]]
	34.0 μs	[parse copy s [any [thru [p: #" "] (change p #"^/")]]]
	40.5 μs	[p: copy s forall p [if p/1 =? #" " [change p #"^/"]]]
	39.6 μs	[p: clear copy s parse/case s [collect into p any [#" " keep (#"^/") | keep skip]]]
	35.1 μs	[p: clear copy s parse/case s [collect into p any [keep thru [#" " | end] keep (#"^/")]]]
	17.4 μs	[p: clear copy s parse/case s [collect into p any [keep [thru #" " | thru end] keep (#"^/")]]]
image is damn problematic
	with weight= 0 if I put it into tube it becomes 1x1 px (invisible)
	with weight= 1 it gets space reserved for it but doesn't stretch past image/size, so space becomes unused
		it only works fine if I specify limit explicitly
		so maybe it should stretch itself by default with fill=1? and if weight=0 it will disable stretching?
	OK:
		weight=0 fill=0 - use image/size, constrain it by min-scale/max-scale
		weight=0 fill=1 - ignore fill flag
		weight>0 fill=0 - use image/size, constrain it by min-scale/max-scale
		weight>0 fill=1 - fill provided canvas, constrain by min-scale/max-scale
		what if fill/x <> fill/y ? perhaps should be the same as fill=1x1
		although it's possible with fill=1x1 to make it bigger than the canvas, I think it shouldn't happen
		what if canvas is smaller than image/size?
		perhaps it should make itself smaller than canvas, but only if weight>0
shit! bug in styling: I have a shared context per each style
	so in scenario with e.g. `cell [cell [..]]` by the time first cell is composed, it's already bound to second cell!
	well since the block is shared, it has to deal with state itself.. but this makes it dangerous to use..
	solved that by copy/deep style-ctx for now.. don't like the overhead but it's worth the convenience of block styles 		
tube caused problem in grid autofit:
	when I write `row 1` it makes itself 1px wide, while content sticks out
	it makes some sense: it fits what it can, the rest sticks out
	on the other hand for grid this is bad as text made of single letters becomes real big
	problem is: grid reports it's size as if it included the sticking out items, at the same time it doesn't let the other items expand
	test code: 
		cell green 50 [row blue [
			image data= system/words/draw 100x100 [pen blue box 1x1 99x99]
			paragraph "I n   p o s u e r e   p l a c e r a t   m a x i m u s . I n   p o s u e r e   p l a c e r a t   m a x i m u s . I n   p o s u e r e   p l a c e r a t   m a x i m u s"
		]]
	text should be sized to 120px wide, or returned size should be 50px, but not both
	in this sense, weighted algorithms are more resilient to abuse
I need to drop multiple parent model entirely as it causes too many complications in both rendering cache and timer cache
	;@@ and document this once decided
	memoized-paths used in timers was unreliable as there's no known moment when it will reliably find paths that will survive for long
	and there is no moment when it's known that memoized-paths should be invalidated
	then I tried to add it's buildup directly into render, but render would just append the same path over and over
	same-path lookup in that array is very slow so not an option, so when should a path be removed? nasty...
	from now on, only spaces with single parent can have a /rate, and I should probably move to single-parent model
	although, what about self-containing grid? it has itself as parent and a real parent too... shit
	what if invalidation doesn't clear tree nodes? only marks as non-cached?
	I need then to leverage some `forget-tree` function to recycle no longer needed spaces (too bad GC can't tell me)
	or maybe I could scan the cache post-render and clean it up from unused spaces?
	have no parent = go away? but what if it has a parent, just wasn't invalidated?
	more sense in marking spaces as cached or not... then not cached = go away
	or better: have a render generation (incremented number), save it along each cached slot, if less than latest = go away
	same number will surely blow the hash :) hmm.. no, tested, it's fine, but it has other problems
	perhaps I should ditch hash for now, use block.. see #5213 - append & change are fine for now, and shouldn't use same items
	timings: `append` and `clear back tail` - 1us, `change` - 1.4us
	also, hash vs block for pairs: up to 4 parents no difference, 8 parents - 20% slowdown, 32 parents - 100% slowdown
	meaning, I could use block for most cases, and use words in place of objects for parents to save RAM at the cost of one `get`
	generation number should be per-host-face, because they are rendered separately, and cleanup should affect single face only
	more informed hash structure then:
	single space can have different names in different places on the tree, so name should not be part of it, but what links it to it's parent
	parents block: [generation (once) space-name parent-name ...] (parent-name for hosts is 'host')
	cache data block: [canvas space-size map drawn ...]
	cache itself: [latest-generation (once) space-object parents-block cache-data-block ...]
	(generation could be a time! value perhaps?)
	all rendered items will be cached, regardless of their /cache? value (for tree validity)
	when fetching smth from the cache, need to visit all children and increase their generation,
	but how? only by iterating the map.. besides it's a slowdown and possible cycles..
partial cache cleanup:
	iterate over render-cache, spaces with generation older by a given threshold should be removed completely
	(marking as free is pointless, just move smth from the tail)	
	trigger? could be done once a second maybe (every `rate` frames)
also, maybe I could detect face destruction and free it's space cache?
	inject smth into stop-reactor's body? but it's compiled, and face's code is compiled with it, I can only override whole reactivity
	I could perhaps inspect system/reactivity/relations and see if my host is there?
	cleanup task: just clear the cache belonging to particular host
	trigger? it's not rendered anymore.. even timer can't help if all hosts are inactive.. so no possible trigger
	then manual cache-cleanup func, and a list of known hosts,
	should also be triggered after each host render, so while at least one host is alive, other ones will be freed
	need to test that host is indeed reactive at the time of 1st render, if not - find a defense
;@@ need to find a way to disable invalidate calls during space creation, otherwise it's just lost effort
;@@ esp. if space is deeply inherited, like link/paragraph/space
while migrating spaces to classy-object, found an interesting catch
	list-view/list when it's axis changes, affects content-flow of it's parent list-view
	this means it's on-change actor is per-object, and classy-object doesn't work like that
	ideally I should just call `react` and tie /content-flow to /axis, but spaces are not reactive due to later's shitty scalability
	I could maintain a registry of list-view/list pairs, but bad idea - see REP 129
	I could add /parent to this list, simple, but then spaces become cyclic, don't like it
	(mold forgive me for even considering this, although if I add it as a word...)
	ok /owner for now, temporarily
	well, another option would be to make content-flow a function.. probably not..
another catch:
	with `declare-class` each new inherited spec adds a call to `classify-object`
	without it, all initial on-changes (during object creation) will be lost (as object will be classless until complete)
	but it's an overhead I'd like to avoid
	I could perhaps insert `classify-object` into the head of the spec
	but then if descendant class restricts some parent's field, initialization will fail if parent assigns a forbidden value
	plus overhead
and.. a lot of invalidate calls will now happen during construction
	pointless, since it's not valid in the first place
	idea: use /size = none as "never drawn" check? maybe inside invalidate itself?
found multiple inheritance in on-change:
	/origin is present in scrollable, window, grid, container
	inf-scrollable inherits it from scrollable
	grid-view and list-view from inf-scrollable
	but grid-view wants to push it into grid, so it overrides the original
	;@@ maybe I should add optional override warnings into classes (maybe as #debug classes ... or #debug warnings ...)
timer becomes more and more woven with the rest
	after classes merge, now I can't "modify" base space-object! class and affect all the other created classes
	I either add the rate check directly into space class upon it's declaration, or modify all classes created so far
	if I modify all of them, how do I know they're all spaces? some other classes might have been declared
	plus, render has to do special work for timers
	plus, events have special on-time slot
	okay maybe I could maintain a global list of on-change hooks? but then, just for timers? reactivity is per-object anyway
	not worth it, integrating timers...
I'm all the more serious about single parent model
	what do I lose?
	self-containing grid? okay, but it has no practical value
	shared stretch space? to hell with it, it's not costly
	shared images? they could just share an image! value, but be different spaces
	I lose the ability to mirror some space tree somewhere:
	- debug-draw that renders existing spaces on it's own canvas
	- possible magnifier tool (e.g. in some UI editor? I don't even see a real use case, but draw block works here)
	- fancy fx like layout mirrors, minimaps, etc - draw block works as long as there's no need in interactivity there
	  (it won't be possible to press mirrored button etc)
	  although.. debatable.. I could make a space that mirrors it's content and makes it interactive with /into
	- animations e.g. rotating away copy of the layout - would have to become bitmaps or fixed draw blocks
	- some kind of task manager could have snapshots of it's "task" layouts - again, fixed draw block works fine
	so, only debug-draw is lost, and I could make it copy it's spaces subtree to fix that
	that seems to be all...
	what do I gain?
	no risk for cell space to belong to multiple grids or be at multiple places in the same grid
	  otherwise how to answer the question "what's the coordinate for this cell?" needed by styling (is it header or not, odd/even etc)
	  header would assign a bold font, which is not accounted for by render-cache, and it will flip between fonts depending on rendering order
	  (this answer will still be hard, but at least it will have a definite answer)
	no risk of shared timers (which would slow them down significantly due to need for a complex cache model)
	I could add /path facet to each rendered space
	so timers will know what to do with timer's parent without any special lookups or tricky caches
	this will also keep spaces moldable as it's not an object list (until reduced)
	I could using /path easily invalidate it up to the root without a render-cache (which is a beast)
	how to avoid subsequent invalidation? just by checking /cache for valid/invalid
	cache could be held within the space itself, but since it contains draw blocks, I should not do that, or mold will kill me
	or cache could be a word e.g. `valid` that points to a block with cached values
	`invalid` could point to the same block or not, it doesn't matter as that data won't be used
		(it's best to save the link so the object with [valid invalid] words will not require recreation)
	=off could disable caching for that space, but we'll still have a path, independent of invalidation
	what about cache cleanup then? cache only has objects within map, but that's enough to lock them
		if cache is a word, no cleanup needed - GC will take care of it as long as cache has no references to live parents
		let's see.. map contains children and these contain path that links them to parents... but children are inaccessible, so GC works
	no need for generations, as these were only needed as a kludge for cleanup
	no need to use a hash!
	spaces already cached - how do I find them? just fetch their valid/invalid word, easy, which holds the subtree (as map)
	this opens a possibility (down the road) to specify which object fields are to be held in the cache (not just drawn/map/size)
		for grids this may be quite useful as they have too many caches
		for text I could put /layout there
		and it may remove the need for space-local /invalidate func
		instead of exposing a new /cached slot, /cache could be used:
		a block containing a list of cached words (before it's head) and their values (after it's head) referred to by word
		a select-cached-fields function or whatever the name to tune it post-construction
	problem with paths: in cached subtree they might become invalid if parent got moved
		will have to visit and renew all paths via map traveersal
		if I'm visiting whole tree, perhaps no need in deep invalidation?
		during visit I will find deep spaces that are invalid, and will pop up the invalid flag to the root
		this will solve the problem of invalidate vs invalidate/only
		but may be slow...
		alternatively, I could in place of /path just use /parent (word), limiting the visit depth
		need to benchmark.. list-spaces takes 7ms for 1000 spaces, which should be a good visitor time estimate
		and that crosses out visiting idea, then /parent should indeed be a word, or words
	will have to remove 'generic' spaces
	will be no need in limit or cycle detection in traversal algorithms
	consider disabling cache for timers, as there's really no need
	how to check for possible parent override during render?
		maybe I shouldn't? 99% cases won't override anything, and self-containing grid still will work (hacky but..)
		perhaps just an assertion, maybe only in debug mode?
		this looks like a costly check to do though.. and will require a hash building during each render..
		postponed!
		this also relates to whole /parent vs /parents dilemma: with /parents I need a tracking mechanism
	can /parent be part of /cache ? no, because we still need the relation even if space is not cached
		/parent is mandatory now for all spaces, while /cache may be absent? but that would make it `none` meaning not cached
		so /cache is mandatory too
	/parent may simplify /size checking as /parent=none can be tested for "already rendered" and /size may always be a pair!
	I like /owner more than /parent though, 1 symbol less
	/dirty? flag is not needed anymore for the host, although how to avoid redraw?
		perhaps host should check for it's space's /cache='valid value?
		update() is not needed either as it's all automatic
	who creates the /cache block?
		it should be just `on` initially, or make-space could create the block and make it 'invalid
		but it has to make it invalid *before* all other fields are set, so as not to trigger invalidation..
		perhaps it could be unbound 'invalid at first, and post-construction become a fully qualified 'invalid ?
		then cache could not be tuned during construction until make-space exits
		/cache could be the first word set, with a call to create-cache ? that solves it all
		since it's unset until initialized this will be simpler than also test for unset...
		but I could simply test for a word, then it doesn't matter when cache is initialized!
		problem with create-cache: if I wanted to alter it, I would have to call it again for each space
		this will also affect /text space which must be fast
		maybe a better way to use a `cache: block` at first until `make-space` turns it into an object
		tricky part: without /only I need to visit all parents even if cache is 'invalid or off, but not if it's a block!
	name is still a problem! if I have /parent chain I still don't have the names themselves
		and don't want another global registry for them, so perhaps name should also be in the cache!
		but if I decide to expose it, won't be needed
		ok solved by last-frame at least temporarily, need to think about explicit name even in existing model
	what about timers that were rendered (and armed), but are no longer on the frame? how to turn them off?
		they still have a /parent, which may be live, and name
		I could scan parent's map for the name, but it's a big overhead in case of lists/grids
		a global registry (one per host) could have been better if I could clear it at every frame, but I can't (due to cached subtrees)
		maps could become hashes, but that would only work if they contain objects, not names
		looks like find/same on the map is the cheapest solution so far, long as timers are not put into grids
		but they are.. in inspector grid-view within grid-view...
		and such lookup will have to be done everywhere up to the root
		will be a user's burden to turn off timers /rate when not used? what about grid-views in cells? shit, these will stack up
		I could combine the notion of render generation with some flag for cached subtrees (mark whole subtree as valid without visiting it)
		then if I scan the tree from the host down, I will stop at the mark
		e.g. if generation is an integer, mark can be -1 or 0, at 100 fps it will take 462 days of uptime to reach the maxint
		generation could be time (slower?) then mark could be none (or it can be none anyway, or it can be 'cached)
		generation could be a float64, still fast, multiply by 1 + eps instead of incrementing, enough for 1e18 frames
		simple +1 increments are enough for 1e15 frames too, so increments are enough as they coerce to floats
		generation: int/float (rendered), 'cached (fetched from cache), none (never rendered)
		in host face - only int/float and none
	/cache format: [
			name generation           <- used by timers mainly, to figure out if space is still connected to the tree
			[size map <head>]         <- extra words to cache, separate block because it's much easier to work with (e.g. as argument to `set`)
			canvas drawn values ...   <- values of those words, whole group repeats
		]
		how many times allow canvas to repeat? block is efficient up to 4-8 canvases, more should be converted to hash or controlled
		for now perhaps just an assertion if it's longer, so I am warned and can decide
	what if cache is off?
		such spaces don't get generation number or name, so can't have timers
		grid is an example - not cached, still can have timers as children? no, because it's not traceable anymore from the root
		either I use a separate /cache? on/off flag, or /state to hold name & generation, /state makes more sense but occupied by switch
		not so many synonyms for state, perhaps /info for internal data? or /internal ?
		both are too good names to claim
		/frame-info /frame-data /last-frame
		actually, none of that works because if space is marked as 'cached I no longer know if it's live or not
		I could look up 'cached spaces in their parent map though to double check
		oh but for 'cached I will have both generation and fence! so no problem at all
		/last-frame: [name generation 'cached/drawn]
		removed name in object model, now:
		/last-frame: [generation 'cached/drawn]
	this revives the question: should /map and /size be in the space object, or in the cache?
		I hold /drawn in the cache because it's mold output is huge noise
		I hold /size in the object because it's often accessed
		/map is in the middle, it's used for traversal, hittest, it's also needed to persist even if cache is disabled (as well as size)
		/content is not used for traversal because it's *all* items, not visible items, so not UI-related and may be a func in the future
		for object model: makes sense to also expose /drawn? or pointless?
			it's not gonna be accessed anyway, the only value is if one wanted to inspect it, but then one may call render
		is there a point in having /last-frame instead of /frame-generation + /frame-state ?
			0-4   field object = 424b >106b/field
			5-6   fields = 728b       >121b/field
			7-8   fields = 1868b      >233b/field
			9-16  fields = 2428b      >150b/field
			17-33 fields = 3500b      >106b/field
			so 106-250b/field, with an obvious anomaly around 7-8, maybe worth reporting
			min. space with last-frame is 7 fields, so already in the big area
			block is 28b + 16*number-of-values (5 values block fits 108b)
		so there's a point
		and maybe rename it to /internal or smth? in case I later want to extend it
		may even put cached fields into /internal block, leaving /cache to be a simple logic/block
		may even make /cache class-wide, saving some more RAM?
			block of words will have to be bound on each cache fetch though, but may be worth it
			but it's hard to achieve, need some modifications to the class declaration or what
			besides, grid-view disables it's window/cache at runtime, not for any other windows
		/cached - better name than /internal? less extensible, but still okay
		both /size and /map are also parts of the frame techincally, but I'd rather not complicate access to them
		/cache will not be logic anymore, but `none` to disable it: then I don't have to give meaning to 'true'
		how to avoid invalidation during construction, if /cache is now legally a block?
			will check /cached/-1 for now (which should be drawn/cached word), more reliable than /owner
	and another one: should I still be using words, or /type: name inside the object?
		I could rewrite `probe` finally.. could even write per-class variant of it
		such /type could reference the object itself, so it will be easier to construct paths using it
		#4118 is a good test for such probe
		what's stopping me is e.g. scrollable/thumb and field/caret are both of rectangle template
		if I make /type: 'thumb and 'caret, that would mean possibility of writing `view [caret]` which makes zero sense
		while `view [rectangle]` is somewhat adequate even if not useful
		OTOH, I will have path access
		and can solve that by `make-space [name: 'thumb]`
		a bit dumb having `thumb: make-space [name: 'thumb]` from DRY perspective though - it has two names now
		need more pros and cons to decide, for now seems different but not better
	interesting note: no override in the grid-test5! because it calls /draw, not render()
		so there are even two ways to get infinite trees - disregarding override warning and avoiding render...
should there be dump-rendered-tree + dump-tree? since /map is only valid after render.. (dump-tree could walk across content)
available? is still an issue
	it's an out of the tree render, so it's broken styling is going to cause problems eventually
	so far it works only because list/grid are not styled as part of some parent style,
	and even then it's a coincidence that lack of host style doesn't create artifacts
	such render can also cause space data to go out of sync with the rendered frame, breaking hittest or smth
	somehow I must make it render only during tree render cycle
	available is used by roll to check how far can it roll, a few times per second, or triggered by other events
	I must make it async, so roll sets the target, and next render fulfills it to an extent possible
	roll can't change the origin directly as it is used for offset calculation on the frame
	but maybe it can "plan" a change to it, maybe even on-change can "plan" it, not allowing a direct change
	will require adding an argument to it's call :( or checking it's return value for some flag, e.g. 'revert ?
	either way will slow down everything just for this
	and it may be quite surprising for the user to see a value not being set, but postponed..
	/next-origin may be a better solution 
shit! in grid-test8 almost 3k renders...
	row x3, column x3, 4 grids by 12 cells, 3 renders for autosizing, cell+text makes two
	totals to 2592 renders, just this.. need optimizations, invalidation is extremely impactful and needs all juice it can get
	more precisely: row&column each x2 since no 3rd render, 4 grid x 12 cells (48 cells total), but why 5 renders for each text?
	and 2 renders of each text for wrap to set min-size (plus parsing there)
	paragraph: min-width depends on text, flags, font, but not on canvas, color, margin
		layout depends on text, flags, font, canvas (if wrapped), not color or margin
		also if width<=min-width, doesn't need a second render
	grid fitcache: depends on content (each column on it's own or spanned cells), not on canvas
	grid hcache: depends on content and widths (changed by autofit), but not canvas height
	grid margin/spacing/origin do not affect any of that, even size-cache, just the result (drawn,size,map)
	grid pinned affects size-cache but not the rest
	grid cell size/span changes affect fitcache of that column and spanned, hcache of that row, size-cache
	so 1st and foremost, space itself must be able to handle invalidation and track what needs updating during render
	invalidation should pass the child (cause) to the parent, so it will know the scale of invalidation
	grid may have to use hash to locate the cell that caused it
	but how this will work with render and it's canvas-caused invalidation?
	content changes affect all canvases, but canvas changes may carry over some parameters
	so on content change I must ensure nothing is cached by render itself, or it may override grid caches with old data
	effect:
	content (incl. cell size, but not color) => drawn, map, size, size-cache/size invalidated, but not size-cache/bounds
		hcache of affected row(s)
		fitcache of affected columns (need recovery of it from partial invalidations)
	cell replaced => same as content change, + ccache entry (should be done by wrap-space automatically) ;@@
	(need a hook in wrap-space perhaps)
	cell color => just the overall drawn invalidated, but not map or size or anything else
	cell content changes, but not size => same as color
	margin/spacing/origin of grid => only drawn & map & size & size-cache/size, nothing else (origin doesn't even affect size)
	(how to handle? invalidate 'size without a child? then what if full invalidation is needed? another scope? or invalidate-tree?)
	span => hcache of all affected cells, size-cache/size but not size-cache/bounds
		new autofit result => new hcache (no need to invalidate, autofit will do it on it's own)
		no autofit => no further changes
	(let set-span invalidate affected cells)
	canvas width =>
		new autofit result => new hcache (no need to invalidate, autofit will do it on it's own), size-cache/size, map, drawn, size
		no autofit => no changes
	canvas height => does not affect grid, affects grid-view(scrollable)
	(let draw handle canvas or dispatch accordingly)
	so: need distinction between size and appearance changes in children
	can this all become some global structured laziness with dependencies?
	how will grid know if just canvas height is changed? it can parse it's own cache..
	so invalidate/info space cause scope where cause is child and scope is 'look or 'size
		(primary call may have child=none)
		default invalidation is 'size
		cause must be an immediate (not deep) child (so parent space can find it in the map)
	'look invalidation means all parents will also have only look change, while 'size means all parents sizes are in question
	on some level 'size can become 'look if space knows it's size won't change, though it's questionable if it can
	should there be 'size/x and 'size/y ? is there a benefit in that? even for `list` I don't see any
	I should not invalidate data asap, rather should make an invalidation sequence that will be executed by next draw
		because e.g. absent hcache may call calc-row-height and that will cause an out-of-tree draw
		and result will not be valid anyway because it's not what's currently rendered (visible) on the frame
		affected: hcache, size-cache, map, size
		won't be needed until next render: fitcache
		OTOH, maybe I *should* let these funcs work on new data, while map preserves the frame? but out-of-tree is a problem then
		another problem is invalidation during render, e.g.:
		- cells are added into content by data access
		- data access is made by maybe measure-column
		- which may invalidate all the rest
		to ensure it doesn't, new cells should not be connected to the tree (so they have no /owner yet and cause no invalidation)
	should I bother caching drawn & map in the grid? not until proven to be required I guess
so the origin problem...
	I want it to be clipped inside scrollable/draw only for draw purposes
	this would eliminate the issue with zero-sized window affecting it during tube render
	(the issue results in inability to scroll down when it should still be possible to, not sure why,
	but likely because content(window) size becomes zero(multiple of zero canvas) and origin gets clipped within 0x0..0x0)
	idea is not to affect real origin, only the one being drawn
	but that breaks with grid, as grid-view/origin must be pushed to grid/origin and affects:
	- where pinned cells appear
	- what cells are even drawn 
	(inferred by grid from it's origin and /window passed to it by window/draw, which is based on window/origin and canvas)
	moreover, to clip origin I need to know content's size
	but I only know it after content's render, result of which depends.. on origin
	catch-fucking-22 and one of the trickiest design problems
	maybe content (window) can adjust the origin of it's own content (grid)? no
	maybe content (grid) can adjust it's own origin during it's /draw?
	...so I decided to clip it in the event handler itself, where it's guaranteed that space has valid size (not an intermediate one)
	one should use /clip-origin instead of setting origin directly when one wants clipping
	one trouble: when dragging by content or empty space, roll changes origin asynchronously
		and thus the idea of using origin as a point of reference doesn't work
		so instead I'm now just resetting drag offset every time I react to it
	another trouble: when dragging grid by content, the original cell may get out of the viewport
		then it's not in the map anymore, but while LMB is still down, hittest/into expects it to exist there
		I suppose a simple fix would be to clip the path after the window, or even grid-view
		but that breaks another thing: dragging keeps the path given to drag-start, so thumb dragging is no more
		so the "fix" would be to clip the path only if it doesn't land on a scroller
reworked (inf-)scrollable's sizing but now inside the column it's as if on an infinite canvas...
	doh! it's my min/max logic which is wrong..
note on grid/frame/cells - why it's a hash of period 3:
	(at least in the current model where space names are kept outside space objects)
	need to lookup name by coordinate - so I cache them all and can render the *same* cell (persistence)
	need to lookup coordinate by object - so I can tell the cell where it's located (e.g. to determine if it's pinned)
	if I only hold objects and make new names every time I want to render them, then it's not persistent
	even simple button click (in a cell) results in 2 redraws, and cell clicked is not the same word as cell released
	which makes hittest's into-map fail as it's looking for the same word in the map 
how is page size defined?
	dumb way for scrollable is to use it's own (viewport) size, minus maybe scrollbars
	but in case of some grid cells are pinned, I should subtract their size, which is complicated
	perhaps, just 80% of the page for now?
	and line size, what is the line size, who defines it? 10-20px seems okay but hardcoded
how to determine whether scrollable should allow dragging by it's content
	or it should let content handle the events
maybe instead of origin/on-change make grid/origin a function accessing grid-view/origin?
	grid needs to detect the moment of change and invalidate itself, but that's solvable
	main reason not to do this is it's working as is anyway, and function will only increase complexity
no need to cache spaces where /draw is not a function (optimization for timers)?
	actually, style itself can evaluate any code and even replace /draw block, so this doesn't work
	timers' cache is simply turned off for now
out of tree renders problem located in list-view:
	list-view uses it's own height estimation (e.g. locate-line), which renders it's items
	while final items are rendered by list
	so list-view misses window/list part which is bad for styling
	how to solve?
	why is locate-line needed? called by list-draw (in-tree) and by available (the culprit) which is called by roll!
	shit.. makes sense.. roll is known only by inf-scrollable, not the inner container
	I can't call 'roll' from within content's /draw, because I've no control over content, generally
	will have to spoof the rendering tree then, make it look like it's deeper
so `roll` now postpones `available?` until /draw
	and /draw requires invalidation, and that happens 4/sec for every grid-view/list-view
	is this heavy?
	grid should still be cached, but reality is it calls both window/draw and grid/draw, wtf
	right.. commit/cache is never called on grid because of /window xy1 xy2 usage
	window itself is never cached in a grid
	so for inspector (and alikes) it's a heavy solution
	I could split `roll` in two parts: one (sync) detects nearby border, another (async) calls available
	but then near 0x0 (which is almost always) it will slow down
	then next acceptable solution is to spoof rendering path?
	problem with that is while styles are going to be applied for the final item (grid),
	all intermediate styles will be lost, even those applied by `host`
	so it's a half-measure too, but perhaps the best one, realistically
	plus, only font may affect the sizes of children, and not draw font, but real facet, so it shouldn't even matter
	from grid-view/window/grid structure's POV, spoofed rendering should work fine
	plus, it has an important role of not setting the /owner facet to `none`
	let event handlers pass their path into roll, which requires it from now on
new mold principles (or rather form? `?` and `??` will use it for human oriented output):
	depth-dependent: big items are expanded fully at top level 0, into single line at level 1, and are not beyond that
		should have ability to turn that off? need to be able to save draw blocks to compose later
	item grouping in lists: same item, same type
	ellipsization of long values within a single line (lenght depends on indent)
	mold/part for big things to avoid delays
	controllable molding of object's fields? or general principles are enough?
		might wanna format /draw facet...
		output of space at level 1 must focus on it's name, size
	ideas how to make mold output loadable, yet readable:
	- use issues to denote constructed values: #object #map #error (no literal maps)
	  then plug in some construction macros file
	- use generic construction syntax, e.g. ##[code] - ##[construct/only [...]], ##[make map! [...]], ##[func ..] etc
	  extra bracket level is unfortunate here, but it's more flexible
	  perhaps only with /all refinement, and use just names object/map/error normally?
as expected, cache causes problems (in glossy-test):
	parent column gets fetched from cache on big canvas, while children aren't affected
	and they were previously rendered for smaller canvas, so their map & size are invalid
	so invalidate host/space is a bad idea
	it all only works if invalidation comes from the deepest child that causes it
	on top level full invalidation is required
dragging and tree modifications - tricky!
	on-down calls 'start-drag' expecting later on-up to call 'stop-drag'
	but if before on-up (e.g. in on-down or in on-dbl-click) the tree changes, drag-path becomes invalid
	and system is locked in permanent dragging state
	how to solve?
	somehow keep visiting spaces in drag-path?
		they're not in the map anymore, so I don't know their offset/size
		maybe pass `none` as offset or some default (0x0?)?
		0x0 seems most innocent, given that that space is no longer visible anyway
		although, children may translate that 0x0 and get arbitrary offsets.. but it's still okay 
	some global call to stop-drag?
		but how do I know it's on-down that started dragging? maybe UI does it on RMB?
	fall back to visible hittest path if drag-path is invalid?
		may cause quite unexpected events flow
	avoid tree rendering until dragging is complete?
		out of the question, too limiting
interesting bug case, took me some time to figure it out:
	in resize-test, reactivity ties some space size to other space's text facet
	when I fetch [size map] from the cache, after setting size, text of other space gets changed
	this triggers invalidation of the space I'm fetching from the cache
	and leads my cache source to become cleared, and I'm attempting to set map to none, which fails
	how to approach this?
	set-quiet is obviously not an option here, since /size is watched
	forbid invalidation temporarily? will not update the text on next render
	always compare /text ? not so good performance-wise
	delay reactions? might work
	and in the demo itself, ofc I should use `maybe`
transition to objects from words:
	1st problem: tried /type facet but it's hardcoded in View: `base`, not `host`, will rename style to `base`
	every path now - should it still contain words (taken from /type) or objects (specifically molded)?
	and map? where should I draw the line between words and objects?
	I'm afraid if I put objects everywhere, and mold as words (e.g. paths), it will become even more misleading
	OTOH, would be nice to have some path access
	what do I need for path access? just /content? and that will require /type facet
	also would be nice to get rid of `anonymize` (extra RAM and GC load), but how?
	(one-word object is 424 bytes, average 8-word space is 1860 bytes, so that's ~25% overhead for items in generic containers)
	if I use words in paths, I need them to resolve to objects
	so this kind of half-here half-there model is crippled too
	also style and event handler maps are always accessed words, which require path conversion from objects
	but those paths don't require binding, so at least no extra allocations come from it
	events(hittest) and timers should use objects in path or they will take a performance hit:
		path of words will require as many objects
	should traversal functions still output words? I'll try objects there too for more speed
	form causes issues too.. runs out of memory on some recursive space... so will `to string!`
	do I have to rewrite these two as well? what a mess
	mold itself is an issue: I have to write mold/compact even in interpolated messages...
	maybe make /compact a default and /deep for full dump? 
	another problem: even if I change `form`, I have to change every compiled function that uses it
	e.g. rejoin, but it calls `form` indirectly from append's R/S code..
	nah, this becomes just way too much and too disruptive
	if I make words for paths, what do I lose?
	either I re-anonymize them all on every hittest or timer event (plenty of those, big overhead)
	or I should anonymize /style during space creation, still paying the overhead but only once, while it's cached
	event handlers will still get paths as words and need a `get` to access the objects
	but I at least get path access
	let maps use words as well? the only change will be /content type?
	maps with objects are harder to access:
		forth-arrow-geom: select/same map space/forth-arrow
		back-arrow-geom:  select/same map space/back-arrow
		band:   scroll/size/:x - forth-arrow-geom/size/:x - back-arrow-geom/size/:x
	compared to:
		band:   scroll/size/:x - map/forth-arrow/size/:x - map/back-arrow/size/:x
	but putting words into map will require anonymization, which is undesired
	OTOH, a lot of (select get content 'size) become just (content/size) which is great
	this stupido morono triggers host's on-deep-change when I repend something to grid/frame/invalid !!!
	(because I changed /space from word to object..)
	now that's a performance hit! and I only found it because there's some bug in there
	(fixed by avoiding face/on-change call for /space)
	worst of all, there's some mold heisenbug that renders `[]` as `[^/]` sometimes, at random!! impossible to track
		okay heisenbug fixed..
	should menu DSL accept words as existing object names, or as template names?
		main point was to have explicit `<->` there, which is a template name
		OTOH for most template it's pointless - without data they have no value, so existing objects make more sense
		if <-> becomes an "existing" global object it gets shared and messes up the cache
		I could first check for existence, then check for template name, but it's easy to break
		(e.g. by redefining <-> to something else, an op maybe, while it was meant to be a template name)
		could menu DSL be a superset of VID/S?
		maybe let inlined objects be existing spaces, and words be template names? makes most sense
		also ;@@ it should be possible to extend just-word-template-names support to more complex VID/S expressions
	cache is another memory consumer - since I'm using an object for each cache
		should be possible to replace it with block
		[valid/invalid fields... cached-values...]
parent vs owner, type vs style
	although I can't override /type of a base, it occurred to me that style can still differentiate between hosts
	either by introducing a custom facet or by comparing the base for sameness to known bases
	so it's solvable
	besides, "style" name is already very overloaded with meanings
	/owner is 1 letter shorter, but not critical otherwise
	and /type and /parent have a value of code reuse between spaces and faces, so I'm renaming these to /type and /parent
in single parent model, do I still need a map?
	could have just assigned /offset to children and kept /pane
	I do need it because map/space/size <> space/size, as map is expressed in parent's coordinates
	I still do mix these two sometimes though, by mistake
cache creep/buildup
	tricky thing is, invalidation (esp. deep) might be missing (on resize?) and cache will accumulate old canvases
	I could clean it up but idk after which length: e.g. space within row within column may use 9 slots per frame
	so I have to add generation number into each cache slot, then on commit - walk over it and clean up
	current and last generation (previous frame) should be enough to keep it fast?
	what if cached previouosly space now gets drawn again but not due to invalidation, but because it's given new canvas?
	I could leave infxinf and 0x0 canvases and infx0 or 0xinf, but rest is likely outdated
	for less load, maybe should only clean it up after some length threshold? undecided yet
	unfortunately now I'm iterating manually over the cache and hash will bring no benefit either
	in very deep layout this may become a problem 
so markdown reader
	images - will cache them to not read the same files again (GC requirement)
	gifs - not supported by Red yet, will be static
	file - will stat it once in a while and reload if changed, relaying out the widgets, keeping the origin
	will work by translating .md into a vlist (VID/S code) of: grids, text (code), and high-level paragraphs
	should remember it's last geometry in config file
	also I'll probably make it a GUI tool, not CLI, to get rid of the terminal
		so will need an UI: empty window, dialog to open md file, can be closed, maybe multiple tabs support too?
	html tags to support:
		&html-entities;
		block-level tags - should be separated by empty lines to be recognized, otherwise they're just text:
			pre blockquote table header footer ol ul hr li dt dl dd
			full list here: https://www.w3schools.com/html/html_blocks.asp
			don't expand markdown within these paragraphs! but inbetween tags - should!
		inline tags:
		img src= width=
		details+summary
		h1 ..  
	md feats:
		# .. ###### - headings
		=== --- - headings
		`..` - code
		`` .. `` - code
		*italic*, _italic_, **bold**, ~~strike~~ - not sure if these need spaces around or work intra-word?
		\^/ - to force a newline
		[text](link)
		![image-text](link)
		:emojis:
	TOC variants: github gitlab gitea, but probbably no need to support it yet
	or maybe generate toc automatically? should be a separate app I think
	links:
		https://www.markdownguide.org/basic-syntax/
		https://daringfireball.net/projects/markdown/syntax
		https://gist.github.com/seanh/13a93686bf4c2cb16e658b3cf96807f2
	fucking tricky this markdown parsing..
	so:
		found https://github.github.com/gfm/
		https://spec-md.com/ is better written though not GFM specific
		block-level html should end with empty line (doesn't have to begin) otherwise it becomes text
			everything until the empty line is part of html
		grid should be separated by empty lines from both sides or it becomes text
		``` switches to code mode and back, interrupts text
		heading needs not any padding, breaks text
		up to 3 spaces before anything, else switch to code
	what to trim? only code is not trimmed
	state diagram:
		blank -> text code heading grid html
		text -> code heading
		code -> text
		heading -> text code
		grid -> blank, otherwise commit as text
			preliminary grid is a sequence of |-lines
			any invalid grid should be committed as text too
		html -> blank, otherwise continue as html
I wanted for rich text to accept both strings and spaces first
	but I need to wrap links as well... or maybe auto-generate links from urls?
	and relative urls make dynamically with `as url!` ? might work!
	may support more datatypes eventually
	also want wrapping on for links (if they span many lines)
	but then they'll be rectangular and will have empty space after
	still worth turning it on? or split them into 2+ separate links, one per line?
	perhaps I shouldn't split links at all though... will be weird seeing it begin on one line, end on another
	what about code? I don't want to wrap it, but clearly most md renderers wrap long code strings
	it's bad look either way, but if I split it by words, I'll have to style the background with respect to adjacent spaces
	as a workaround I could - if code is longer than the canvas - make it wrap and set limits/min to canvas/x
	so it would go to the next line, but will become a box - might be even better than the usual spaghetti
	spaghetti support would require upper level style to paint the background
	not something hard too, but will abstain for now
rich-paragraph design	
	I'd like to have a 'fill alignment in it, but it's tricky...
	I could use weight>0 to stretch text spaces themselves,
	but I can't stretch the text proportioally without altering the kerning (and manual kerning is too slow and imprecise)
	old trick: I could make each word a separate space with `stretch`es inbetween, would that work?
	even better, if that worked, I would not need to split the text in any other way
	might be slow, but we'll see.. it has a benefit of no tube prerender requirement
	a bit of a trouble will be to provide selection across multiple spaces, but it's a must anyway
	ahh.. but I need spaces to be nonzero, meaning I will have to add stretches there, with min size
	good thing is that space size becomes normalized (double spaces equal single) 
	so:
	- text is split by words
	- fill alignment needs `stretch`es inserted to work, except the last line
	  I can add a stretch after the last line with weight= 1000 to suppress the other ones
	- min stretch size will be determined by the measured space size
	  but in what layout to measure if adjacent fonts/font-sizes differ?
	  makes sense to use default text, but need at least one string then in the items list
	  if no string? maybe just render an empty text space and measure it?
	  but without a string, I can't know the font size, maybe it's all big images
	- to optimize other than 'fill alignments I could split them at line granularity
	  but this will require trimming of long spaces into single ones
	what about spaces between text and other stuff? e.g. image may stick to the text?
	I suppose the parser should save all spaces as they are (except at paragraph's head and tail)
	paragraph layout will then use info about spaces for stretch insertion
	new problem: how to carry text flags into rich-paragraph? (coming from emphasis in markdown)
	perhaps just insert flag blocks before the string? or support rtd-layout syntax?
	rtd-layout is slow though I might implement a subset of it
	key is: links consist of rich content too, but need to carry the color and underline
	so it makes sense to use rtd flags..
	I guess I'll just use refinements as flag toggles, no stack, no alternate names, etc
	what about color? tuple to set it, but how to reset? #[none] too generic?
	words can be reserved for now, maybe I'll find a good use later
	but how to make link underlined if it includes spaces? maybe don't split it by words, only by spaces?
	if I want it to be wrappable, I'll need to split it on line granularity and leave alone otherwise
	or alternatively make my own underlining style that crosses stretch-regions (benefit: fill align includes links)
	then I could use this style also to make code wrappable
tube has an issue with markdown
	sometimes I'm using long strings (e.g. in code) - this makes tube very wide
	and paragraphs wrap at it's big width, making it all unreadable
	options:
	- I measure big items and wrap them into scrollable, before using tube (in rich-content?)
	- I wrap all code and images into scrollables with limit that of the canvas (still doesn't defend from huge words)
	- tube respects canvas when it's smaller than longest item, but still reports it's size as that of max item
	  since tube is very general algorithm and it may be inside a scrollable, this is not an good option to enforce this
	  scrollable should deal with stuff sticking out of the tube
	  (canvas is usually limited inside a scrollable, not infinite, can't be used as a hint)
	- I set /limits to the tube itself to that of the canvas, so it can't stick out
	  but then I won't be able to scroll and see the big lines, as tube is narrow now
	  what GH does is it wraps even code, gitter OTOH uses a scrollable (GH way is preferable)
	  still doesn't work.. need to make tube respect limits more than it respects the canvas
	  but if it does, it becomes smaller and I can't scroll over it.. shit
	  image by design doesn't try to downscale to the canvas, else no point in having it in a scrollable..
	  so I'll fix it by setting image's max size to the window, for now
how to handle newlines?
	tube has no notion of carriage return, so rich-content cannot make it go to the next line
	what however if I insert wide space of zero height in place of newlines? might work
	otherwise I would have to split paragraph into multiple tubes, which is unwelcome, will hurt selection continuity etc
also space-as-stretch has a flaw: such stretch may be pushed into a new line, making line start with a space
	I'll need special handling for these, measure rows, turn split stretches into carriage returns
	maybe two styles: linebreak and paragraph-break? shitty names.. linefeed and linebreak maybe?
I guess no way around measuring each row...
	also I can't just pass url to rich-content, because I lose the link's destination
	but if I pass a link space it won't be split, besides I need to pass a mix spaces and text with the same destination
	I may use url for destination instead!
	how to reset the url? pass empty one?
	or use blocks for both color and url? but not for flags?
	e.g. given a link [follow `me`](target) I pass:
		(as url! "target") [(link's color) ["follow" (code space /text="me")]]
	how do I construct a map then if text can be partially split?
	besides one day I may want to focus the whole link (interactivity), that is focus frame will span the line break
	this can only work with custom /into: logically all content will be a single line, however rendered as many
	such link will be a container (`divisible`?) for other (indivisible) spaces,
	because other spaces won't know how to render a focus frame that is split into lines
	not sure how to define coordinates between spaces (considering 'fill align) and between lines though
	maybe area outside spaces falls to the rich-content's canvas, there's "nothing" in it
	clicks will have to leverage some tricky logic to determine on what line it lands, to place a caret
	selection must be able to include/exclude any space though
	I guess stretching makes it harder, otherwise space could be literal, but with stretching it has to be a space
	editor will need to map such caret location to it's internal data,
	and it may pay to split strings into chars for ease of mapping
	vocabulary:
	- chars will constitute text content
	- spaces - other content
	- blocks will group chars and spaces into single items from caret's perspective (up to the user what and when to group)
	  blocks will also act as a stack for attributes
	- parens will act like a stack for attibutes (color, link target, flags etc) ?
	  on flags: test `xx*a**bb*cc**dd` shows that I can't turn italic on, bold on, italic off, bold off (result: `xxa**bbcc**dd`)
	  also: `xx_a**bb_cc**dd` results in `xx_abb_ccdd` - seems that underscore can only start emphasis after a space
	  tried `xx _a**bb_ cc**dd` too but it doesn't recognize ** as bold marker, nor does `xx _a**bb_** ccdd`
	  anyway, means that markdown attributes are stack-like, which limits them but makes sense
	  so paren works for attributes, although no so great for caret...
	- another idea: word enables a flag, refinement removes it: bold .. /bold (html-like)
	  set-word: value sets color or command or other facet, and set-word: none unsets it
	  but this is bad for caret too, although at least shallow, but set-word is a complication when walking back
	- perhaps each item should be either char with no flags, or paren with both char and flags block, but this is expensive
	  first idea (of parens) was better, just needs more advanced caret to content mapping
	  and why paren? use the block - just wrap each char with it's metadata
	  benefit of this model: can easly cut selection, paste somewhere, no parsing/reconstruction needed
	  drawback: need speedy production of rich-text flags, incl. application of flags during measurement phase
	  so, if I use this model, my final rtd ranges will just be replaced wholly on every change to be efficient
	  plus sameness is used for consequential items, when copying flags are also copied
	  if I use ranges, on every modification I will have to scan them all and probably split, leading to even bigger mess
	  if I use linear structure with attributes mixed with the text,
	  every change will have to scan the whole thing to produce proper in/out attr changes
	  both linear structure and isolated one seem to be of equal complexity, ranges are more complex
	  but linear wins in RAM usage and easier to build, and as long as I can cache the parsing result, it should be efficient
	so, linear is chosen then, only need to find a syntax for it
	rtd-layout's syntax may be fine for range generation, but I'll need only a subset
	grouping isn't so great when you add items: need to split the whole stack of groups if attributes to be pasted too
	linear structure is better, but need to keep track of all flags and figure out which ones to alter
	also should consider removal, e.g. `"a" b "b" /b "c"` -> `"a" b /b "c"` (need to get rid of b /b)
	in more complex case it may be `b i /b /i` - to avoid this, attribute on/off order must be maintained as LIFO  
	syntax:
	- char - single text char
	- string - works as if a sequence of chars
	- word (bold, italic, underline, strike) enables the attr (no need to support alternate spellings I think, but can be added later)
	- refinement (same) disables it
	- set-words take a parameter:
	  color: tuple or word (maybe issue too), /color removes
	  backdrop: same, /backdrop removes
	  size: sets font size, /size removes (back to default)
	  font: sets font face, /font removes (no font)
	  command: sets click action, /command removes
	- paren reserved for now
	- block groups things into single item for caret, automatically providing stack of attributes
	  though I may implement this later
	  ;@@ add url! to syntax?
	  ;@@ DOCUMENT SYNTAX AND RICH-CONTENT ITSELF
	ranges may be created either for the whole, and then split into individual faces (easily, by subtracting caret from them)
		then whole set of ranges changes with content change but not with canvas
	or can be created per every text sequence, but then sequences will change with canvas, and require reparsing
	ranges will have groups unrolled, because it's not caret offset anymore but char offsets for the richtext face
	parsing results in global set of ranges then of the syntax (prefixed by pair for range, mostly aligns with internal rich-text format):
	- word for flags
	- tuple for color
	- 'backdrop tuple for backdrop
	- integer for font-size
	- string for font face
	- block for command
	when drawing on given canvas, spaces will be created and flags applied
	will need a lower-level text space, `text-span` that allows to control flags fully?
	or better: if flags block starts with a pair, it's not processed?
	what about clicks? I want clicks on spaces between words to work too
	do I need to create text spaces for text regions? they should not use the general `text` style
	nor there's any sizing magick that should be embedded
	so the only reason to create them is to have them in the map: any benefits?
	on click I need to translate coordinate into a caret offset in the initial high-level spec
	so need to have a map of item indexes mapped to boxes on the output layout
	but blocks may span multiple lines and be a single item,
	so boxes will not be on the final layout but on an unrolled layout (single row)
	and there will be a block of row lengths
	I don't need events on chars to be handled outside the rich-content, only events on spaces that appear in it
	so no need in the map for text
	but cache will include row sizes (lengths and heights), boxes (pair x ranges of each item are enough)
	so the only reason for not using tube (save for speed) is links that span multiple lines
	but here's another idea: tube-like space that wraps it's content using draw facilities
	(using clipping render the wrapped child twice: once on the right, once on the left)
	however it should wrap on whole words, not just any place, not in the middle of a char
	so I will need to give it a set of offsets where wrapping is allowed
	I also will need to give it offsets where stretching for 'fill align occurs - how?
	or instead just scale the row? indeed! seems much less complex and not worse visually
	may even be used as a feature - like some magazines, banners etc
design issue/question in paragraph layout:
	if it's not left-aligned, e.g. right-aligned, to what margin should it align itself?
	normally I would contract the final size if it's less than canvas
	or extend if it's bigger than canvas
	but in this case, it's tricky
	1. left-aligned paragraph with a huuuge word that will certainly stick out
	   I want only that word stick out, and then full size extended to it
	   but other words should wrap properly at canvas, not at the huge word
	2. center-aligned paragraph with a huuuge word
	   if I center everything around half of the final size, likely only huge word will be visible
	   although technically it's a burden of the container
	3. right-aligned paragraph with a huuuge word - same thing
	   I could align around right canvas margin, but that would be an unexpected mess
	4. fill-align, huge word - will simply zoom out the word, this one is the simplest
	5. center-aligned, smaller than canvas, fine - centered around real center 
	6. right-aligned, smaller than canvas, no so great unless container itself also right-aligns it
	   ok that's the key then, container alignment should be the same as paragraph alignment for good result
linebreaks are giving me real headache
	paragraph layout is space-oriented, it doesn't know anything about text
	rich-content is what parses text and fills linebreaks, inside /draw to avoid out-of-tree renders
	however spaces are created before /draw, when /source changes (otherwise every /draw will have to parse the source)
	and those spaces must already be free of linebreaks
	because each space is thought of as a band, and each break is it's width so far consumed, which cannot just reset on linebreak
	so the only option left is to have linebreak space which gets special handling in /draw (needs it's size set)
	but then it leads nowhere too, because if linebreak width is set canvas width,
	some line can be huge, bigger than canvas, and linebreaks will accumulate on a single line
	another issue: 'fill has to ignore lines before linebreak space
	I just hate making so many special cases - is there a better way?
	perhaps I should consider linebreaks on a lower level
	or using block of blocks for content
	or instead of linebreak I just spawn a few layouts, one per text line, from a single draw call
	hard because /items won't work with that, and /content needs a model change
	easier to make a special case for 'linebreak (or just 'break ? from rich-paragraph/break it's use will be clear)
	also rendering multiple lines as multiple layouts is a performance waste
	maybe special <break> marker instead of linebreak space? lighter and foolproof
	on the bad side: tag cannot be a result of lay-out, so cannot be added inside VIDS
;@@ need to doc breakpoints format, rich-paragraph and rich-content, and break too
;@@ add rich test gif to tests?
rich-content and selection:
	selection cannot be a box, like in field, because it may span multiple lines
	I can only visualize it using /backdrop color (which is what everyone else is doing anyway)
	it will be up to the user to use backdrop attribute in his own spaces, as only generated text is supported out of the box
	I can't also turn item index into a box - only into two separate vertical lines (because they may be on different rows)
	OTOH maybe I could make selection a box, just it won't know... hmm.. it must simply be painted alongside the other spaces
	but how do I draw it? if it has a size it will shift the other spaces, if it doesn't how will it itself know it's own drawing box?
	I will need to get caret box of left and right selection margins and set selection size to the rest of the last row + start of next
	both caret boxes and corresponding rows
	a bit of an issue is that rows have differing height, but selection is a box
	in this case should I scale it vertically? should I set it's own height to that of 1st or highest row?
	most likely selection will have a frame decoration
	what browser does is simple text backdrop + overlay on images (there are even visible gaps where there's margin)
	but box may just be better looking and more customizable, esp with advanced styles
	using lowest row and no scaling seems safest from weird artifacts
	(e.g. big image makes the row high, selection scales 10x and frame makes text illegible)
	or, I could use highest row and no scaling - for frame-less selection, with some texture on it
	(lower rows will just have it clipped)
	or selection could be just a pen, but that'll work like highest-row/no-scale, just more limited
	I'll take the lowest row as default, and maybe later an option for highest row
	or there could be multiple selections rendered (one per row) at draw time, not reflected on the map
	but then they could not be accessed via path like rich-area/selection
	so I will have to move any facets out (if any)
	perhaps it is the best choice?
	why I might want to reflect selection on the map is drag-n-drop content moving (common shit, need to start drag on selection)
	OK maybe it should be on the map (each selection separately), or anywhere as long as /into dispatches into it
	but how should it dispatch if selection is overlaid on the other spaces?
	maybe /into should prioritize selection? then I won't be able to click on it to set caret there
	or maybe /into should ignore it, and rich-content should just match clicks against /selected range
	;@@ will need a flag for start-drag to not lock the path, so drop may land into another space (e.g. other rich-area)
	api:
	- map xy to offset in rows/row (may be on an empty row or it's tail easily - so depending on selection direction one can go back or forth)
	  (simpler to do backward scanning here using for-each/reverse)
	- map offset in rows/row to caret offset (left or right)
	  these both will be useful for click selection
	  such selection should be 2D: only converted into range based on it's direction, which is inferred from rowspan and dx
	- map caret offset to rows/row offset ?
	- map caret offset (left or right) to a vertical line in a row (it's 2D visible coordinates already scaled)
	  left or right because row split can occur between two spaces, or аfter a hyphen
	- map row start/end to vertical line in a row (2D visible already scaled)
	  or better full row to it's visible box (scaled compared to it's raw clip region)
	  these will be used to draw selections, to know where each row's selection begins and ends
	- map RxC into row item, R into row data, get rows count - to abstract from the block format ?
	  draw should be as fast as possible, using the raw format, but other functions may be abstracted
	shit I'm drowning in index trickery
	really need quality abstraction there
	maybe make a linear array of each item, it's box in space's coordinates and row/col and index and caret range, then navigate over that?
	then I can foreach-scan it until I find where xy fits best to get caret offset?
	need to prototype these before implementing
	tasks:
	- translate xy point to:
	  - child xy point (for hittesting)
	  - caret integer offset (for source selection)
	- translate caret integer offset to left or right caret box (for caret display)
	- figure out visual bounds of multiline selection
	  which can be done knowing the caret boxes above (or only x coordinate and row number)
	  and each row's visible box (may be inferred from caret boxes and knowledge on which caret positions rows start/end)
	  (selection should know it's real clipped size, should not stick out of the clipped region, or it's frame may get clipped out)
	- so, caret ranges for rows (excluding split separators)
	  except it's hard to obtain these, shit
	interestingly, if rows are split on 2 or more spaces:
	  left/right keys will skip all spaces at once but del/bksp will remove them one by one?
	  what browsers do is they allow to navigate over visible spaces, but hidden spaces converge into a single caret box
	  and they allow both left and right caret box even if there's only one delimiter space
	  well, not an important feature anyway
found a problem with textual VID styles expansion!
	style text: text won't work - will deadlock!
	hmm.. even if I kept the original template name with the style
	then I would not be able to create substyles like that,
	e.g. `style text: text  style wtf: text` - would expect last 'text' to be a real VID/S style then
	and if it starts expanding, it deadlocks
	so a different model must be used:
	`style new: old ...` will keep the 'old' name if it's a real style, and rest as text
	but if it's sheet style, it will use the name from that style and join the text with new attrs
	;@@ fix it!
	it has a benefit though: if some facet is a result of an expression, it gets evaluated anew for every widget instance
	(+ first time for the style itself to know where expression ends)
	but main reason I did it is to support /content - it has to be laid out anew every time, as I forbid multiple parents
	;@@ maybe I should eventually document how it really works and why
selection and invalidation
	currently rich-content when placed inside a tube, when selected will draw selection on all of it's intermediate layouts in the tube
	;@@ perhaps I should utilize invalidate-look to optimize the tube to avoid these redraws
it just occurred to me that in the browser text is not focusable, yet it ctrl+c copies the selection
	how can I copy it on rich-content if it's not meant to receive focus?
	should it always be a program's duty to provide copying? (I tend to think so, or I will enforce too much of the UX)
	or selectable should also make it focusable?
	should it have a /hint by default for right-click menu with copy option? (unlikely)
also, such browser should provide cross-paragraph selections
	obviously this will make selections appear on them all, and has to clear the rest (if any)
	so making rich-content selectable is bad idea, as it's too limited
	browser should control all the selections on it's own discretion (but I'm lazy to implement that)
	eventually it must be some markdown viewer widget with high level capabilities including selection and copying etc
	which will also be focusable anyway, as any other scrollable
usage of my own (generalized) wrapping also leads to unwanted row sizes:
	? (draw size-text r: rtd-layout [font 30 "lorem ipsum^/" /font font 20 "dolor sit amet^/" /font "consectetur^/adipiscing elit"] compose [text 0x0 (r)])
	small-font rows should be small
	but in rich-content, this is a single space split across multiple rows
	since it's height is that of it's biggest letter, it applies to all rows, and they look very spacious
	I decided to hold on splitting into multiple spaces
	I could then split by words, one word one space
	although, is it going to be worth it? likely performance loss for an unlikely text layout
	but it will create problems in rich-edit: if user adds a single big letter, all rows will become spacious
	perhaps I will expose a way to control splitting and make the setting more conservative for rich-edit..
	or.. omg it's ez: I should force split on font and font-size changes
mixed-font-size text does not look aligned, since I'm aligning it by the bottom line (and images too)
	but what can be done? there's nothing in Red to tell me where the text's baseline is
	best I can do for now is controllable /baseline facet
links in rich-content
	I have this idea: since links can contain anything - I should wrap them into clickable
	clickable could have it's breakpoints set from those of it's content
	either many clickables (one per item) or one clickable with many items (needs a list then)
	but breakpoints are only known at draw time, while content is set before that
	and draw won't be able (out of the box anyway) to distinguish my clickable from user-provided clickable
	so should it then now look into every clickable or filter them? or should it spawn them?
	it makes sense for static paragraphs to have static clickables so they can be focused, tabbed over, etc
	and from tabbing perspective whole link should be one, not split into many clickables
	so I decided each space must provide a way to split it, if it's possible
	and current breakpoints format is wrong, too complex to create and parse, even if minimal
	I need a more machine friendly format, e.g. [int logic ... int false] where logic is "mandatory?" (false if empty)
	trailing false may be used to glue multiple items together (spacing is empty) (though still needs offsetting)
	then another idea: ints will not be offsets, but interval widths, then it can be glued easily
	also it removes the problem of duplicate offsets (e.g. 0 0) or whether it should end with total width, etc
	and it removes the problem of whether it's strictly increasing, just all widths have to be nonnegative
	seems data format is everything...
	another more compact option would be to have negative widths for empties, positive for mandatory - great!
	and much faster since it doesn't need repend anymore, and it's not sensitive to head offset, so no need to subtract it
	and it's consistent around zero: it can be treated as both empty or full, doesn't matter
	benchmark of find vs parse on space splitting:
		lorem: {Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.}
		gather1: does [clear buf p: lorem while [p: find/tail p space!] [append buf  -1 + index? p p: any [find p non-space! tail p] append buf index? p]]
		gather2: does [clear buf parse lorem [collect after buf any [any non-space! p: keep (index? p) any space! p: keep (index? p)]]]
		>> clock/times [gather1] 1e4
		131 μs	[gather1]
		>> clock/times [gather2] 1e4
		96.3 μs	[gather2]
		there we go, parse		
	should rich-content itself be breakable? does it make sense to put one rich-content into another?
	I suppose it may be worth it from the POV of generality, e.g. some space is based rich-content, but may appear then in another
	should pose no problem since rich-content will unroll it's children by rendering on inf canvas
	so it's breakable if it's unrolled, and non-breakable if it's wrapped - breaks are canvas dependent, so must be cached there
	do I even want to cache them though? I guess I won't until I see the need... for now just reserve the `breakpoints` facet
	it can be a function now, and a cached block later - both should be supported/expected
	maybe a better name than `breakpoints` or `breaks`? since it's intervals now..
	chunks? parts? slices (good one)? regions pieces segments sections (good one - both hints at process and data format)
	what of list? if text requires a render to get it's sections, how can list be sure it's items are rendered?
	it's fine as long as only rich-content uses /sections but for more generality...
	technically if item is not rendered, then that's it's current frame, so it's okay for it to return no sections
	so silent none return is fine for text without layout - user of /sections must ensure previous render
	for rich-content it's a bit trickier - it needs to render it's items before getting their sections
	then render itself and provide sections for itself
	I may be able to move this functionality into rich-paragraph? layout itself? it has no connection to /source anyway
with sections, will I still need to split text on words to figure out it's min width?
	sections seem to do more work than space-splitting
	I though about unifying but I can't assume that sum of widths of each line will equal unwrapped text's width.. rounding... 
grouping multiple rich-content items into a clickable has a problem!
	each of those spaces could have spanned multiple caret offsets
	now how can I translate clicks into caret offset if internal layout is so complex?
	I think I should make clickable a single item for caret instead of complicating it
	and document that "command" attribute groups items
	the only drawback I see is that in rich-edit links will be either clickable or editable but not both
	(or I could remove first/last item of the link but could not position the caret inside)
	another option is to remember all items' logical caret ranges and use /into to obtain the final item
	but how will I know where to look for my saves item in /into-returned path? always last item = text?
	since no other space supports mulitple carets, might work
	but caret-to-box iterates over plan rows, it will have to do deep iteration, which is no good
	I could like with sections, make a function that enumerates caret locations of a space
	but hardest thing will be to make edits: such space would have to support some positional edit mini-DSL
	let it be single item for now at least
	but what to do with text offset and already committed ranges? they are all wrong after the substitution
	how badly I need to expose attr ranges to the space itself? it was never used yet
	simplest way I go over all ranges and collapse them
	all starts inside the collapsed range become it's beginning (command:), ends - it's ending (/command)
	so final item includes all ranges where it participated
rich-edit caret offsets
	I think it should split all strings into chars, so caret can be just an integer, without a need for deep addressing
	it may import/export strings then for convenience, but should not use them inside?
	or really make some caret API?
	- get caret range
	- get caret box for i-th offset
	- get caret offset nearest to xy
	- remove item before/after i-th offset
	- add given item before/after i-th offset
	same field or area space could then be a wrapper around text or rich-content or anything that supports this api
	it will be possible to e.g. place a caret between list items, and delete chars of an item and then the item itself if it's empty
	a bit of an issue will be to transform these lists/items back into source that produced them (source is needed for exchange)
and one key problem is copy/paste: clipboard is textual
	although I can't possibly encode spaces that appear in the source into text
	so it will be dual: internally hold a block, also save for the other programs as text
	but how to know if internal block is invalidated by a text copy from another program? when to prefer text over block?
	simplest check is for strict equality of last copied text with text on the clipboard..
	one could then clip smth else, then clip last text again, return to my program, and paste the block - no harm in this
	I can imagine selection that is partially text and partially a region of a grid, that is a document-wide caret addressing
	which is ctrl+a/ctrl+c/ctrl-v friendly in that it copies all content that it is able to
	although one can't paste part of a grid back, except as text, even into the same program
	another grid selection model is xy1-xy2-like, 2D
	I can also imagine partial selection from clickable links like in browsers, which also needs document-wide addressing
	keys: left key should make caret 'right', right key should make caret 'left', to stay on the same row
	caret size (height): imagine a row with small font and a single big item on it
	caret in this case may be big near the item, but small everywhere else (or it'll be weird)
selection
	ideally should also adhere to caret's height, but it'll make it near impossible to have a frame
	also with document-wide addressing, how to draw selection?
	ideally if left and right caret is the same, selection is continuous, if not then it's split
	so selection ideally is a huge lot of blocks between right caret and next left caret
	also it woule be nice if space would not have to provide any support for selection to work
	it should somehow work everywhere by itself
	but perhaps document container might take that role, to draw it, as long as it has caret boxes provided by it's children
	like this: document has a selected range, and creates a bunch of 'selection' boxes for this range and draws them  
custom caret
	can be implemented also e.g. in time/date entry (can be list-based), which may even appear in text
	e.g. a printable document form composer that allows embedding of such spaces right into the text
	carets are not a generalization of sections, because sections treat whole space as a band,
	while carets can work fine in a multiline complex space
	(though often they share underlying algorithms)
ok so what's the caret API ?
	need to:
	- know how many caret places there are (so "length" in caret units is known)
	- all left and right caret boxes for these places (or a range of, if not all are needed, or a single one)
	  or ideally just offset->box which should cache what's needed for retrieving whole box ranges fast
	- caret offset that is near XY
	no copy/paste needed at this level - can do that in the source
	so content may have e.g. a single list space, but source must contain all chars separately or expose insert/remove api
	source insert/remove/copy will also be side-sensitive
I'm thinking source dialect should be extensible
	e.g. I may add a grid representation into it, if I ever want to select/copy/insert only parts of a grid vs whole
	there's no direct conflict between flow-like selection and 2D selection:
	- flow-like will work on source level, provided by document
	- 2D will work on grid level, changing it's selected range of pairs or even multiselection
rich-edit UX copy/paste-wise
	one option is copy/paste text together with it's applied attributes (preserves everything, but needs mess cleanup)
	for that, and for text generation itself, a range extraction routine is warranted
	another option: copy/paste only text, on paste apply attributes that are there in place (simpler, discard formatting)
	third: only copy/paste attributes that both opened and closed within the selected range (preserves inner ranges)
	example: what if I select part of normal text with part of code span and copy/paste it?
	ideally, pasted upon itself it should maintain identity
	and pasted anywhere else, keep the code part as code (same with links)
	means option 1 is preferable, the rest doesn't work like that
	but what if I copy normal text and insert into the code span? should it wrap the code span? I don't think so
	so it's an inconsistency of sorts, though I can say that normal text has no attribute so it doesn't carry "nothing" with it
	then insertion of normal text into bold makes bold, but bold into normal also makes bold
	so I need copy/paste API (unrelated to selection itself and carets, only works with the source):
	- return a ranged copy
	- remove a range
	- insert stuff at offset
	what ensures consistency of these ranges and selection/caret ranges if caret offsets are up to spaces?
	only my effort I guess (and assertions at source-to-content transform)
	for spaces to handle copy/paste themselves document format has to be the foundation and they should know it
	it may be a layer between VID/S and actual spaces object tree
	but do I wanna go that far? not yet anyway
	or I could create a bunch of templates based on existing ones that accept their data in document format
	then to copy the data is just to access it
	but access will have to be deep or what? e.g. clickable/list/text/data - how does it relate to clickable/data?
	doesn't seem easier than just using rich-content alone
	but widgets that know how to source themselves is still an option to consider
	what's a better word? distill? refine? rectify? purify? vaporize? refine seems best fit, even though unrelated to /refinements
	disassemble? dismantle? breakup? deconstruct?
	these will be created by rich-content only and used within
	caret api may still be general, as it's widely applicable, while /refine will be a special feature
	although then there will be refine-able lists and unrefine-able (not produced by rich-content)
	with the same caret range, but copied differently (if at all)
	just as some user-provided space could have a selectable caret range but I won't be able to tell to copy part of itself
	looks like the only sane solution is to make refinement part of the caret api, and format should be known to every space
	I guess for now let rich-content have it's own refinement per template and later I'll probably inject it into templates?
	in line with copy/paste usage scenarios, refine will work on a range and support insertion/removal
how to name the API?
	should caret and copy/paste even be a single thing? what of sections?
	it's doing:
	- point-to-caret, caret-to-box, length - 1D/2D conversion
	- remove, insert, copy of item or many - conversion between source format and output
	sections are best left alone, due to them being band sections, while caret locations can have many lines
	in principle this all relates to editing, even item enumeration, so maybe edit-api? editable? modifiable? alteration?
	structure? access (too broad)?
	/editable or /edit makes most sense, both as a flag that it can be edited and as an interface provider
	problem is, if it's an object/map then it's too heavy for text template
	I could just link it to a generic object, but then extra arg requirement: space/edit/remove space args meh
	could be a function though, with each refinement taking it's arguments...
	editable: [/remove range /insert where stuff /copy range] or
	editable: [/remove where length /insert where stuff /copy where length]
	[/length /point-to-caret xy /caret-to-box where side]
	actually insert needs side too, though remove and copy should be smart
	(and point-to-caret may return side together with the offset)
	side could be encoded into offset as sign: - for left, + for right, with abs AxB normalizing it
	rationale is to make 'where' argument alone and 'side' specification optional (as sign, defaulting to right/+)
	right or left caret should be the default?
	suppose I made my text bold and I'm typing at the tail of it - I want bold to continue, so left it should be, to insert before /bold
	dammit, but that means using - for right, + for left? nowai, perhaps rather event handlers should use negative caret for insertion?
	also /caret itself should carry where it is shown, so must include the side and sign change on movement will make it weird
	but making caret a block [offset side] is weirder
	I could make it a float with -0.1/+0.1 shifts for side, then round to get real offset
	another option: double the offset for chars, 1 left 2 right 3 left etc
	https://gitter.im/red/help?at=6391d73f3daaa326ba75839f
	I tend to favor [offset: N side: word] but creation of these to pass an argument to editable api is baaad
started a function for editable api, but it scares me.. perhaps a DSL is better?
	editable: function [
		space [object!]
		remove [logic!] insert [logic!] copy [logic!]
		length [logic!] point-to-caret [logic!] caret-to-box [logic!]
		offset [integer! none!] side [word! none!] length [integer! none!] data [block! none!] xy [pair! none!] 
	][
	]
	editable: function [/refinements values] [~/editable ...all this mess omg...]
DSL: but I'd like to avoid compose usage, would rather bind it and evaluate elsewhere
	editable [
		remove offset length
		copy offset length -> data
		insert offset side data
		length -> integer
		point-to-caret xy -> offset side
		caret-to-box offset side -> block
	]
editing ranges is problematic: need to offset them (easy), extract (okay) and unify (hard)
	unification can be on simple flags block like in text, or it can have command block ranges which must use /same comparison
	another way is to convert ranges into source, optimize source, and expand source again into ranges and text
	but all that is rather tricky to implement
	simplest perhaps is to use item-by-item final attributes list as an intermediate form
	but then there may be multiple attributes per item and their ordering comes up.. omg
	I could enumerate them and lists of numbers are easy to order properly and compare
	but what do I do if I join two ranges with some command attr? how do I know the command is the same? need /same block - then it's fine
	but how to distinguish backdrop tuple from color tuple? it can't be a block, paren is reserved
	perhaps each attribute will have it's both name and value, in this case color/backdrop and value is tuple
	perhaps attributes comparison op should depend on attribute itself, sameness for command only for now
	too bad I can't use `union` with /same
	command: [same block]
	color: tuple
	backdrop: tuple
	flags: [bold italic underline - set] ?
	bold: true  etc? - will be easier to work with - they need no value, and I can this way avoid union on the block
perhaps to generalize the source dialect
	I need to declare every attribute as an object, how it compares, whether applies to text, decode/encode, etc.
	maybe each attr should have it's own stream decoder/encoder (for source conversion - refinement and expansion)
	(although how to efficiently parse it then mixed with other attrs? should attr expose opening as parse rule?)
	aim here is to:
	- make it general enough to separate combinatorics from the templates
	- keep source processing into low-level rtd flags fast (rendering speed is top priority, not editing)
	- allow future dialect extension, even by the user
also need simple ranges format?
	if `copy` copies refined source, then insertion of it somewhere may make inefficiencies e.g. closed then opened right away attribute
	otoh, if it copies simple data map or smth, then inserting an item (char) is tedious:
	need to find all attributes that will apply to this char and mark them for new index, also offset following indices
	OK so source format is great for insertion, just need a simple way to optimize it
	oops, not so great if I insert bold chunk into other bold chunk: how do I know to remove the /bold ?
	only by converting into raw format and back
	words, set-words, refinements, make a simple ruleset, which can be respected generally
	should I expect any deviations?
	what about e.g. grid representation in the source?
	grid .. | .. return .. | .. /grid ?  more reddish vid-like but doesn't follow attr on/off model nor decodeable
	grid row .. /row /grid ?  less reddish more html-like crappy
	grid row: 1 .. /row row: 2 .. /row /grid ?  friendly to attr decoder and `/row row` won't be optimized away
	OK here's the thing: attributes are property of text, they are copied and inserted together with it
	but structure, like row delimiter, is not property of text, it cannot be copied from one place and inserted into another
	so it cannot possibly follow the same rules, and I currently don't see a better approach to it than html-like
	(because it needs to be flat for caret to have an index, and ability to ascend from children into parents with key presses)
	(another option is using blocks and path-like caret, but doesn't look any better and cannot use flat pointer into source for insertion)
	(but blocks cannot represent e.g. "a <b> b <i> c </b> d </i> e", so they're unfit for the purpose in the end)
	(at least now I understand why html was made like this, but mixup of attributes and structure looks like a mistake)
	also, grids will have both:
	- textual copy/paste which while can copy contents of multiple cells, can only insert it as text into single cell
	- cell-level copy/paste which only copies full cells, contains info about copy dimensions
	so I better design internal clipboard format for such possibilities (use tab for next cell denotation in the copied data? csv-like?)
for ease of copy/paste processing must be stack-like: bold bold /bold /bold should work
	same for color: x color: y /color /color
	color spans need not specify which one of them ends - it's always the latter one
	although then if I select text that is part red part blue, and make it green, I will have to shift previous color: & /color marks
	e.g. I may remove the text first together with all attrs except color, then mark it green then insert at removal point
	so this still will need processing of input, else I must specify attr closure like: `/color x`
	but it's not stack-like anymore and confusing to the reader
binary looks like a good format for expanded attributes
	it can be ored (enable attr), anded (disable it) easily
	it is easy to insert/remove in (bitset is a no go since can't be addressed at bit level)
	it's compact enough (1MB per attr per million items)
	[attr-name #{mask}]
	another option is byte vector: also supports logic ops but also addition/subtraction
	attrs: [
		bold: [true #{mask}]
		color: [
			green #{mask}
			red #{mask}
		]
		command: [
			[code] #{mask}
			[other] #{mask}
		]
	]
	easy to clash attrs: e.g. colors or what command applies to this or that item
	the only issue is leading zeroes: find mask 1 may take long, so maybe masks head should be at first nonzero
	index? still will tell the real offset, then it'll be easy enough to convert into pair and back
	trim could be used to remove trailing zeroes after clashing multiple masks
	although single mask may include multiple ranges.. can it? makes sense, otherwise no point in vectors at all
	so no trim, and find is gonna slow it down - ~9ms per single 1MB find!! wow! not gonna work
	only option then is (preferably sorted) list of pair ranges for each attr+value
	what if I use vectors [start end start end] in place of lists of pairs?
	offsetting will be real fast - what is needed by on-source-change.. on the other hand I hardly will find that as bottleneck
still don't know whether to allow strings in the source or not
	using strings means direct pointers to source are not possible, only logical caret offset provided to the api
	not using strings means splitting them all into chars which will be unreadable
	although, source may contain spaces which may have length, so pointers into those are also not possible
	so then strings are not special either
	hmm.. since attributes cannot begin or end within a string or space, I could have assigned indexes based on items count, not caret
	but then how am I going to convert them into caret indexes? I'll be working with caret indexes most of the time
	maybe forbid spaces inside source? let there only be data? then I'll have a chance for source offsets
I need to finally decide whether I need structure (tags) in the source or not
	why do I need it anyway? why can't I work on widgets directly via editable API?
	on document scale, eg. 1MB of text, reparsing whole source and rebuilding whole tree on keypress is insane
	from this POV, I should edit widgets directly with API
	but whole reason I bother with ranges is because applying left/right insertion logic to RTD flag blocks is hard
	(at least all text faces will have to be serialized then deserialized on each edit, but the cost should be small)
	and I would need to apply edit differently to all the other supported widgets
	final point of insertion is not always a text space - e.g. can't insert image into it
	so e.g. for grid: such grid cell will each contain either a rich-content or a list?
	this also returns to the question of whether rich-content contains other rich-contents (e.g as paragraphs)
	option 1: source is not updated, only used to build a widget tree, and can be requested to be rebuilt
		each insertion goes into a widget - into text (chars) and rich-paragraphs/content and list/content (within command lists)
		(cannot insert into the grid or cell directly - only into children)
		insertion not crosses cells and selected data has no structure markers, so no cell info
		whole grid can be selected as one item and inserted into such list
		can only happen if selection starts and ends outside of the grid itself, so grid is a single item
		text within grid can be selected/copied but can't cross grid's boundary
		cells can be selected and pasted as cells - not handled here
		copy of multiple cells then inserted into single cell
		ctrl+a (select all) can be caught on document level - everything, or on grid level (if focusable) - to select only grid data
	option 2: copied data has structure 
		either contains widgets as they are (and pastes some smart copies - but that's hard to generalize)
		or it has to serialize each widget so it can be deserialized back into a similar widget (preferable)
		copy of multiple cells may be inserted only as multiple cells (unless explicitly processed to remove the structure)
		ofc if pasted outside of grid, structure gets removed
need to first think about structure of the document
	document contains only text and images, that's all
	it is organized into a complex tree
	option 1: paragraph cannot include anything more complex than text and images
		this rules out link spans then - bad idea
		but grids and lists become alternate leaves - either them or paragraph, but not mixed
	option 2: paragraph can include all these tricky structures, subtrees
		then each grid is also part of some paragraph
		I think this is more general and more common model these days
		leaves are only text and images, rest is branches
		top level document is a vlist of mostly paragraphs, but also grids and lists
		and maybe even includes page splitters (rows) with multiple paragraphs (like in magazines)
		it maybe even organized as a page itself, with footer, header, sidenotes etc
		it may contain also code spans (multiline ones - which are not rich-paragraphs)
		and even various game-like interactive elements (but these are not copyable/serializeable)
		so importantly I admit that not everything have to be serialized that can be displayed (or appears in the source)
		this means I either cannot (or want not to) reconstruct the source, or I insert such items into it as is, unserialized
		this is the way to go
	copy/paste on link span and code span:
		part of the link may be copied as a link or as text
		whole link should also be copied as link
		part of code should be copied as code, and formatting matters there (newlines tabs etc)
		although it's acceptable if it's inserted as text outside of code span too
		(e.g. I copy some word - don't want to make a new code span when I copy it)
		whole span should always be copied as span
		this returns to question of inside/outside selection and whether selection can cross limits of a span
		browsers let it cross but there's no wysiwyg editor with code spans I can recall..
		word processors do not let even cross-cell selection: such selection expands to full cells on an attempt
		nor they allow selection started on a grid to get out of it
		selection started outside only selects grid as a whole
		may select part of the grid and insert outside - into text - as new grid
		or into grid cell - either as new inner grid or replacing current cells (it asks what to do)
	copy/paste on grids
		on my idea of encoding grid cells with tabs and newlines for structure:
		- this will make it easy to copy from grid and insert into some spreadsheet or csv file or even as text
		- this will make it impossible to have newlines and tabs inside grid cell's text???
		  what we input as enter vs shift+enter will need to be represented in the source somehow
		  same question I have for lists, whether it's just a paragraph flag or some source notation that makes a list's item
		  perhaps use <break> to spawn a linebreak space in paragraphs, start new list items, and new grid rows?
		  may also add <br> as alias for <break> for html lovers
I liked the idea of using words as template names in the source, but if I do that I can't use words for attributes..
	still have #issues but not sure if it's better than tags (which are by their design structure markers)
images in the source may appear as image!
	but wrapping them into image space lets control their facets, like /limits
when copying only closing or only opening part of the source, mirror part should be added automatically
	(and it will work fine inside any number of other containers - as long as they are not crossed, they need not to be reinserted)
	then even part of the list item will become a new list item (that is copy must cross the item paragraph boundary)
	even part of the grid will become a new grid
	(though grid will need special logic to always include grid start and end markers,
	else if selection doesn't cross the grid, it won't be inserted as one)
	if code is crossed, it becomes inserted as code
	fine
to avoid rebuilding the whole tree when source changes I have this idea
	once parsed, each source structure (data region) will get replaced with single widget
	and further modification of that data region happens within the widget, only affecting it (usually single paragraph or grid)
	applied text attributes like bold command etc will have to be copied into this new widget so they still apply inside it
	(they will also still reside outside of it in the original source?)
	or maybe it's stupid because this way I will turn whole source into widgets and that's what /content is
ok then these are the options:
	1. I make changes to the source, let them be reflected on the tree
	   then I need to maintain ranges of each widget in the source, and each edit updates these
	   will make these ranges as widths so they need not constant modification but a little bit slower indexing
	   biggest slowdown here may come from insertion/removal time of the source itself,
	   and maybe caret mapping (though space ranges help with that)
	   worst case scenario - single 1MB paragraph as a single string... well, quite unlikely and easy to work around by splitting the string
	   same thing for 1M items of any kind, but chars can be grouped, and so many images are just expected to cause trouble
	2. I make changes to widgets
	   source is not getting updated, and may even be not a facet but an argument that is loaded to make the tree
	   each copy is serialized, and then deserialization needs to figure out how to map it into existing widgets
	   this options is scarier than the other, too hard to imagine how it works exactly in detail 
on proper UX upon insertion of grid structure into grid cell.. e.g. ["abc" <|> "def"]
	I can't insert it into "z|x" and obtain ["zabcx" <|> "def"], that is I can't just meeting a marker jump to the other cell
	I have to obtain ["zabc" <|> "defx"], and that involves moving all the subsequent cells by one
	for this to work properly I should not have any grid row separators, only grid width (number of columns)
	copying/insertion of columns though needs special handling from the grid itself...
	in any case, or at best I will be bound to row-like treatment of grid
	(btw I could encode spans as <||> <|||> etc perhaps, applying to previous content? - but this only encodes X spans, no Y)
	ideally though grid should fully handle copying and pasting in 2D mode, so row UX is not important
I just realized that structure tags in html cannot intersect: they have to be closed in LIFO order
	while tags like bold italic can easily intersect
	which again proves that mixing them was a bad idea, they are just different categories from the start
	and this means that just like strings, I can have blocks inside source instead of the ugly closing tags!
	BLOCKS: #item ["text" #item ["subitem"]] are the solution!
	only need to think how to represent grid, whether I need #grid itself or just #row [#cell [...]]
	#cell[] is not super compact/readable but it fits the model,
	other ways:
	- to enhance #row with special parsing rules for | marker (perhaps a good idea? each #widget having it's own format)
	- let tab char be the separator, but if it appears within other container that doesn't count (but paragraph is implicit so no go)
	  even if I wrap tabbed text into nameless block, it still looks vulnerable/unpredictable
	- use Red block-level new-line marker for cell separation - but this will destroy compactness and dangerous around code formatters
	  not to mention newline would more expected to make new rows
	need also to encode span pair somehow.. since any grid should be copyable in this format.. well, pair datatype may do but where?
	it may also be useful to encode some parameters e.g. #item #(param: value) [..] but I'm not sure what will these be
	#heading #(level: N) ? vs #h1 - #hN ? .. but this is way too high level
	instead I should have [font: 20 ... /font] smth
	although heading might have decorative underline under it and paddings, so it's most likely a widget in itself
	so it makes sense to make such template and (de)serialize it
	#item #(type: bullet) ? that is likely to map well to templates, unlike #bullet vs #numbered-item smth which are more like vids styles
	main issue with #item is that I call items in the list this way, but they're different than items in text list
	such text #item internally is a hlist with number/bullet marker and vlist of paragraphs to the right (which is a document)
	so one of the questions is how low level the source should be - should it contain #document, #lists etc. or just #item
	it boils down to how it (de)serializes, whether I can support it easily or not
	and maybe path-like caret offset will be better than integer eventually, much much faster and no need for space range bookkeeping
new day new thoughts:
	this source dsl and vid/s come closer to each other more and more, so why there's two?
		I'll leave only source dsl for text formatting (possibly extendable) - no structure within it
		when part of structural space gets copied, it's simply cloned with only part of the data
	do I really need to (de)serialize spaces or may just teach them to clone themselves (copy data but not state)?
		now I decided it's too much complexity for naught
	caret vs focus how they interact
	  * caret always resides within a rich-paragraph - always!
		though being within it, it can also be within a subitem (eg list used for link spans)
			I have this idea: instead of a list, use another inner rich-paragraph for spans
		if caret is within a grid, this grid is located within some othre rich-content,
		but grid has a cell with inner rich-content that has the caret
		caret is only shown if rich-content is the last space in focus path (focused = yes)
		it can also be in a field or other caret-enabled space though
		but!
	  * pointer selection needs the ability to locate caret offset that is closest to the point in a document - how?
		I guess it will have to scan the tree (or map) deeply until it finds rich-paragraph with closest Y
		then locate caret in it with closest X
		such caret offset result is a path (like focused) but with added integer offset
		(even though rich-paragraph may be within another rich-paragraph, parent paragraph doesn't put offset into path - but a space instead)
		caret left/right movement is trivial tree navigation from this deep path
		caret up/down movement is trickier - perhaps will rely on the same algo that finds closest Y/X
		just need constraints for this algo, e.g. "don't look above or below given Y",
		or "don't look before/past this given space (currently focused one)"
		(difference is whether Z-order is always left-to-right or I allow it to be the opposite and scan whole map)
		(but if Z-order is backward I don't see how I can make a meaningful cross-space selection anyway so..)
		spatial navigation will likely share this algo - need to consider it when implementing 
	  * cross-space selection spans between such two paths (which may be of different lengths)
		and consists of selection boxes which all reside within rich-paragraphs and texts/fields
		i.e. only explicit space can be drawn as selected, not /spacing nor any decoration outside of text areas
		(images as well as any other widgets can be put into rich-paragraph so can be selected as a whole)
		(and this omission of non-copyable things is a good thing UX-wise)
	  * will be very inconvenient to work with selection that is 2 paths, so I will have to provide pair/path mapping after all
	  * spaces will not be put into clipboard as is, only their clones, because by the time of paste original may be removed/changed
	    i.e. I need to "freeze" the copy once it's made
	    spaces that don't support /cloning won't be put into clipboard at all, just skipped
	    upon each insertion, again a copy is made, so new space can be modified but won't affect the one inside clipboard
	    clipboard will be a context with /data block freely readable and appendable (will auto clone spaces using on-deep-change)
	    (such cloning should consider that I may need to only replicate selected part of the data, not all of it)
	    kept in sync with system clipboard text by comparing last written text to the last read
	  * cloning is deep (just has to remove all single roots)
	    e.g. rich-paragraph rp1 within rich-paragarph rp2 when requested clone/part axb
	    not only clones only part of rp2, but also may clone only part of rp1 within
	    or e.g. selection of tail of one list item l1 and beginning of next item li2:
	    will copy [li1 [with part of it's rich-content] and li2 [with it's own part]] - 2 top level list items inside clipboard
	  * whether to have general cloning or per-template depends on whether I want to automatically apply cloning logic to template derivatives
	    I think I do, even though without specific knowledge about changes in derived template, clone may omit some features
	    I'll follow hybrid approach: each space lists a list of cloneable facets and how to clone them
	    and clone-space function will use that list, or return none if list is undefined
	  * document will be the thing that enables cross space selection and caret movement
		as well as it will be the thing that maps clicks to nearest rich-paragraphs
		(internally a vlist-based container; on VID/S level it will work fine accepting rich-paragraphs etc)
	  * document will eventually have /save/as 'html (and other formats) so it can be sent as an email or saved as a document
	    maybe /load too
	  * perhaps rich-paragraph won't draw any caret itself, only will return box of requested caret offset
	    and only document will draw the caret
	    same for selections - document's task
	    so children are likely not focusable, and don't use focused state - only document is in focus when it draws the caret
	  * how does paste work? e.g. if cross-list-item selection is pasted upon itself?
	    insertion will only try to unwrap the first clipped item, all subsequent items are inserted as is
	    rest of the text after caret gets added into the last clipped paragraph?
	    not good if I paste these items into plain text - whole text will become part of the item
	    actually, wrong, only rest of the paragraph becomes part of the item, and it's fine
	    but if I paste items into paragraph, I can't unwrap the item itself since paragraph is standalone, so there it's not even an issue
	    rich-content will handle insertion then by splitting it's text into 2 parts and adding them where appropriate?
	    selection unwrapping means that the insertion handler is often not the paragraph itself but one of it's parent (item or cell or grid)
	  X removal and insertion is where all this operate-on-the-tree model fails miserably!
	    how can I possibly define unambiguous rules of removal and insertion for complex scaffolding?
	    e.g. on ends of a list item, or grid cell, or code span
	    there may be multiple levels of decoration, very context-specific and providing rules for each will be hell
	    and these rules will be non-transparent and tricky, hard to understand and maintain
	    on a source representation OTOH such rules should be relatively easy to define, what gets removed/inserted, what doesn't
	    and this is the answer to the question of how many details source format should or should not include
	    and how it is different from VID/S: one contains logical elements, other - real spaces
best source format I have come up with so far:
	document = #vlist [
		#paragraph [rich text here images and inline spans]
		#code [just text here nothing else]
		#vlist #(marks: 'numbers) [						;-- single list item is also vlist, like the document!
			#paragraph [...]
			#code [...]
			#grid [
			]
			#vlist #(marks: 'bullets) [...]
		]
	]
	that is, structure is minimalistic but there's clear distinction between in-line and top-level items
	#paragraph #code #grid #vlist are all top-level and not supported by paragraph itself (each item defines it's own vocabulary)
	removal at the edge of a #paragraph may glue together adjacent paragraphs, but other items by default will be removed as one
	one option is to have grid and code as just top-level objects, another - expose their data to the source
	whether selection can cross between paragraph and e.g. grid depends on that
	but since I would like to insert grid as grid and code as code, perhaps it should not cross?
	because they're incompatible formats, and selecting only a few cells in the grid can only copy text, not 2D structure!
	YES this is the key! that flow selection on grid cannot be copy-pasted as grid!
	I may still (de)serialize it for convenience, but ideally it should be modular/extendable and configured so #grid is not for peeking
	fuck! if I have this:
		text text rich text
		1. vlist here as item
		   other paragraph in teh item
	and if I select from "rich text" until "vlist here" inclusive, and copy and paste selection upon itself
	it will mess the structure! most likely I will have "vlist here" as a new numbered item!
	if source was flat though, pasting stuff into itself would be safe... hello tags again?
	[
		<p> rich text here images and inline spans </p>
		#code [just text here nothing else]
		<ol>
			<li> <p> ... </p> </li>
			<li> #code [...indivisible...] </li>
			<li> #grid [
			] </li>
			<li> <ul> ... </ul> </li>
		</ol>
	]
	[
		<p> text text rich text </p>
		<ol>
		<li> <p> vlist here as item </p>
		     <p> other paragraph in teh item </p>
		</li> </ol>
	]
	selection in this case includes tags, just need to figure out how to paste them somewhere else without making a mess
	core difference between tags and blocks model is the order how removal+insertion gets done
	in block model I considered that I remove, fix, insert, fix, and get different structure
		I could still auto-unify adjacent ordered lists in this case and preserve structure
		in fact, what about unification on paste of any kind of structure for the first and last copied item?
		or reusing any container that appears on the way, but inserting if it's not? - best idea so far? SHOULD WORK!
	in tag model I considered that remove, insert, fix - the lack of fix between the two keeps structure intact
		but the hard question is how to fix the structure after
interestingly, rich-text doesn't allow ["ab" u "cd" b "ef" /u "gh" /b "ij"], works like stack
	but low-level allows that
in paragraph [b /b] - where is left and right insertion?
	I guess [b "" /b] is one way to introduce it, but it's still all a single caret offset
	besides, technically there's no bold in there since there's no text, so no left no right
final source format then (top level container #page is a vlist with no marks):
	#paragraph [paragraph syntax]						;-- may have #p shortcut
	#list #(params: values) [							;-- may have #ol/#ul shortcuts
		#item [
			#paragraph [...]
			#paragraph [...]
		]
	]
	#code [anything except text is ignored/removed]		;-- rich text can be pasted here, but will be stripped
	(code may appear both in paragraph and in list - but it's not an attribute!)
	(attributes are not carried from one paragraph into the other, UI should do that if it wants)
	undecided if #grid is worth including (inclusion provides crossing selection):
	#grid #(params: values) [
		#row [
			#cell [
				#paragraph [...]
				#paragraph [...]
			]
		]
	]
	will need to make it extendable/modular so one can refit it (but that's for later)
how to encode a spoiler?
	it's theoretically there, but shouldn't be selected or allow caret until it's shown
	#spoiler [
		#title [#paragraph [..]]	- title is a vlist
		#content [#paragraph [..]]	- also a vlist
	]
	so it then only produces a space for #title and reports 0 length for content, so caret skips it
	selection should also ignore it, so I'll need caret-to-source handled by each scope separately
	as document doesn't support translation or zoom, 'content' space should not be created until made visible
or can it support translation/zoom? and where I need it?
	I can imagine grids inside scrollables, but grid I will make a single item ?
	code will be put into a scrollable too, and it's not a single item, don't want that
	so how to translate caret box from code into document?
	I don't have the means.. so maybe caret should be drawn by code itself then
	meaning, I have to put it into rich-content or it's derivative, as well as paragraph itself
	no translation will be needed but need to control who has the caret, or if nobody has
	I suppose document itself will have to track it and set for each rich-content/paragraph
	how will it know if it supports caret or not?
	length > 1 is one indicator, but it excludes paragraphs with single letter (bad e.g. when typing)
	so I suppose editable or caret facets should tell that, or else hardcoded
lessons I learned from briefly playing with the caret around one or more spaces where line wraps:
	- when user types text in, there will be moments when this text ends with a space
	  and this space should be significant so user knows he entered it (visual feedback)
	  so it's unacceptable to clip caret to only text in the row
	  another argument is selection boxes: spaces must be visibly selected
	- on the other hand it's also unacceptable to let caret roam free
	  because spaces are not considered in width estimation, so they may get out of the paragraph into other UI elements
	  so caret should be clipped within the rich-paragraph itself
	  then it both provides enough visual feedback and prevents caret overstepping
	  this still will lead to whitespace collapse in fill mode (when it succeeds)
	  and in case there are too many spaces in the line
	  but that's acceptable, and I don't see a better option
	- I need a special case when to the left of the caret is a space, but to the right is a visible char
	  here, left caret (after the terminal space) should be turned into right caret (before the next line)
	  simply as this feels more human
	  but in case of multiple spaces, those that don't have a char to the right, caret should still be located on the previous line
	- same concerns newline char: locations before and after it both map to the same place in the previous line
	  so a better UX is to move the location after it to the next line
	  (in this case doesn't matter what char follows it)
	  but whose responsibility is that?
	  not text or paragraph since these are not wrapped within rich-content
	  rich-paragraph knows nothing of caret or chars, operates on whole spaces only
	  rich-content has access to text and provides caret facilities, so there it goes
	  turns out it's quite tricky to implement!
		  fill-row-ranges only uses clip-end for last caret offset, since it doesn't know any other "right" margin
		  this results in whitespace being excluded from caret ranges
		  is this desired? at first it seems so, but this will lead to:
		  clicking on after the row will position caret before the whitespace,
		  while manually it will be possible to position it inside the whitespace
		  clearly not consistent..
		  so now fill-row-ranges counts all whitespace
the more I bother with document source format the more I'm thinking of scratching it
	involves so much effort, probably much more than direct widget copying, now that I have an idea how it might work generally enough
	and the idea is: define rules not only for insert/remove, but also for change (for better paste into selection)
	in the worst case, I'll have to specialize list and other widgets to usage in the document
	but ideally document itself should be able to handle it
have this idea about caret
	instead of a block, let caret be a space object in the document!
	document will move this existing object from one child into another when it wants to display it there!
	(also will help to build multi-caret mode when one wants to)
	then as a space it will be styled as rich-content/caret or text/caret or anything, out of the box
	(otherwise, to style it I would have to create the caret space all the time for every child) 
and this idea how to simplify everything
	get rid of paragraph/text - have only rich-content in the document
	it will then be a plain list of rich-contents with no deeper lists, no tree
	each rich-content may have a numbering attribute - bullet or number, and has an indent value which can be tuned on the editor level
	each grid/cell, spoiler - have their own document, and are opaque from this one's POV, so no selection across borders
	document won't need a source but VID could accept it once to create the proper layout, and discard the source
	indeed this is so much simpler
	source format could simply use block for paragraph, with optional marker for numbering
how to organize paragraph indentation?
	one indent isn't enough, since there's indent from the left of the page, and that of the first line only (number, bullet)
	critical in lists that are by themselves indented
	/indent and /first-line-indent?
	/indent as a pair firstxrest?
	/indent as a block [first: .. base: ..]? though wikipedia names 'block indent'
		in this case negative first also effectively increases base?
	/indent as a block [first: .. rest: ..]?
		base makes more sense as it's known, but in this model rest > first > 0, which is easier to grok
	also, first line is one thing, but indenting to a number is another, as number in this case changes it's width
	but it can be done by making number a space, not text
	but then some upper level will have to control indentation's consistency
	and this high-level logic will have to work even on read-only documents
	also, number should never collide with the text, so number indent is a minimum but not maximum value (/limits/min a good fit for this)
	so let indents themselves be either fixed or rather measured based on font size? 
intersections of attribute ranges
	hard thing here is to maintain consistency across multiple removals/insertions/unions etc
	consider color: it overrides the previous value
	when used as a stack it's fine, but what if I unify two ranges of different color
	I could just map colors one upon the other, but if they start at the same offset I need extra effort to guarantee nesting
	and effort becomes bigger with more intersections
	OTOH I could subtract ranges from each other to ensure no intersections, though it's also an effort
	unification then is asymmetric: one takes priority over the other (primary/secondary)
	intersection exclusion naively is O(n^2) where n - number of values an attribute takes, but I have an idea
	dammn I hate the amount of code needed to support pair ranges compared to bitsets/vectors
	vectors' main issue is serialization: slow to find the change index
	but how important is it? 1MB paragraph is not a likely case, and serialization of multiple paragraphs happens when?
	on copying only, which is not going to happen often anyway, for the whole document
	possibly on removal/insertion - if I want to update the source (usually I do) - but it's for one paragraph only
	bitsets may help since 8x faster find on them, but how to shift them? enbase+debase?
	and how to serialize?
	- enbase then find (1 comparison per bit)
	- to binary then find (1 cmp per 8 bits) - perhaps the most efficient solution all things considered
	  or rather parse: funny but it's 2x faster than find binary binary: parse binary [any charset]
	- create masks e.g. of 256 bits length, and it with them, test for emptiness (= charset []) (1 cmp per 256 bits but allocations)
	after some work with bitset I'm thinking just binary will be faster
should I keep ranges in the rich-content when I can call 'measure length'?
	ranges preserve info about what spaces were 'single' in the source, and what spaces were created from text
	so caret can skip the single ones but dive into the created ones
	but I also could dive into all of them
	or I could just add a flag (/dive or smth) and avoid this data
	for document it's enough to know the length of each paragraph to be performant
	(might just cache them, piece of cake)
	or I can make caret two-layered: paragraph-number x item-number
	(but it's more awkward to use than normal caret, so no)
	what happens when caret is in the sub-document? focus path changes, focuses the sub-document
	how to decide: to dive or not to dive?
	key is copy/paste simplicity, allow no deep pastes
	so that means what's single in the source should stay single in the copy, so no dive into it
	OK so I have to keep a list of items where I should dive, so I might as well keep their ranges rather than boolean flag
	another reason for ranges is translate click into caret, so I might wanna keep ranges of single items as well
	single items will never be dived into even if generated? yes.. left/right caret will only affect attribute carryover
document/selected cannot be a pair!
	it works for drawing it, but not for copying/pasting
	since for copying/pasting it matters if it starts/ends before/after paragraph split (effectively, linebreak)
	also for removal (cutting) it matters as well
	so I suppose let it be object [start: [offset: side:] end: [offset: side:]] ?
about clipboard
	I need to copy into it arbitrary paragraphs with arbitrary spaces
	and provide text version of this data for exporting
	paragraphs may be copied as a single line or formatted to 80 columns, divided by empty line
	this works for code as well
	grid will need tabs and newlines as separators
	for links to be copied, lists have to be scanned for text, as well as clickables
	images are not editable nor measurable but still may have alt text to be copied
		so this function should not be a part of edit [] dsl
	lists can be horizontal or vertical, copied differently
		delimit with a space char or not?
		in rich-paragraph, all spaces are present already, so probably not
		OTOH I could check spacing/x if it's non zero
	again, facet or not? explicit or implicit inheritance?
		container -> list -> ring make zero sense to inherit
		list -> cosmetically-different-list does make sense
		text -> code makes sense
		ok facet then!
	too bad can't use /copy name for it, too widely used... /clip has other meaning, should take segment
		/copy-text ? /export ? /save ? /to-string (most to the point of all) ?
		/form ? (also great, and I use it rarely enough to fear the override)
		REP 134: form, format or to-string?
		format implies some format-template, which is not used here
		also, formatting intent is unknown: for readability or for reuse in other software?
		readability would insert separators into numbers, reuse would not (preferable as more general case then)
		form is mostly for single line messages though
		format for interchange is a best fit so far, so let it be /format
		later with a possibility to extend format function to accept spaces
clipboard and copying
	content in clipboard is supposed to be passive isolated stateless data
	once it's copied it should not change into something else, or it may have unexpected consequences
	currently clipboard expects only strings and blocks of spaces, nothing else
	spaces are cloned when copied (cloning was introduced for that - to make spaces into data)
	they are also cloned again when read, so the receiver can change the copy but not the data on the clipboard
	but it doesn't feel 100% reliable, given how many quirks the 'copy' has
	if anything other than space/string is passed, should it cause an error, pass, or skip the item?
	should it have extendable list of conditions which it can accept, with functions that prepare the data?
format and lists
	should format use content or items?
	items is filtered and sorted data so it makes sense to copy what is shown
	content makes less sense 
	but maybe use map instead?
	btw, rich-paragraph should format not the source but actual items, to ensure spaces are not skipped
	how to add space after bullets/numbers? should be done on document level, since it's introduced there not in rich-content
what about blockquotes?
	I could base them on paragraph, sure, but how to copy/paste it?
	oh easy, they will just clone themselves together with their block thing
	or rather, they will be normal paragraphs, just under a different name, to style them accordingly
how they can be listed in the document?
	don't wanna make a new DSL
	could extend VID/S with something, but then again not sure it's worth since most likely document layout will be generated anyway
	I need to either ensure nothing not based on rich-content appears in the document (or on rich-paragraph?)
	or everything should just get skipped (ignored) by copy paste
	but since paragraph can include any space I don't see why this space should appear there without a paragraph 
composite widgets pose hard design questions
	drop-button example:
	I could organize it as a `hlist [box button]`
		best thing about this is that `draw` works automagically
		problem is when user clicks on box, how to mirror it's inner 'pushed?' into the drop-button?
		need two-way mirroring.. somehow.. or maybe not, maybe pushed? should stay within the child only
		but then read access is more complex, and no programmatic control over it (only from UI)
		(same as list-view doesn't have /axis, only /list/axis)
		read access could be simplified with a function reader, but the other one..
		another good thing in this model: total control, e.g. /limits for box
	or as a data-clickable mirroring itself into box, and drawing box and button side by side
		but this needs custom draw, and doesn't solve anything
		I still need to list all mirrored facets, so I may as well just define them in the list
	or as a data-clickable without other spaces inside
		but this will not only need more complicated custom draw, but also hittesting
how should hovering work?
	uses: highlight hovered over list item, or indicate a clickable surface
	lol turns out I have a %hovering.red file that was never imported (and event/away? is not for writing)
		it also previewed time events which is a heavy and bad idea
		but the point was that pointer may stay in place but space itself become rendered elsewhere
		so the away event, and perhaps there's no way to achieve that without timer
	options:
	1. generate extra on-over event for all spaces the pointer just left (like event/away in View)
	   can't modify event/away but can pass away? as another parameter to the handler
	   for this to work I will have to keep track either:
	   - of all spaces that received over events but no away event
	   - of all spaces under the previous over event - faster
	     just compare two stacks (paths) - last and previous one, fire the event
	     this will also play nice with dragging
	     whether or not I should check if space is still on the tree, unsure - perhaps not worth it
	2. have on-enter (not the enter key) and on-leave events, which aren't View-compatible
	3. have on-over work as on-enter and on-leave/on-away as another event
	4. have a check that tells if pointer is over the space or not
	   but what will trigger the redraw? still need an event
	5. make it work akin to focus model - with only one space ever being hovered upon/highlighted
	   under the hood it will be a previewer
	   but there's a need for a list of 'highlightable' types then
	   and it will be impossible to highlight multiple spaces, which is not an option
	   e.g. item(row) in a big vertical list and at the same time item in that row
on-drawing event	   
	timer previewers are now called for each rated space, not once per host
	so 'drawing' event introduction may win some performance
	plus if no space has a timer, now it's the only way to ensure away event, except insert-event-func
	another reason for this addition is that `render` may be called by the user, which I wanna catch too
	OTOH I don't want spaces to support this event (for performance), only the host, so maybe I should not add it
	OK I'll use a kludge for now, `prerender` block for face render, no better idea
	aw shit, it doesn't have access to the event... so can't know pointer offset
	but in arbitrary code calling 'render' I don't have events, nor pointer offset
	so it's not possible to generate away events outside the timer code?
	I can stash last event/offset for each host during host over events, then hittest against it
	but there's the question of dragging - is it on or off, should hittest go into the last path or not
	but it's fine I guess
	btw, it should not use spaces event system, only faces event system
	another consideration: during dragging a lot of events will land outside the space
		should they have away flag? or maybe just test if offset is within the space? I prefer the latter
		(but away event can still occur during dragging if render relocated the space)
	another: if render relocates a space, it's not enough to only produce over event if it's /away
		all renders must generate over events if offsets in the paths differ
	what a mess, ok:
		over events are there already, I just need to add one when new-path and old-path have different spaces
			2 hittests: one normal, another into old-path (to obtain proper away offsets in the old spaces)
		this will cause duplicate offset for all spaces in the path that did not change
			and generally there will be twice more over events where spaces are small
			but it's fine I guess
		and this event should ideally happen before the 'over' that goes into new space
		render again only triggers new event if paths aren't equal
			should it be generated before or after the render?
			if render is the cause of it, then after makes sense - just rendered and now invalidated
			OTOH, before makes sense too - invalidate as a reaction to previous render and re-render
			after is better since dispatch will test for invalidation before rendering, and prevent render (and away event)
			but this will alarm validity cycle detection (rightfully).. hmm
		what if dragging stopped - on-up event - same pointer offset, maybe no render - View generates over event?
		fuck it's so complex and dangerous! maybe I should only react to over events and not to render?
		or just compare paths by timer and don't bother with user-triggered render calls?
			it will only be a problem if one tries to build one's own rendering pipeline, not timer based
			but no validity issues and no pre/post-render kludges
		another reason not to overload render is: during render many size changes happen normally, don't want it to mess everything
		case by case:
		1. pointer moved and no dragging
		   compare paths: old-path with new offset and new-path (free)
		   gen event if at least one space differs, for the spaces in old-path (one event chain)
		2. pointer didn't move and no dragging
		   same, but can only gen event if previous render shifted something
		3. pointer moved and dragging
		   path spaces are equal by definition, so normal over event will trigger away-ness
		4. pointer didn't move and dragging
		   same here, no event needed
		another issue: cannot set event/offset, and for timer event it's invalid, have to use object
		or why bother, pass 'none' for event, offset is known from path
		it's still lagging:
			render (on timer) moves the spaces
			next timer kicks - detects movement
			and then hopefully on the same timer hit it rerenders it
			so it's still 1 frame behind
			but it's either that or postrender with all of it's risks of cycles
drop-button UI/UX
	at first I thought of using popups for it, but I need to show it below the drop-button
	how can I translate the left/right bottom corner of the space back into the face and window? I can't
	besides, such translation may need scaling/distortion
	what I can only do is show this menu in the drop-button's coordinates
	but then how can it stay on top of other spaces (which it will occlude)
	and how to avoid clipping by the parents?
	in some mobile UI I would just expand the list this item is in, without occlusion
	heck maybe I should consider it a bad UI practice to have these dropdowns..
	but what's desktop alternative? locker pane? still less efficient than a drop down
	better idea: don't tie the list to the drop down's corners
	instead display it as a popup centered on the selected item around the pointer
should caret be part of field/document or of text/rich-paragraph ?
	part of text is simpler, since it automatically applies correct translation, scale, clipping
	on the other hand it carries features of the parent
	- in field this is offset and look-around
	- in document caret isn't the same at all as in rich-paragraph, even offset is different
	the only thing I dislike here is that style will be spelled as field/text/caret or document/rich-content/caret
	let it be for now
	if I find a good reason to put caret into field/document, I will look for workarounds 
I decided not to burden implementation with links that span multiple caret places
	because if I did, I would have to add analogs of offset-to-caret/to-char into every space used (list, clickable)
	seems like unnecessary complication for now
	as a result I don't need /command attribute anymore - let it just be inserted as a space
how to "linkify" whole paragraphs if they're selected?
	it might be best to create one link per paragraph, skipping the list marker
need to reconsider what spaces are significant in rich-paragraph
	text: "a b c" - if I select " b " and make it a clickable/rich-paragraph, it eats the last space
	so trailing spaces must always affect the size, as well as leading ones
	only spaces where lines are split are insignificant
row ranges concept in rich-paragraph has a problem...
	when an item spans multiple rows - what are the ranges for each row? they interlap
	these rows caused so many problems already that I regret not making a coordinate system initially for it
	why didn't I? because didn't see benefits back then
	how 1D/2D map to one another then?
	paragraph itself is 2D and receives clicks on it's 2D area
	it unrolls clicks into 1D row and then into a specific space
	need to think on vertical offsets during this translation...
		tricky: rows are of different heights, so single space may have different vertical offsets in different rows
		so one option is not have them in the map at all, store separately e.g. as map (row-number, space) -> y-offset
		another, better: have whole map properly vertically aligned as a single row (along baseline)
			and visible rows will each have start-y end-y that define their vertical offset and height
	but it's map is 1D, because it can't be 2D without having duplicates
	and it should not be a problem as /into handles translation..
	but map is expressed in space's coordinates.. so it should be 2D
	only valid implementation would be to have a nested structure: rich-paragraph/unroller/spaces...
	paragraph is 2D and has 2D unroller, but during /into unroller, 2D is converted into 1D
	and unroller deals in 1D coordinates and has deduped spaces in it's map
	spaces in unroller map will be unscaled, so no /into will be needed
	scaling will be done during paragraph->unroller translation then
	or wrong?
	maybe rich-paragraph will have a 2D size but /into will translate points into internal 1D?
	indeed! it's map is 1D, but size is 2D
	same as zoomer may have 100x100 size, but with scale 0.5 a child may have 200x200 size
	zoomer doesn't need a map, but if it had, it may store children in scaled coordinates
	so assumption that /size and /map/child/geom/size belong to the same CS is wrong generally
	still having an unroller may help abstraction?
	worst thing currently is having single child in multiple rows - need to get rid of that
	if unroller supported draw/window I could go row by row obtaining fragments? (it may ignore Y axis)
	what about splitting/sectioning and 'fill' mode that fills split whitespace?
	and how it works together with scaling? who scales?
	'chain' may be a good name for unroller, or 'chopper' or 'slicer' or 'sausage'
	so para asks chopper to return 0..100 range
	chopper renders everything and caches the results anticipating multiple range requests
	returns spaces that fit, but NO!, this won't work since it has to set it's size and not change it with each row
	let it just be a function in paragraph or chopper then: chop the row (map) given a range?
	it may return then both size and spaces and their offsets
	it's returned size may be bigger than requested, which means clipping
	and first space's offset may be negative (left clipping)
	what about sections? will need sections of each returned space
	and will need to know if last visible section is optional
	if it is, and it's skipped on next range request, if not, subtract it from next range
	scaling may apply too
	rows primarily become ranges [start-x end-x] of each visible row
	with less sections usage (only on row edge) it might actually be faster!
how to cache sections?
	they depend on canvas, at least on some dimensions of it
		e.g. hlist's items height affects their width
		or paragraph may turn off sectioning when it's split
	but they're optional and it's unwise to fill them until needed
	so maybe let them stay in /frame or other cache and get invalidated by /size change?
	ideally I need a custom caching mechanics for it, but too lazy
	shit it's tricky!
	case: hlist may be rendered on other canvas and it's map fetched from cache
	but items and their sizes and maps won't be
	and this means items will have outdated/invalid sections cache if they change their width with height
	but it also means that map of items and hittesting will be invalid
	forgot.. I have cache generations to defend against that
	plan for now is: store them separately
	set to none on draw and by cache fetches - so canvas changes always reset it
		problem then that fetching cache for current canvas also resets it..
	fill by /sections
	have another idea...
	draw resets it (to new empty block)
	use common cache to store a block, and this block will later get filled (also in the cache) by /sections
	purrfect!
so what's the effect of generations on out of sync children maps and sizes?
	rather hard to predict...
	inf/zero combos are never replaced but possible to get to glitch:
		render on a new finite canvas, changing items, then on infinite (cached), leaving items finite
		how likely? no space I know of does that
		tube: half-fixed size, and if it becomes 0xinf (after Nxinf) it cannot be hittested anyway
		list: same
		grid: inf then fixed for children
	wrote a design card for now, don't see immediate blockers
paragraph edge cases as I see them:
	leading space - always significant, even if right-aligned
		esp important during editing
	trailing space - significant, but should not produce a new empty line
	split space - disappears basically, but caret locations still exist, to walk across whitespace
	linefeed - should not be part of the paragraph! bcuz cannot be unrolled into a row
		should split input into two paragraphs - need assertions in paragraph code
		(plus it's just a complication to support it)
	map will simply contain a list-layout-like row of all items
		either on source change or on-demand after the change
	map will be split into rows by draw (splitting depends on canvas) and rows are cached
		splitting also handles indent and scaling
	need translation func 1D->2D and back (roll/unroll? slice/stitch?)
		should it use subpixel precision, for scaling? no reason, since on both ends are pixels
		it will account for indents, alignment, zoom and chosen /size (not canvas - canvas is handled by draw)
		since row splitting depends on sectioning and item sizes, some things must be cached:
			each row's start-x end-x (unrolled) scale-x offset-y height (rolled)
			each space's caret-start and -end - but this is for caret-to-and-from
				instead of space->range map - maybe just by space's index?
			within each row - each space's offset - for stretched spaces support (size is known from item/size & scaling)
	should alignment always be added from left side? it becomes rather weird
		alignment for numbering doesn't make sense at all when not left-aligned
		what editors do is align the paragraph itself but not the number
		it's still weird but probably less weird ? or not...
		what makes most sense it seems is to rearrange alignment
		that is, it should be first subtracted from max row size, then whole row (that's left) is aligned as it should be
		'fill however should not fill alignment's empty space, only what's left after subtraction
		and fill should really scale whitespace not content
		else there will be fill-left fill-right fill-center and they'll all be weird
		I might allow scaling up to 5-10% before stretching spaces, but then only spaces
		this is challenging though, since paragraph & text do not know how to stretch their spaces
		it can only work simply enough if text is split into individual words (and even then complicates it much)
		or maybe like this! not just split map into rows, but split it into words (significant regions, projections)
		each word then project into the output using clipping
	'fill with scaling should somehow also reduce row's width! that is row can be bigger than allowed width, downscaled
	should it render items on infxinf or use width?
		for grid (images too?) it makes sense to use width, but for sub-paragraphs totally not
		so I suppose it will be up to document to autofit all grids
so I laid out a 1D map, now what?
	to create rows, ideally I need to give it pixels and it returns space index
	otherwise I will have to repeat the positioning again during row layout
	(and it has proven previously to be challenging when sections are taken into account)
	but even if I repeat it, translation will still be slow - inspect all items, find one that intersects the given pixel
	to speedup I can:
	- list pixel ranges, look within it, maybe structure in a tree or use binary search
	  still should be faster than sectioning everything
	  shit, my binary impl is not great for step functions
	- make a vector or binary map of pixel->index (vector is super slow because 2 vectors can't be joined together, so binary)
	  4 bytes per pixel - 4kB per 1000 pixels, 40kB per 10000 (normal paragraph), 1000 paragraphs = 40MB a bit too much
	  can make a block then convert to vector - convenient access, still small
	  so maybe lessen it, to 4 bytes per 16 pixels, and then correct the index on misses?
	I also hate having spacing in the map, have to account for it, breaks binary search, return value is trickier...
	I'll disable spacing for now, too cumbersome to support
	shit again.. snapping by row width makes algo too complex due to forth and back sections handling
	(due to possibility of ending with an empty section)
	section-based algo was much simpler/shorter, will have to get back to it :(
so the structures...
	to draw a fill row I need it as a list of words (word ranges)
	for each word I need it's space and geom (including drawn) - looked up or cached
	edge word ranges -> row range
	word count + row range -> amount of whitespace to distribute
	each word + geom/offset/x -> clipping region for drawn
	amount of whitespace + geom/offset + alignment -> x offset of word
	all geom/sizes -> row height -> y offset of row and word
how should caret-to-box work for fill alignment with stretched whitespaces?
	I suppose there should be a separate scaling ratio for each interval between words
	or for each section
	how about a function that takes cumulative 2D x value and returns a 1D x value
	it would be based on a set of scale factors for each segment
	main goal: mapping of all 2D points to 1D points and back, fast
	useful for:
	- mapping pointer events, but also need 1D point into space translation (/into)
	- caret-to-box, but also needs caret to 1D box
	subgoals:
	- 1D x to caret offset
	- caret offset to 1D x
	- 1D x to 2D x
	- 1D x+y to 2D y and row offset (may depend on row height)
	- 1D x to row number
	- 1D x to map item number? (then given item offset -> offset within item)
	- 2D x to 1D x (row-dependent)
	- 2D y to 1D x row offset
	- 2D y to row number
	+ fast interpolation over a function as a sequence of points, possibly with flat regions
	don't need no row number in 2D since it's easy to get by division, as long as row width is fixed
	only problem is with rows that are bigger than canvas...
	should not be a problem since I have to measure all words before I know the total width (which determines row widths)
	(otherwise single rows will stick out of the paragraph = ugly)
oops still an issue with fill align
	what if whole row is a single word? no whitespace is in it that can be stretched
	what all text processors seem to do (incl google shitty docs)
	is they left align it and start each word on a new line: https://i.gyazo.com/16df2b90d111df6e3456d6045a05e68b.png	  
	I can either force split like they do, or increase the total width (perhaps an option eventually?)
	I could increase total width over canvas until /limits/x and then force split...
	since I'm not making a word processor, it doesn't matter much though
	value of forcing split is in no risk of paragraph making the whole document wider than the page
	value of not doing it is e.g. in autofitting grid column to paragraph, or laying it out inside a row/column
	so it should be controllable after all, as changing /limit with canvas is too tedious, it should be a flag
	flag that controls whether canvas width is enforced by hard split or not (/limit will affect it by affecting canvas)
	name? /hard-wrap ? /force-wrap ? /split-by-canvas ?
	too tight width may make it very inefficient though, repeating the same draw command for every pixel
	I may have a single /limits object shared between all paragraphs, and then I don't need a separate flag
	just change limits and invalidate all paragraphs... still extra work though
	at least this will avoid the inefficiency, as long as limit itself is wide enough
	problem of forced wrapping is it can split single letters... which should be avoided when possible
	sections already contain chars and will be split fine, including urls, but with exception of text wrapped into some custom container
	ok postponed for now, but main point is that need to know the min section width before splitting into rows!
now another question: split by words (on whitespace) or by letters? should this be controlled?
	perhaps a good solution is: to split by words, but when single word is bigger than the row then split it by letters
	should be fine with it, even better than text processors 
	but should total width be estimated from min section or min word?
	min word is better UX, and thats what I came to with the basic text paragraph
	but then it opens up a question of hard wrapping again, as this contradicts the above solution
	curious fact: if I split by words (on negative sections),
	then images that follow one another without a whitespace will not be split
	only if they have a margin and support /sections via generate-sections then they may be split.. and it's fine
another issue, catch-22 like:
	I need to know total width to be able to split it by rows
	I need to know rows content to know total width because it's affected by indent
	solution: if biggest section or word is the first one, add indent1, otherwise add indent2
	it has a drawback: if indent1 < indent2 and first word is small, then 2nd word may fit into 1st row,
	but this solution will make total width as big as if it doesn't fit
	more robust solution:
		only if indent2 > indent1
		loop thru all words, accumulate maximum of
		min (word/x2 + indent1) (word/x2 - word/x1 + indent2)
		and total-width will be max allowed-row-width and this accumulated value
apply scaling to whole row or individual items
	if I apply to whole row it complicates draw a bit:
		can't just move to a given offset and draw a word (offset is a float and it's already scaled)
	if I apply scaling to words, whitespace and text will be aligned on pixels, while rich-text can render it at subpixel precision
		so I expect a bit of jitter as size changes
on last (split) whitespace and how to store it in the 1D/2D mapping points
	inter-word whitespaces have their points already, so this concerns only the split whitespace
	last whitespace should be added after the row, i.e. it may even stick out of the allowed width
	(in right and fill mode it will almost always stick out, except for the last row, in other modes less likely)
	sticking out whitespace won't be possible to click on (outside of space geometry), so I can still obtain Y by division
	but it will be there for the caret: caret to box may produce caret box after the row if not clipped
	if it doesn't stick out (in left or center mode), it can also be clicked on
	no point in scaling it but for convenience it's an open option
if trailing whitespace made significant it raises a new problem:
	now it becomes part of the last word e.g. `x        ` which can't be split, so will affect the overall width
	if I make multiple words out of it then intervals can be stretched - bad? probably not..
	what's bad is that then `x` and ` ` may occur on a row as two words, while the rest on another row
	so this will look pretty unexpected, and produces a new row, which is also bad
	I have to leave it as insignificant but make special cases in row layout algo:
	trailing whitespace should be placed just like split-whitespaces, after the row, never making a new row
leading whitespace can be made significant, and become part of the word it prefixes
	I see no harm in that
	word processors do not make it part of the next word,
	but they make it a single word, that can occupy a single line but not two or more lines
	google docs is a bit funny in this regard: https://i.gyazo.com/5165ca2dfb0268c4f8ca39373b4d8077.gif
	while textmaker clips the visible caret as I prefer doing
	the drawback of making it part of the word is that it will affect the overall width,
	or it will be force-wrapped into multiple lines
	which is not a serious enough drawback to even bother
what about tabs?
	textmaker makes each tab snap to a specific horizontal offset, which includes indent
	google docs just converts tab into a linefeed lol
	I guess I should not bother with tabs then
	but if I did, I would have to modify the row layout algo, with a special case for tabs
	shouldn't be too hard if need arises, but may need special kind of section for it (zero is the best fit)
should row's Y be obtained via simple division?
	in this case X cannot be bigger than allowed width
	and trailing whitespace will become compressed, in the worst case (fill, right align) - into zero
	or alternatively, only sticking out whitespace becomes compressed (what word processors are doing, except google docs)
	ok fine with division for now then
on coordinate naming: maybe `x` for original row, `x'` for unrolled 2D row, `x''` for rolled 2D row?
	though the difference between the last two is only in row-x1', so perhaps `x'` for rolled 2D row x, and `x''` shouldn't be used
	scaling can be performed after subtracting indent from x'
	total-width, total-width', total-width'' ?
	total-width-1, total-width-2, total-width-3 ?
	total-width-source, total-width-unrolled, total-width-rolled ?
	Stotal-width, Utotal-width, Rtotal-width ?
	total-width-1D, total-width-1D', total-width-2D ?
another issue will be with clipping:
	if I clip each word, this will cut the possible outline of code spans, or selection box around url
	so I should not stretch just any section - only whitespace text sections! while containers will be left unstretched (but scaled)
	but how do I even know? from paragraphs POV they both spaces - list and text
	make a special case for `text`? or drop the stretching support?
	better idea: scale the whitespace horizontally, not skip it! then frame will also be scaled (which is fine)
	then if whitespace is to be drawn, it makes sense to not only keep words but whitespace too
how will force-wrap affect the row split algo?
	if single word is bigger than the row, it should be split between sections, without any force-wrap
	force-wrap may enable splitting not at section boundary, but at any point
	it will also prioritize given canvas and won't try to extend it, or determine max word size
problem is, words do not carry info about sections, so how to split at section margin?
	I could just group sections into words, but keep sections too:
	words: [AxB white? [sections...] ...]
	rows:  [RAxRB [AxB white? [sections...] ...]]
to simplify algorithms I decided to add another alignment: 'scale
	'fill will have no scaling, 'scale will have no space adjustment
	in 'fill all words will be aligned to pixels then and rendered separately
	'scale and all other alignments will render row as a whole single word
	how will scale fill the row though? up to the max and then upscale? or to achieve best ratio (closest to 1)?
	maybe 'upscale will fill the row up to the max, while 'scale will aim for scale closest to 1
	only 'fill needs to know if we're on the last row then, 'scale/'upscale don't
'scale splitting algo:
	add words until predicted scaling ratio becomes worse than last one, then split here
	last line will usually be scaled by a lot, and I don't care
	there can be a more sophisticated balanced algo that would achieve best result for all rows, but no reason for it yet 
	this mode might not play well with force-wrap, so I should disable force-wrap in 'scale mode 
should margins actually be reported by /sections as empty?
	if I use margins to draw an outline, this outline will become clipped
	so perhaps only spacing, but not margins?
	margin should stay significant, but still separate section, so in bad cases it may serve as split joint
row Y as x / width doesn't work, simply because they are of different heights
	only row number can be obtained like that
	then what's the optimum mapping?
	whole chops of total-width correspond to specific Y2D offsets and back
	so the mapping is x-1D' <-> row-y1-2D,
	where row-y1-2D corresponds to the y=0 of 1D/1D' spaces (and may point at an empty area up to geom/offset/y)
when to split text in rich-content:
	row starts at command: https://i.gyazo.com/cb78c0ce0554a30eb760eae7d33b786e.png
	row starts before command: https://i.gyazo.com/fc0b44860f5b13a676b98dadab7bc158.png 
	row 2 becomes bigger than it should because part of the previous space (from "orem" thru "elit,") is big
	so I could for now force splitting on font/font-size change
	whether to split on words is still debatable - needs benchmarking
selection: object [start: [offset: side:] end: [offset: side:] range: pair]
	is a nuisance, too much work to spawn it
	simpler will be to keep it synced with the caret?
	it's a total mess, shit.. and no automation unless I resort to very complex form:
	selection!: declare-class 'selection [
		parent:      none	#type =? [object! none!]	;-- for auto invalidation
		range:       0x0	#type =? [pair!]
		start:       0		#type =? [integer!]
		end:         0		#type =? [integer!]
		start-side: 'right	#type =  [word!]
		end-side:   'left	#type =  [word!]
	]
	and a few on-change funcs..
	could simplify by removing start/end (using range for it)
	but still, it could have been just a single pair and encoding/decoding api
	maybe selected: [range: 0x0 sides: [right left]] ? still needs manual invalidation but better
	selection!: declare-class 'selection [
		parent: none			#type [object! none!]	;-- for auto invalidation
		range:  0x0				#type [pair!]
		sides:  [right left]	#type [block!] (parse sides [2 ['left | 'right]])
	]
	biggest issue is this also needs api to create such object
	and biggest question is do I need selection to be bidirectional? or may auto-order it?
	one can always infer the order from the caret - to which side it belongs.. so probably no
	but if it enforces order, there appears a problem of the assignment order if /range also reorders /sides
	aha, that's why /select function is needed
I also hate source format complexity esp attributes
	what if I used strings to map each item to attr? that's up to 4e9 attributes, but compact by default
	each char will be a value index
	1MB of text -> 1MB of each attribute max (maybe 10MB total max)
	no normalization needed, trimming is easy
	done! much better!
I need to get rid of serialization into /source
	this step is currently totally extraneous and slow - serialize then deserialize again on every edit
	moreover it requires document to contain rich-contents not rich-paragraphs
	while paragraphs are good enough and can be edited as long as they can unpack their /content
	then every space in the paragraph will become editable
	and to turn off editability one will just have to override length (set to 1 or remove it)
	done! source is only in VID/S now, while rich-content deals with decoded data only
	document has still to contain only rich-content because rich-paragraph does not define editability
empty paragraphs are a little bit of a trouble
	if they have no caret offsets in them, then I can't move caret from one to other - only before or after the empty group!
	so maybe I should count paragraph itself as 1 caret slot? (as if it was a new line char)
	in that case it will be possible to select this slot and I suppose it's fine
	will this help simplify selection, removing sides from it? indeed! wow!
	so there will be an empty caret slot between all paragraphs - a delimiter hmm..
	what if paragraph is empty? biggest issue is the lack of line height
	need to ensure nonzero height and caret for empty paragraphs!
paragraphs offsets scalability problem
	done naively it iterates over all paragraphs until it locates the caret
	if I saved all paragraph offsets I would still need to update them (nearly) all on every edit
	root issue is addressing: caret and selection offsets are integers (convenience matter)
	ok not now
impossible to define page-up/down jumps within document that is list-based
	so how to give it info about page size?
	I'll need to move key events from document into 'area that wraps it
	let 'document stay passive
how to make paragraphs always contain at least one row?
	ideally when I press enter, newly created paragraph should be of the font of the previous char
	but how hard it can be?
	rich-paragraph doesn't have a /font, it only has one or more spaces, and it's logical to turn it into 0x0
	rich-content on the other hand is text-based, and whether it has 0 or >0 length shouldn't affect it's height much
	should I always have a paragraph inside it, even empty? seems the easiest thing to do
timers have a problem in vids-polygon
	apparently rate: when set still has /parent= none, but global timer event-func is primed
	since other faces and their timers are present, this resets /rate to none since it cannot see a tree yet
	ideally I only want to populate rated-spaces after they were rendered, never before
	since who knows how many spaces can be created but never brought alive
	I'm thinking /rate change would simply invalidate the space (at least when switching from/to none or 0?)
	and render then will add it to rated-spaces list so it's not active until rendered 
simpler clipboard format idea:
	instead of paragraphs appearing in it
	I can put /data: chars and spaces, as a plain block
	and use lf for paragraph split!
	but... how to pack together items and attributes? doesn't seem simpler without it
	I could make data have [items attrs] format, and mark it as 'rich-text, allowing other formats to be held too
	and maybe pluggable format converters (but seems like reinventing the document/format)
	another option is to instead of block, copy whole document (clipped)
	postponed until more data
undo/redo/history in document
	snapshots not on every letter but:
	- on pauses? - e.g. a second after last change
	- every second or so?
	- on enter!
	- on movement keys? - may mark end of the edit
	- on space?
	- on undo/redo!
	what can be undone/redone:
	- remove/insert chars with attrs into paragraph 
	- remove/insert spaces with attrs from a paragraph
	  for this I need these spaces to retain sameness, and probably retain it between undos/redos, so no cloning should be done
	  OTOH if I insert space multiple times I will have to clone it every time
	  so I clone stuff from clipboard before inserting it, but then put it unchanged into the history
	  so document/insert should not clone anything by itself, but actions/paste should (actually clipboard/read does that)
		removals have to keep stashed items, but insertions? not necessarily, as it's in the items already
		OTOH it may be simpler to keep them always:
			insert offset [items attrs]
			remove offset [items attrs]
	- split/unify paragraphs - this is getting complicated
	  rather it may be easier to linearly map data to document, replacing lfs with new paragraphs
	  just need to remodel copy & insert, and that will help remodelling clipboard later
	- alignment - need to track value before and after
	- indentation - same
	- bullets - technically, spaces, so no special case? at least if I remove/insert them but don't change /text in place
	- dunno about default font/color change? it probably should not be exposed or tracked, sort of default program settings
	- what about another document within e.g. a grid cell? ideally undo/redo history should cover all sub-documents, or it will be weird
	  so each entry in the history will also include the document it comes from
	  and it should not then belong to the document, but to what? global thing?
	  it will also be weird to share history across multiple fields or multiple not nested documents
	  perhaps nested documents should somehow commit to parent's history? e.g. by tracking it up the tree?
	  then what if document is moved from one parent into another? clearly need to disconnect their histories
	  this model will also require focus to move between parent and child documents on undo/redo
	  and each should have equal access to the timeline
	  e.g. child may trigger undo/redo in parent and delete itself on undo, but on redo focus may be restored into child
	- caret movement: history should track caret's offset and restore it
	- selection: always clear it? or track too?
multiple keys become a problem:
	if each character forms a single undo entry, then even if I group them eventually, it's too heavy
	but scanning whole document is still heavier
	shit! even grouping only code is still too heavy, need to diff somehow
	or don't add a timeline point until ready, but that still needs tracking of all events
	if map is 4k, 4MB means 1000 single char edits, too small, and map is likely bigger still
	need some smart timeline grouping later that will unify similar subsequent events into one
generalized timelines
	i.e. for undo/redo, browsing experience, what have you
	receiver (space) + forward command (block) + backward command (block)
	which can be just two blocks probbably, with receiver appearing in the call paths as e.g. doc/edit, but then need to anonymize it
	so better with receiver after all
	so parent/child documents will be connected somehow to the same shared timeline and commit events there and request it to act upon them
	and timeline action (undo/redo) will focus relevant document if focus is applicable
	timeline: .x.x.x.x. where x is an event that has 2 directions: forward and backward, and . is 'time' point that is between events
	focus belongs to a time point, not to an event, and may be restored when that point is hit
	(for browser, event may be just page choice, or url setting)
	or! focus may belong to an event - where that event is performed, why not? even simpler to implement
have an idea of simplifying attributes further
	instead of a map (name -> [values: [values] mask: "mask"])
	I could hold values separately, maybe in a global registry
	and locally can then have #(name "mask") map for every chunk/paragraph
	or I could intermix each item with an attr string: [item1 "attrs1" item2 "attrs2"...]
	but that would require "attrs" have a single char per each registered attr `name`
	which is way less than a map, but being repeated for each item not so optimal
	lets see..
		map itself is 300-400b normally
		4x 256-char strings normally take 1.1kb
		4-char string is 44 bytes (up to 16 chars always 44), 256 such strings = 11.2kb, quite big
	unfortunately, chars are not truly 32-bit, but limited to 110000h (1.1M) :(
	another option: encode each unique attribute set as an integer
	then 256 int cells = 4kb, but waaay less maintenance
	the only danger is someone making a rainbow out of the document with 16M text colors by 16M backdrops
	which is an unpractical stretch anyway
	realistically at the max there's 1 attribute set per char, so one needs 4G of text to cover the whole range
how to map attributes to sets and back?
	integer -> set is trivial, but given a set?
	suppose I order it somehow, e.g. attributes names and values are sorted
	blocks however are not hashed so attr lookup is linear
	I could hash it myself.. and then look up by the hash
	if attribute values are: logic, integers, tuples, strings
	plus names are words
	so I can: mold the set of values, run sha1 over it and then index by this sha1 hash (binary is hashed by `hash!`)
	instead of mapping hash to integers I can directly put hashes into /data (on sameness basis)
	however it will be unreadable in case of mold, so better use integers
can document hold a gist of all paragraph data blocks?
	if paragraph's /data is replaced, it won't know though, not without custom invalidator that tracks the change
	still ideally it has to be a tree... with custom invalidator it will be quite scalable
need better timeline in document
	[move new | move old]  - may be unnecessary
	[select new | select old]
	[indent para-index new | indent para-index old]	
	[align para-index new | align para-index old]	
	[insert SxE data | remove SxE]
	[remove SxE | insert SxE data]
	grouping rules:
	move - replaces the other move, or is appended
	select - ditto
	indent, align - ditto
	inserts - groupable if E1 = S2 and no insert/remove after it
	removes - groupable if S1 = S2 or S1 = E2 and no insert/remove after it
	remove+insert - not groupable
	insert+remove - groupable if E1=E2 and no insert/remove after it
	remove/insert affects para-index of subsequent indent/align, so those can't follow it either
	hmm if I group insert + remove I get an undo action with no effect
	so either I detect that and remove the action, or simpler don't group inserts and removals into one
how to handle slicing of the document?
	only paragraphs can carry the indent/align attributes, so for copy/paste it has to be paragraphs, not data
	codify: inserts whole paragraphs on undo, but for redo may use a slice
	linkify: inserts/removes whole paragraphs
	mark: inserts/removes whole paragraphs, but can be implemented as 'change' of data
	typing: inserts char that is then painted, but for redo has to remember both char and attribute
	removal: for undo has to remember char and attribute (or if range is removed - whole paragraphs)
		also if newline marker is removed, undo must restore the original paragraph
	looks like I have to support both.. shit
tricky copy/clone situation
	I can't clone data on insert, since that will not preserve the spaces on undo/redo
	but insert modifies paragraph's data directly, so paragraph has to be cloned, but not the spaces within
how to set focus into editor in VID/S??
	editor itself is not focusable - only documents in it (which may be nested)
	if I make it also focusable it's an extra tab stop that also autoredirects focus, and deadlocks tabbing
	document cannot be focused during editor construction, since until rendered there's no known path
	right! if I get rid of the path	in focus, I can directly set focus to a space then
	and when I need traversal for tabbing I can use /parent
	but how to make focus per-window? hook on-focus View event?
how to navigate to caret after edits?
	e.g. I insert a newline and it should be below the viewport
	but since it's not rendered yet, document doesn't have this data
	in fact, caret locations all should be seen as invalid after data changes
	for now I'll just trigger extra render, but need a better solution
	when to trigger? invalidation is not good enough criterion - caret movement becomes slow
	need to trigger it on edits only
	or flag it and let next render deal with it?

	
	
	
|                                                    <- total-width ->                                               |
^-- row-x1'                                                                                                row-x2' --^ (multiples of total-width)
^-- row-x1                                                                                                  row-x2 --^ (in 1D space)
|      <- indent1 ->      |                                      <- row-avail ->                                     |
|   <- indent2 ->    |                                         <- row-avail ->                                       |
|   <- indent2 ->    |                                         <- row-avail ->                                       |
(fill-aligned)       |word1  word2  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...  ...   wordi|_____ (trailing whitespace)
                     |     ^-- whitespace (distributed and inherent)                                                 | ^-- white-trail (unscaled)
(center-aligned)     |                                     wordi+1 wordi+2 ... wordn_____                            |
^-- row-x1                   =                    row-x1 --^                             ^-- row-x2    =    row-x2 --^ = next row-x1
|   <- indent ->     |          <- in-row-indent ->        |  <- row-used-width -> |      <- row-left-width ->       |
(left-aligned)       |wordi+1 wordi+2 ... wordn_____                                                                 |
                     |  <- row-used-width ->   |                        <- row-left-width ->                         |
(right-aligned)      |                                                                      wordi+1 wordi+2 ... wordn|_____
|   <- indent ->     |                              <- in-row-indent ->                     |  <- row-used-width ->  |

;@@ this totally deserves a design card
summary of paragraph layout:
	- limits are applied to canvas (by render, not the layout, which doesn't need to know about limits) 
	+ prep a 1D map of all children without spacing (spacing complicates X to child mapping significantly)
	+ align the map vertically along baseline
	+ build an indexed function of 1D x to index in the map -> will be used to quickly locate the space it lands on
	+ list all sections of a 1D space -> to determine min. section and to simplify the by-row splitting algorithm
	  also save total-1D-width, i.e. result of all sections summation -> needed by row layout algo since it does not use sections
	  mark leading whitespaces as significant, or at least ensure they become part of the 1st word
	+ list all words from sections, as X1..X2 1D ranges -> to split between words and to know used row size
	  output should also contain whitespace, so the format should be: [AxB width-1D' white? SxE...] (pair + pair + logic + pair)
	  where SxE is a slice of sections (offsets in the block)
	  one word may span multiple spaces (feature, not a bug), since at this point we don't know this relationship
	+ determine min. total width and if it's less than allowed row width, allowed width should be extended
	  -> so that there will be no single sticking out rows, and so row number can be estimated by simple division of 2D X by row width
		- if /force-wrap is on: this step is skipped, and canvas is respected
		- if /force-wrap is off: determine as max word width
	  total width is found according to the catch-22 algorightm described above
	+ available row-width1 and row-widthN are determined from allowed width and indents:
	  as (total-width - indent1) and (total-width - indent2)
	  -> these tell how many pixels is there available for each row in unscaled 2D
	- lay out each row:
		;@@ need to split tasks: first create rows, then align them, pad with whitespace (at least for each row)
		+ row-x1-1D' = row-number * total-width = this row's x=0 in unrolled CS
		  row-x1-1D = first word's x1
		  row-x2-1D' = row-x1-1D' + total-width
		+ take a number of words until they fit the row-width (in all modes except 'scale)
		  in scale mode: take words until scaling ratio worsens
		  ensure at least 1 word per row
		  format same as words
		  empty words are always added
		+ if only single word is in the row and mode <> 'scale:
		  cut only a part of the word, based on it's sections range, until they fit the row-width
		  ensure at least 1 section per row
		  + if only single section is in the row and force-wrap = on
		    cut this word further until it fits row-width
		    ensure at least 1 pixel per row (need a special case somewhere for 0 row-width as it may be slow)
		+ row-x2-1D = last (empty or not) word's x2
		+ used-row-width = x2 of last non-empty word - x1 of first word (only in 'scale mode may be > row-width)
		+ in fill mode only if number-of-words > 1 (otherwise left-aligned):
		  + determine additional whitespace between words as:
			whitespace = (max 0 row-width - used-row-width) / number-of-words
			(becomes 0 if used > min)
			quantize whitespace as a vector, so we'll have whole-pixel coordinates for Draw
			distribute whitespace across width-1D' of empty row-words
		+ in all modes other than fill, unify row-words into one (save for trailing whitespace)
		  set it's width-1D' to:
		  + used-row-width in left/right/center modes
		  + row-width in upscale/scale modes
		  now produced word vector doesn't depend on alignment at all, simplifying draw
		- accumulate row xs in the function data:
		  + store left row margin: [row-x1-1D  row-x1-1D']
		  + store indent:
		    indent does not depend on alignment, always located to the left (textmaker and google docs agree with that)
		    factor = select [left 0 scale 0 upscale 0 fill 0 right 1 center 0.5] align
		    in-row-indent = round/ceiling row-width - used-row-width * factor
		    [row-x1-1D  row-x1-1D' + indent + in-row-indent]
		  + store words, each as:
		    word-x1-1D' = offset that starts at (row-x1-1D' + indent + in-row-indent) and accumulates word width
		    word-x2-1D' = word-x1-1D' + word-width-1D'  (last value may have been scaled)
		    also calc word-x1-2D and word-x2-2D -> will be used in draw
		    [word/2 word-x2-1D'] (only closing point, opening is there already)
		    this includes trailing whitespace (empty sections), but it requires a special case:
		    word-x2-1D' = min word-x2-1D' row-x2-1D' (downscale the last empty word)
		  + trailing empty area (no sections) needs not storing, as it will be added by left row margin
		    function should be smart enough to skip the same point added multiple times
		+ accumulate vertical row offset
		  + find spaces used by row from row-x1-1D and row-x2-1D
		  + determine row-height: as max size/y over the slice of spaces
		  + determine row-y1-1D: as min offset/y over the slice of spaces
		  + row-y1-2D: starts at 0 and accumulates row-height of finished rows
		  instead of keeping both row-y1-1D and row-y1-2D, keep the difference row-y0-2D: row-y1-2D - row-y1-1D
		  [row-x1-1D row-y0-2D row-x2-1D row-y0-2D]
		  draw will be adding each geom/offset/y to this difference
		  still need real row vertical ranges - for click to row translation! 
		+ draw each word (empty or not):  
		  + find spaces(objects) used by this word:
		    feed each word's x1 and x2 into x-to-map func - this gets us a list of geoms
		  + word's scale = word-width-1D' / (word-x2-1D - word-x1-1D)
		  + drawn-spaces = [draw code for involved spaces starting at 0x0]
		  + first space's x offset offset1 = word-x1-1D - geom1/offset/x
		  + drawn-word = compose/only [
		  		translate (word-x1-2D by 0)			;) moves to the 2D point
		  		scale (word-scale) (1.0)
		  		clip 0x0 (word-x2-1D - word-x1-1D by row-height)
		  		translate (0 - offset1 by 0)		;) accounts for starting in the middle of a word /drawn
		  		(drawn-spaces)
		    ]
		    collect these into drawn-words, separate with `push`
		+ draw the row: drawn-row = compose/only [
			translate (indent + in-row-indent by row-y0-2D)
			(drawn-words)
		  ]
    + build a 1D/2D indexed x mapping out of xs vector accumulated from rows
    + carets don't need mapping built in advance - rather, let it be created when need arises
		
	
;@@ what about general funcs that realign parts of the map vertically/horizontally (modify)? for paragraph and tubes

;@@ on over events are too populous now, need to reduce the load
	

;@@ don't treat margin as empty section, only spacing - or outline/frame will be cut
 
	

;@@ rename rich-paragraph to rich-text? or is there a place for single-line rich-text in layouts?
;@@ split rich-content text on font/size change!
;@@ ensure not only last row is not scaled, but those before the linebreak as well! assertion maybe too?
;@@ try tube/stripe/fill setting it to -1x-1 on tube-test
;@@ remove non-pair (integer) support from margin & spacing? it's too much trouble overall, with 'along' and checks and conversion
;@@   instead, I could let on-change convert them into pairs automatically
;@@ instead of decode canvas calls everywhere, consider decoding it inside render! passing as 2 args (or 3 args fill-x fill-y?)
;@@ monospace flag for rich-content? - to model extensibility on it
;@@ date selector widget in the text? - to copy it into clipboard as date?
;@@ make start-drag automatic? although what if I want to pass a parameter... plus, how to know which space in the path start the drag?
;@@ document /indent format
;@@ document source format, maybe as a design card!
;@@ move source description into reference?
;@@ document /format facet.. also measure/edit if I keep them
;@@ document image/data block format (draw)
;@@ document strike style
;@@ document cache and generations as I tend to forget how it works all the time
;@@ undocument apply-attributes, devise & document the replacement after fixing redmark


Timer design:
- we want to maintain the desired frequency of updates (otherwise every animation/game will be CPU dependent)
  but at the same time we don't want to lock execution in a single timer when it takes longer to process than it's period
  so we have to be able to drop events but since this affects the animation, a warning should be printed
  and we want to be able to disable those warnings for production code
- on a W10 laptop in battery saving mode face timer never repeats in less than 14ms, but usually it's 14-30ms
  but if we use `wait 0` as yield func, we never get intervals more than 15ms
- in performance mode timers are still 65 fps, so are `wait 0` granularity
- will need multimedia timers for anything more precise, or at least will need to set system timer to 0.5ms interval
  (that's 2000 fps compared to current 65 fps)
  this will increase the power consumption though (from what I read on the web)
- so there is very little point in doing our own event loop, just to improve the fps by a negligible effect
  and for now just using `rate 100` dispatcher should be good enough
- yet we can improve the animation by providing the delay to timers
  e.g. desired rate = 50fps = 20ms, if 30ms have passed that's 50% delay, if only 10 then that's -50% delay
  (0% would mean a perfect match)
  then one should scale the animation to that delay
  or 100% would be perfect match, 50% for 10ms, 150% for 30ms? it's a question of `dt` vs `dt - 1`
  depends on the argument name also, if it's `delay` then `dt - 1`, if it's `scale` then `dt`
- this will require a table of all timers' last trigger time
- how to determine *when* to call a timer handler?
  e.g. host has rate 67 = 15ms, and child has rate 30 = 33 ms
  if we only call the timer *after* the guaranteed 33 ms, we will get really 45 ms
  so it makes sense to call the timer before it expires, like up to 7ms before? half of the host resolution
  no that's bad.. rather we should accumulate bias and try to minimize it...
  OK it works up to 64 fps, where timer is slower than the desired fps...

MUSEUM
this is bad because it mirrors the code from draw
; into: function [xy] [
; 	any [
; 		all [within? xy 0x0 box  reduce [content xy]]
; 		all [box/x < size/x  within? xy o: box * 1x0 vscroll/size  reduce [vscroll xy - o]]
; 		all [box/y < size/y  within? xy o: box * 0x1 hscroll/size  reduce [hscroll xy - o]]
; 	]
; ]
; into: func [xy] [
; 	any [axis = 'x  xy: reverse xy]
; 	all [
; 		within? xy 0x0 size
; 		any [
; 			all [xy/x < back-btn/size/x  reduce [back-btn xy]]
; 			all [xy/x >= (size/x - forth-btn/size/x)  reduce [forth-btn xy - (size - forth-btn/size * 1x0)]]
; 			all [xy: xy - (1x0 * size * offset)  xy/x >= 0  xy/x < (size/x * amount)  reduce [thumb xy]]
; 		]
; 	]
; ]

this is bad because it doesn't build a map, and consequently we can't hittest against the map
; (back-btn/draw)
; ; (put items 'back-btn 0x0  back-btn/draw)
; translate (map/thumb/offset: o: back-btn/size + (stripe * offset) * 1x0) [
; 	(thumb/draw)
; ]
; translate (map/forth-btn/offset: back-btn/size + stripe * 1x0) [
; 	(forth-btn/draw)
; ]

this can't work because of #4788
; cached-length: none				;-- set to none when it's out of date
; on-deep-change*: function [owner word target action new index part /extern cached-length] [
; 	;@@ TODO: more actions
; 	;@@ BUG: on-deep-change is a mess, totally useless
; 	;@@ e.g. take/last - reports index=0 and series at head, so how to figure out the changed part?
; 	nitems: length? items
; 	case [
; 		none? cached-length [exit]				;-- nothing to modify
; 		word <> 'items      [exit]				;-- it's not items that changed
; 		any [
; 			'cleared = action 
; 			all [part * 3 > nitems  nitems > 10]	;-- part is too big: better recalculate size normally
; 		][
; 			cached-length: none  exit
; 		]
; 		find [appended poke poked] action [
; 			target: skip target index
; 			+-: :+
; 		]
; 		find [inserted remove take cleared change changed] action [
; 			+-: :-
; 		]
; 		'else [do make error! "TODO: unsupported-action"]
; 	]
; 	partlen: 0
; 	repeat i part [
; 		item: get target/:i
; 		item-size: item/size
; 		partlen: partlen + item-size/:axis
; 	]
; 	partlen: partlen + (part * spacing/:axis)
; 	if part = nitems [partlen: partlen - spacing/:axis + (2 * margin/:axis)]
; 	+-: either find [inserted appended changed] action [:+][:-]
; 	cached-length: cached-length +- partlen
; ]

consequently this becomes too slow...
; cut-items: function [
; 	"remove items until list size is within constraints"
; 	where [word!] "head or tail"
; 	limit [integer!] "enforce min number of items to keep"
; ][
; 	items: content/items
; 	len1: get-length
; 	num1: length? items
; 	cut-one: select [head [take items] tail [take/last items]] where
; 	while [all [limit > 0  not within-limits?]] [
; 		limit: limit - 1
; 		do cut-one
; 	]
; 	len2: get-length
; 	num2: length? items
; 	reduce [num1 - num2  len1 - len2]
; ]
; within-limits?: function [] [
; 	len: get-length
; 	num: length? content/items
; 	all [len <= max-length  num <= max-items]
; ]
; get-length: has [size] [
; 	size: content/size
; 	size/(content/axis)
; ]

on-deep-change is no place for list refill, cause such thing becomes hard to control & predict
; if all [word = 'origin  source  content/items] [
; 	if case [
; 		;@@ TODO: where to hold this 200ms delay? where to enforce it?
; 		;-- one can click 'page-down' faster than 200ms and get to the end unnoticed, but 100ms - unlikely
; 		;@@ TODO: this means this delay has to be ONLY in on-over, but how?
; 		;@@ also it's bad to have origin auto changed (breaks code continuity) - better to have it on demand
; 		0:0:0.100 >= difference t: now/precise last-refill-time [no]
; 		origin/y >= (0 - look-around) [
; 			;@@ TODO: add-items/cut-items should happen inside draw, only planned here
; 			set [add-n: add-len:] add-items 'head jump-length
; 			cut-items 'tail add-n
; 			set-quiet 'source skip source 0 - add-n
; 			origin/y: origin/y - add-len
; 		]
; 		(csize: content/size clen: csize/:axis) - (map/content/size/:axis) + origin/y <= look-around [
; 			set [added:] add-items 'tail jump-length
; 			set [cut-n: cut-len:] cut-items 'head added
; 			set-quiet 'source skip source cut-n
; 			origin/y: origin/y + cut-len
; 		]
; 	] [set-quiet 'last-refill-time now/precise]
; ]

scaled triangle doesn't play well with styles including an outline
; triangle!: make space! [
; 	size: 16x10
; 	dir: 'n
; 	; need `into` here? or triangle will be a box from the clicking perspective?
; 	draw: function [] [
; 		set [p1: p2: p3:] select [
; 			n [0x2 1x0 2x2]								;--   n
; 			e [0x0 2x1 0x2]								;-- w   e
; 			w [2x0 0x1 2x2]								;--   s
; 			s [0x0 1x2 2x0]
; 		] dir
; 		compose/deep [
; 			push [
; 				scale (size/x / 2) (size/y / 2) [
; 					triangle (p1) (p2) (p3)
; 				]
; 			]
; 		]
; 	]
; ]

items in list's map do not have to have different names, as this requires too many words
and it also messes the map up when moving items around (e.g. in add-items 'head)
still, we need each `item` to refer to a unique object so we need context to wrap it (unless we drop names)
sadly (#4165) find/same word doesn't work, but there doesn't seem to be a need for it anyway
; add-item: function [] [
; 	p: make paragraph! []
; 	o: object compose [(to set-word! rejoin ["item" 1 + length? content/items]) (p)]
; 	append content/items w: first words-of o
; 	w
; ]

slower 2-3 times on error than the all [] approach
; focused?: function ["Check if current style is the one in focus"] [
;	attempt [(get last path) =? (get last keyboard/focus)]

version for styles like [item subitem [style]] - slower 5x
; get-style: function [
; 	"Fetch styling code for the current space being drawn"
; 	/named path [path! block!] "Path to look for (defaults to current-style)"
; 	/closing "Fetch a closure instead"
; ][
; 	path: tail as [] either named [path][current-style]
; 	#assert [not head? path]
; 	; if head? path [return []]							;-- empty path
; 	c: [
; 	table: either closing [closures][styles]
; 	; table: find table path: back path
; 	; unless table [return []]							;-- no such style
; 	attempt [			;-- stops when find/tail fails
; 		until [												;-- look for the most specific fitting style
; 			;-- search order here: from the space name (most common) to it's full path (most uncommon)
; 			;-- to eliminate the number of failed lookups (performance)
; 			p: back path
; 			t: back table
; 			until [block? first t: find/tail t p]
; 			style: t/1
; 			table: skip t 0 - length? p
; 			head? path: p
; 		]
; 	]
; 	]
; 	either 'hscroll = last head path [clock/times c 100000][do c]
; 	unless style [return []]
; 	; style: select table path
; 	#assert [block? style]
; 	space: get last path								;-- need to expose it's context to the style
; 	; print ["style for " head path "is" style]
; 	compose/deep bind style space			;@@ how slow this bind will be? any way not to bind?
; ]

version for styles like [item subitem [style]] but using parse - slower 10x
; get-style: function [
; 	"Fetch styling code for the current space being drawn"
; 	/named path [path! block!] "Path to look for (defaults to current-style)"
; 	/closing "Fetch a closure instead"
; 	/local style
; ][
; 	table: either closing [closures][styles]
; 	path1: as [] either named [path][current-style]
; 	#assert [not tail? path1]
; 	space: last path1
; 	c: [
; 	path: clear []
; 	parse path1 [collect into path any [set w word! keep (to lit-word! w)]]
; 	append path: tail path [set style block!]
; 	until [
; 		path: back path
; 		any [
; 			not parse table [to path to end]
; 			head? path
; 		]
; 	]
; 	]
; 	; #assert [block? style]
; 	either 'hscroll = space [clock/times c 100000][do c]
; 	unless block? style [return []]
; 	space: get space								;-- need to expose it's context to the style
; 	; print ["style for " head path "is" style]
; 	compose/deep bind style space			;@@ how slow this bind will be? any way not to bind?
; ]

looks much less obfuscated using `with` and `map-each`
; context [
; 	w: table: none
; 	foreach table [styles closures] [						;-- replace words with paths
; 		parse get table [any [change only set w word! (to path! w) | skip]]
; 	]
; ]

update command should not exit from the event handler
; update: does [throw/name 'update 'event-command]

doesn't work because of #4802
; actors: [
; 	;-- using lightweight wrapper instead of the direct link to :event/dispatch
; 	;-- for actors will be copied at some point and we want as little footprint as possible
; 	on-down: on-up: on-mid-down: on-mid-up:
; 	on-alt-down: on-alt-up: on-aux-down: on-aux-up:
; 	on-dbl-click: on-over: on-wheel:
; 	on-key: on-key-down: on-key-up: on-enter:
; 	on-focus: on-unfocus: func [face event] [events/dispatch face event]
; ]

moved this into the proper event handlers, became less messy
; on-down [
; 	; events/dispatch face event
; 	set-focus face
; 	path: hittest test event/offset
; 	?? path
; 	;-- keyboard support
; 	path2: parse path [collect any [keep word! | skip]]
; 	while [not empty? path2] [
; 		either find keyboard/focusable last path2 [break] [take/last path2]
; 	]
; 	unless empty? path2 [keyboard/focus: path2]
; 	?? keyboard/focus
; 	;-- scrolling support
; 	either where: any [
; 		find path 'hscroll
; 		find path 'vscroll
; 	][
; 		axis: select [hscroll x vscroll y] where/1
; 		ss: get where/-2
; 		drag-in: none
; 		move-by: :scrollable-space/move-by
; 		switch where/3 [
; 			forth-arrow [move-by ss 'line 'forth axis  ss/refill]
; 			back-arrow  [move-by ss 'line 'back  axis  ss/refill]
; 			forth-page  [move-by ss 'page 'forth axis  ss/refill]
; 			back-page   [move-by ss 'page 'back  axis  ss/refill]
; 			thumb       [drag-in: reduce [where axis ss/origin]]
; 		]
; 		face/draw: render test 'root
; 	][
; 		;-- not on a scrollbar
; 		if where: find path 'content [
; 			ss: get where/-2
; 			drag-in: reduce [where 'list ss/origin]
; 		]
; 	]
; ]
; on-up [
; 	events/dispatch face event
; 	drag-in: none
; ]

this design is too hard to reverse properly (for tabbing), and is also tricky to get right & to follow
I'm not using an iterator for this is time critical code and iterator would at least double the 'select' count
if we don't do it recursive, we'll have to find where we are on the map every time we wanna get one level up
so it is recursive
no return value for simplicity & speed
`continue` can be used but not break (too much overhead to support it)
; foreach-space*: function [spec [block!] path [path! block!] "(modified)" dir [word!] "forth or back" code [block!]] [
; 	space: get name: path/1
; 	if map: select space 'map [
; 		path: next path
; 		either dir = 'forth [
; 			if name: path/1 [map: find/skip map name 2]
; 			end?: [tail? map: skip map 2]
; 		][
; 			map: either name: path/1 [find/skip map name 2][at tail map -2]
; 			end?: [head? also map map: skip map -2]
; 		]
; 		until [
; 			change path map/1			;@@ do we want to expose geometry to code?
; 			foreach-space* spec path dir code
; 			clear path
; 			do end?
; 		]
; 	]
; 	set spec head change change/only [] head path space
; 	loop 1 code
; 	; clear path
; ]

first space in the `path` determines the root (upmost space in the tree)
foreach-space will jump to other branches but can't go behind it
thus `path = to path! host/space` designates the whole tree as iteration range
`path = some window or panel` designates a root face, iterating only over hosts inside it ;@@ TODO
to limit the scope just shorten the path
iteration starts with the root path (no way around it), then to the first child or first neighbor
/back affects only neighbor iteration direction, but it's still top down always
; foreach-space: func [
; 	'spec [word! block!] "path or [path space]"
; 	path [word! path! block!] "Starting path"
; 	code [block!]
; 	/back "Traverse in the opposite direction"
; ][
; 	foreach-space*
; 		to block! spec
; 		to path! path		;-- makes a copy (will be modified), also forces index to 1 (so `head` will be relative to it)
; 		pick [back forth] back
; 		code
; ]

; scrap design where style name was overridden from the /style facet
; 	it caused too much complexity but was limited:
; 	it required every space to define it's name
; 	but that didn't help, as then every 'back-arrow' and shit would become just 'triangle'
;   background: we don't want events for 'triangle' but may want them for 'back-arrow', so we use map names.
;     but we don't want event for 'content' (generic), we want them to what style 'content' points to.
;     for this to work /style override needs to be defined for every space but this kills the map names; doesn't work

; scrap design where 'content' was pointing to an object
; 	because that required the object to provide it's name somehow
; 	while all we have to do is say `content: 'name` and that solves it all

; scrap design where map had 'content' word that pointed to another word and we would lay out e.g. `content/list` in map
; 	caused too much complexity in `into` functions

now generalized as an event previewer
; refocus: function ["internal use only" face [object!] path [block! path!] "words only (modified)"] [
; 	while [name: take/last path] [			;-- reverse order to focus the innermost space possible
; 		if find keyboard/focusable name [	;-- pairs are not found so skipped automatically
; 			f: face
; 			until [
; 				insert path anonymize f/type f
; 				none? f: f/parent
; 			]
; 			focus: append path name
; 			unless keyboard/focus = focus [
; 				#debug [print ["Moving focus to" as path! focus]]
; 				if all [
; 					old-name: last old-path: keyboard/focus
; 					handler: find-handler old-name 'on-unfocus
; 				][
; 					do-event old-name 'on-unfocus [handler keyboard/focus none]	;-- pass none as 'event'
; 				]
; 				set-focus face
; 				keyboard/focus: focus
; 				if handler: find-handler name 'on-focus [
; 					focus: append clear [] focus					;-- copy it in case user modifies/reduces
; 					do-event name 'on-focus [handler focus none]
; 				]
; 				commands/update
; 			]
; 			break
; 		]
; 	]
; ]

turns out scrollbars don't get focus in all programs I have around..
somehow I think in old versions of Windows it was the case, but apparently not anymore
; focusable: make hash! [scrollable hscroll vscroll]
; scrollable/on-key-down [path event] [
; 	set [ss: scroll:] reduce path
; 	;@@ TODO: keys for the ss itself
; 	unless scroll [pass exit]				;-- let the inner spaces take it
; 	axis: scroll/axis
; 	move-by: :scrollable-space/move-by
; 	code: switch event/key [
; 		down right [[move-by ss 'line 'forth axis]]
; 		up left    [[move-by ss 'line 'back  axis]]
; 		page-down  [[move-by ss 'page 'forth axis]]
; 		page-up    [[move-by ss 'page 'back  axis]]
; 	]
; 	either code [
; 		do code
; 		update
; 	][
; 		pass								;-- key was not handled (useful for tabbing)
; 	]
; ]

it's unwise to prepare the whole data array for display (can be huge)
instead, pickers should be defined to prep lines of data when needed
; spaces/table: [
; 	...
; 	prep-data: function [] [						;-- preps data for display, independent of `source` format
; 		pin: min pinned dim: data/size
; 		prep-into  1x1                  pin                  pinned-headers/source
; 		prep-into  as-pair pin/x + 1 1  as-pair dim/x pin/y  normal-headers/source
; 		prep-into  as-pair 1 pin/y + 1  as-pair pin/x dim/y  pinned-columns/source
; 		prep-into  pin + 1x1            dim                  normal-columns/source
; 	]
; 	prep-into: function [xy1 xy2 tgt] [
; 		if any [xy1/x < xy2/x  xy1/y < xy2/y] [clear tgt  exit]
; 		w: xy2/x - xy1/x + 1
; 		for y: xy1/y xy2/y [
; 			either row: tgt/:y [clear row][append/only tgt row: make [] w]
; 			for x: xy1/x xy2/x [
; 				append/only row data/pick x y
; 			]
; 		]
; 		clear at tgt y
; 	]
; ]

balancing row heights between 2 list-views is just too much effort:
- will have to pre-render to produce list items
- will have to change height constraints of each item in list (can be huge), then render again
- will have to reset those constraints post-render, so next render is not affected
instead, a single list-view should be made with each row supporting pinned columns
; spaces/table: [
; 	...
; 	draw: function [] [
; 		maybe pinned-columns/index: normal-columns/index	;-- sync indexes
; 		maybe pinned-columns/origin: as-pair pinned-columns/origin/x normal-columns/origin/y	;-- sync origin
; 		maybe normal-headers/origin: as-pair normal-columns/origin/x normal-headers/origin/y
; 		; can we get rid of extra render??? need better pipeline
; 		foreach [name _] map [render name]			;-- prerender lists to ensure they all have enough `items`
; 		;-- balance row heights and cell widths
; 		foreach [left right] reduce [
; 			pinned-headers normal-headers
; 			pinned-columns normal-columns
; 		] [
; 			repeat y length? right/list/items [
; 				litem:  left/list/items/:y
; 				ritem: right/list/items/:y
; 				unless all [litem ritem] [continue]		;-- one of the lists is shorter
; 				litem: get litem  ritem: get ritem
; 				case [
; 					litem/
; 				]
; 			]
; 		]
; 		; reset constraints so they won't affect the next render; any better idea????
; 	]

unused
; list-ctx/item-box: function [list i [integer!]] [
; 	if word? list [list: get list]
; 	ofs: list/margin
; 	if i > 1 [
; 		guide: select [x 1x0 y 0x1] list/axis
; 		ofs: ofs + (guide * list/size/only 1 i - 1)
; 	]
; 	reduce [ofs list/size/only i i]
; ]

this doesn't work if word = 'value, silly mistake
; anonymize: func [
; 	"Return WORD bound in an anonymous context and set to VALUE"
; 	word [word!] value [any-type!]
; ][
; 	bind word object compose [(to set-word! word) :value]
; ]

doesn't work if value is a set-word
; anonymize: func [
; 	"Return WORD bound in an anonymous context and set to VALUE"
; 	word [word!] value [any-type!]
; ][
; 	bind word construct/only compose/only/into [(to set-word! word) (:value)] clear []
; ]

didn't use it
; grid-ctx: context [
; 	;-- grid is like list - simply arranges spaces given to it
; 	;@@ should grid/list be called grid/row or not? technically it may be grid/column as well...
; 	spaces/grid: make-space/block 'list [
; 		;-- `items` should contain lists to display, though these lists are not exposed in the map
; 		axis: 'y			;-- items = rows by default
; 		pinned: 0x0			;-- how many rows/columns to pin (move data to the head to make it pinned)

; 		draw: function [/only xy1 xy2] [
; 			;@@ keep this in sync with `list/draw`
; 			r: make [] 10
; 			guide: select [x 1x0 y 0x1] axis
; 			clear map
; 			max-size: 0x0									;-- size of the biggest item in a column/row
; 			i-item: 1										;-- item (column by default) index
; 			p: margin
; ;@@@ SHIT so much useless low level code here! how to generalize? how not to write grid-view after list-view? how to lay out items in one expression?
; 			while [max-size/x >= 0] [						;-- becomes <0 when no more items
; 				max-size: -1x-1
; 				foreach list-name items [
; 					list: get list-name
; 					item-name: pick list/items i-item
; 					item: get item-name
; 					drawn: none
; 					skip?: if only [
; 						unless item/size [drawn: render item-name]	;-- prerender to get the size
; 						max-size: max max-size item/size
; 						p2: p + item/size
; 						isec: (min p2 xy2) - (max p xy1)			;-- intersection size
; 						isec <> max isec 1x1						;-- optimized `any [isec/x <= 0 isec/y <= 0]`
; 					]
; 					unless skip? [
; 						;@@ TODO: style selected-item?
; 						compose/only/into [translate (p) (any [drawn  render item-name])] r
; 						compose/deep/into [(item-name) [offset (p) size (item/size)]] tail map
; 					]
; 				p: p + (spacing + item/size * guide)
; 				p: max p item/size
; 			]
; 			self/size: p + margin
; 			r

; 		]

; 		on-change*: function [word old [any-type!] new [any-type!]] [
; 			if word = 'axis [
; 				if :old = :new [exit]
; 				normal: select [x y x] axis
; 				foreach item items [		;-- dynamically switch each list's direction
; 					spc: get item
; 					spc/axis: normal
; 				]
; 			]
; 		]
; 	]
; ]

tabbing is trickier than expected:
when I move focus in `key-down` to another face (e.g. field)
next `key` event goes to that face instead
so I need to delay focus change until `key` event fires
cannot use `key-up` since it does not repeat
can use `key` directly but will miss Ctrl-Tab, used by field/area
option: use `key`, miss Ctrl-Tab, but let area/field have some 'unfocused' state changed by Esc/Enter
(this will help spatial navigation as well)
; register-finalizer [key-down] function [space [object!] path [block!] event [event!]] [

this didnt scale:
in the end I had to include style name into the definition block,
else define-handlers doesn't have the name and thus can't accept inner styles
also error reporting was inferior
; extend-handlers: function [
; 	"Extend event handlers of STYLE"
; 	style [path! word! map!] "Style name, path or a map of it's event handlers"
; 	def [block!] "A block of: on-event-name [spec..] [code..]"
; ][
; 	all [
; 		not map? map: style
; 		none? map: get as path! compose [handlers (style)]
; 		map: #()
; 	]
; 	#assert [map? map]
; 	r: copy-deep-map map							;@@ BUG: copy/deep does not copy inner maps unfortunately
; 	while [not tail? def] [
; 		either word? :def/1 [						;-- on-event [spec] [body] case
; 			set [name: spec: body:] def
; 			def: skip def 3
; 			list: any [r/:name r/:name: copy []]
; 			#assert [								;-- validate the spec to help detect bugs
; 				any [
; 					parse spec [
; 						word! opt quote [object!]
; 						word! opt quote [block!]
; 						word! opt [quote [event!] | quote [event! none!] | quote [none! event!]]
; 						opt [if (name = 'on-time) word! opt quote [percent!]]
; 						opt [/local to end]
; 					]
; 					(?? handler  none)				;-- display handler to clarify what error is
; 				]
; 				"invalid handler spec"
; 			]
; 			append list function spec bind body commands
; 		][											;-- substyle: [handlers..] case
; 			#assert [not map? style]				;-- cannot be used without named style
; 			#assert [set-word? :def/1]
; 			set [name: spec:] def
; 			def: skip def 2
; 			unless r/:name [r/:name: copy #()]
; 			; name: to word! name
; 			substyle: as path! compose [(style) (to word! name)]
; 			r/:name: extend-handlers substyle spec
; 		]
; 	]
; 	r
; ]


list-view's infinite space logic is now decoupled from the list logic
; ;@@ TODO: chat will need reverse indexing... though how about `source` function gets -1 -2 -3 ... ?
; ;-- there's a lot of logic in this space only to make it fast
; ;-- list items may vary in size, and not knowing the size of each item
; ;-- we can't just multiply the index by some number, we have to traverse the whole list
; ;-- but list can be huge, and all these functions try to minimize the size estimation effort
; list-view-ctx: context [
; 	spaces/list-view: make-space/block 'scrollable [
; 		source: []		;@@ or a function [index]? or support both?
; 		data: function [/pick i [integer!] /length] [
; 			either pick [source/:i][length? source]
; 		]
; 		index: 1										;-- index of the first item within source
; 		;-- geometric constraints:
; 		;-- * it will display at least 1 item but no more than max-items
; 		;-- * it will drop items starting after max-length along the axis
; 		;-- setting max-length to big enough value makes list size constant = max-items
; 		;-- big enough max-items makes list always show all of the items
; 		max-items:   200
; 		max-length:  10000
; 		jump-length: 100								;-- how much more to show when rolling (px)
; 		look-around: 50									;-- zone after begin and before tail that triggers roll-edge (px)
; 		roll-timer: make-space 'space [rate: 4]			;-- how often to call roll-edge when dragging (can't override scrollable/rate)
; 		list:  make-space 'list [axis: 'y]				;-- list/axis can be changed to get a horizontal list
; 		content: 'list
; 		;@@ TODO: on-change or assertions should ensure max-items >= 1, and sane values for the rest

; 		append map [roll-timer [offset 0x0 size 0x0]]		;@@ any better way to have a separate rate?

; 		filled?: no										;-- true when items are cached
; 		invalidate: does [set-quiet 'filled? no]		;-- call this to force items update

; 		wrap-data: function [item-data [any-type!]][
; 			spc: make-space 'data-view []
; 			set/any 'spc/data :item-data
; 			if list/axis = 'y [spc/width: size/x - (list/margin/x * 2)]		;@@ what data width to use for horizontal lists?
; 			anonymize 'item spc
; 		]

; 		scrollable-draw: :draw
; 		draw: function [] [
; 			any [filled? fill-items]
; 			scrollable-draw
; 		]
		
; 		add-items: function [
; 			"Insert items into list from position WHERE"
; 			where [word!] "head, tail or over"
; 			ext-len [integer!] "Min extension length in pixels (if enough available)"
; 			/local idata
; 		][
; 			x:         list/axis
; 			spc:       list/spacing/:x
; 			items:     list/items
; 			new:       clear []
; 			target:    either where = 'over [items][new]
; 			offset:    switch where [tail [index - 1 + length? items] over [index - 1] head [index]]
; 			available: either where = 'head [index - 1][data/length - offset]
; 			if 0 = available [return [0 0]]						;-- optimization
; 			;@@ it should not know list's internal spacing logic (in case we change the list).. but how?
; 			added-len: either empty? items [list/margin/:x * 2 - spc][0]
; 			+-:        either where = 'head [:-][:+]
; 			repeat i min max-items available [
; 				set/any 'idata data/pick offset +- i
; 				either item: target/:i [
; 					#assert [in get item 'data  "item should have a /data facet to be used in list-view"]
; 					set/any in get item 'data :idata
; 				][
; 					change at target i item: wrap-data :idata
; 				]
; 				item: get item
; 				unless item/size [render 'item]					;-- render it to get the size
; 				added-len: added-len + spc + item/size/:x
; 				if added-len >= ext-len [break]
; 			]
; 			added-num: any [i 0]
; 			switch where [
; 				head [insert items reverse new]
; 				tail [append items new]
; 				over [clear skip items added-num]
; 			]
; 			reduce [added-num added-len]
; 		]

; 		cut-items: function [
; 			"Remove items until list size is within constraints"
; 			where [word!] "head or tail"
; 			limit [integer!] "Enforce min number of items to keep"
; 		][
; 			items: list/items
; 			num1: length? items
; 			size: list/size
; 			x: list/axis
; 			len2: len1: size/:x
; 			; #assert [max-items >= limit]		;-- min shouldn't be bigger than max
; 			min-rem: num1 - max-items					;-- num items over max-items
; 			pick-item: select [head [first items] tail [last items]] where
; 			rem-item:  select [head [take items]  tail [take/last items]] where
; 			repeat i num1 - limit [
; 				item: get do pick-item
; 				item-size: item/size
; 				len3: len2 - item-size/:x - (list/spacing/:x)
; 				all [len3 < max-length  i >= min-rem  break]	;-- check if after removal list will be too short
; 				do rem-item
; 				len2: len3
; 			]
; 			num2: length? items
; 			reduce [num1 - num2  len1 - len2]
; 		]

; 		at-head?: does [(0 - origin/(list/axis)) <= look-around]
; 		at-tail?: function [] [
; 			x:     list/axis
; 			csize: list/size
; 			max-origin: csize/:x - map/list/size/:x
; 			(0 - origin/:x) >= (max-origin - look-around)
; 		]

; 		roll-edge: function [
; 			"Move position of ITEMS within DATA if origin has approached one of the edges"
; 			/head "Force adding items at the head"
; 			/tail "Force adding items at the tail"
; 			; return: [logic!]							;-- whether actually refilled or not
; 		][
; 			unless any [head tail] [head: at-head?  tail: at-tail?]
; 			if all [tail head] [return no]				;-- empty list or less than the viewport
; 			case [
; 				head [
; 					set [add-n: add-len:] add-items 'head jump-length
; 					cut-items 'tail add-n
; 					self/origin: origin - (add-len * 0x1)
; 					set-quiet 'index index - add-n
; 				]
; 				tail [
; 					set [added:] add-items 'tail jump-length
; 					set [cut-n: cut-len:] cut-items 'head added
; 					self/origin: origin + (cut-len * 0x1)
; 					;@@ BUG: we should trigger on-change/index so it can be detected by other spaces
; 					;@@ OTOH if we do, we cause another add-items/over call and lose the added items
; 					;@@ so how to solve this?
; 					set-quiet 'index index + cut-n
; 				]
; 				'else [return no]
; 			]
; 			yes
; 		]

; 		fill-items: does [
; 			add-items 'over max-length
; 			set-quiet 'filled? yes
; 		]

; 		;-- when to fill?
; 		;-- - width changes => new length
; 		;-- - text of one of the items changes => new length -- can't track this automatically
; 		;-- - source index changes => new content for each item
; 		scrollable-on-change*: :on-change*
; 		on-change*: function [word [word! set-word!] old [any-type!] new [any-type!]] [
; 			scrollable-on-change* word :old :new
; 			if find [source width index] word [invalidate]
; 		]
; 	]
; ]

development (non-reduced) version of extend-layout in case I break it later
; extend-layout: function [dir [word!] amount [integer!] /keep where [block!]] [
; 	; print ["extend" dir amount]
; 	lt: list/make-layout
; 	unless empty? list/items [amount: amount - lt/spacing/(list/axis)]
; 	switch dir [
; 		n w [+-: :-  n-max: (base: index) - 1]
; 		s e [+-: :+  n-max: data/length - base: index - 1 + length? list/items]
; 	]
; 	#assert [(select [n y s y e x w x] dir) = list/axis]
; 	repeat i n-max [
; 		name: wrap-data data/pick base +- i		;-- guarantee at least 1 item (else spacing could be bigger than the requested amount)
; 		#assert [not find/same list/items name]
; 		render name
; 		lt/place select get name 'size
; 		if keep [append where name]
; 		if lt/content-size/(list/axis) >= amount [break]
; 	]
; 	lt
; ]

; window/fill: function [xy1 [pair!] xy2 [pair!]] [
; print ["fill" xy1 xy2]
; 	;@@ TODO: e / w support
; 	#assert [0 = xy1/x]
; 	#assert [window/size/x = xy2/x]
; 	#assert [any [xy1/y = 0  xy2/y = window/size/y]]

; 	initial?: window/map/list/offset = 0x0				;-- on first fill, do not align with the lowest/rightmost edge
; 	x: list/axis
; 	dir: select
; 		pick [ [x e y s] [x w y n] ] xy2/:x = window/size/:x	;-- s/e = tail fill (or head to tail), n/w = head fill
; 		x
; 	switch dir [				;-- get already rendered parts out of the requested window
; 		n w [xy2/:x: xy2/:x - extra? dir]
; 		s e [xy1/:x: xy1/:x + extra? dir]
; 	]
; 	;-- window now lies purely outside of the list
; 	req-size: xy2 - xy1
; 	?? req-size
; 	lt: extend-layout/keep dir req-size/:x clear new: []
; 	#assert [not empty? lt/items]

; 	ext-size: lt/content-size/:x + either empty? list/items [0][lt/spacing/:x]

; 	offset: window/map/list/offset				;-- we can count invisibles right now from list/offset
; print [dir offset "new:" length? new "lt/size:" lt/content-size]
; 	rem: 0
; 	foreach': switch dir [n w [:foreach-reverse] s e [:foreach]]	 ;@@ should be for-each/reverse
; 	foreach' [name: geom:] list/map [			;-- count the number of invisible spaces
; 		o: geom/offset + offset
; 		visible?: bbox-overlap?  0x0 window/size  o o + geom/size
; 		either visible? [break][rem: rem + 1]
; 	]

; 	switch dir [										;-- add items
; 		n w [
; 			#assert [not empty? new]
; 			insert list/items reverse new
; 			self/index: self/index - length? new
; 		]
; 		s e [
; 			append list/items new
; 			maybe self/index: self/index + rem			;-- rem can be 0
; 		]
; 	]

; 	rem-size: 0
; 	if rem > 0 [
; 		removed: switch dir [								;-- add items, remove invisibles from `items` & `map`
; 			n w [
; 				take/last/part list/items rem
; 				take/last/part list/map rem * 2
; 			]
; 			s e [
; 				remove/part list/items rem
; 				take/part list/map rem * 2
; 			]
; 		]

; 		rem-1st: removed/2
; 		rem-last: last removed
; 		rem-size: rem-last/offset + rem-last/size - rem-1st/offset + lt/spacing
; 		rem-size: rem-size/:x
; 	]
; 	;-- now that we know removed size we can calculate the new list offset
; 	offset: switch dir [
; 		n w [
; 			ext-size * select [n 0x1 w 1x0] dir
; 		]
; 		s e [
; 			rem-size * -1 * select [s 0x1 e 1x0] dir
; 		]
; 	]

; 	foreach [name geom] list/map [					;-- relocate the visible spaces now that we know the offset
; 		geom/offset: geom/offset - offset
; 		;-- impossible to verify visibility here because we don't know list/offset until we get the size
; 		;-- and don't know the size until we render it and we can't render it until we relocate the items
; 		; o: window/map/list/offset + geom/offset: geom/offset - offset
; 		; expect [bbox-overlap?  0x0 window/size  o o + geom/size]
; 		; #assert [bbox-overlap?  0x0 window/size  o o + geom/size]
; 	]

; 	; unless list/size [render/only 'list xy1 xy2]	;-- refreshes list/size after removal ;@@ TODO: possible to get rid of it and use `lt`?
; 	; render/only 'list xy1 xy2		;-- refreshes list/size after removal ;@@ TODO: possible to get rid of it and use `lt`?
; 	either new-size: list/size [
; 		;-- update the size, without re-rendering anything
; 		new-size/:x: new-size/:x - rem-size + ext-size
; 		maybe list/size: new-size
; 		; render/only 'list xy1 xy2
; 	][
; 		;-- render the list to get it's size - should only be needed first time it's shown
; 		render/only 'list xy1 xy2
; 	]

; 	#assert [list/size]
; 	; lgeom: window/map/list
; 	window/map/list/size: list/size
; 	window/map/list/offset: switch dir [
; 		n w [0x0]
; 		s e [
; 			either initial? [0x0][
; 				window/size - list/size * select [s 0x1 e 1x0] dir
; 			]
; 		]
; 	]
; ]

got rid of this; now map name = style name
; get-style-name: function [
; 	"Transform MAP name into STYLE name"
; 	name [word!]
; ][
; 	space: get name
; 	all [
; 		new-name: select space 'style 					;-- allow space to enforce it's style
; 		name <> new-name
; 		;-- enforced name has to not to leak into globals and should have the same value as the name in map
; 		return anonymize new-name space					;@@ any easier way?
; 	]
; 	name
; ]

closures are now style/after
; get-style: function [
; 	"Fetch styling code for the current space being drawn"
; 	/named path [path! block!] "Path to look for (defaults to current-style)"
; 	/closing "Fetch a closure instead"
; ][
; 	table: either closing [closures][styles]
; 	path: tail as path! either named [path][current-style]
; 	#assert [not head? path]
; 	until [												;-- look for the most specific fitting style
; 		p: back path
; 		style: any [find/only table p  style]
; 		head? path: p
; 	]
; 	unless style [return []]
; 	style: first find style block!
; 	#assert [block? style]
; 	space: get last path								;-- need to expose it's context to the style
; 	; print ["style for " head path "is" mold style]
; 	compose/deep bind style space			;@@ how slow this bind will be? any way not to bind?
; ]

now powered by trap mezz, simpler
; do-handler: function [spc-name [path!] handler [function!] path [block!] args [block!] /local result] [
; 	path: cache/hold path							;-- copy in case user modifies/reduces it, preserve index
; 	space: get path/1
; 	code: compose/into [handler space path (args)] clear []
; 	error: try/all [set/any 'result do code  'ok]
; 	cache/put path
; 	unless 'ok == error [
; 		msg: form/part error 400					;@@ should be formed immediately - see #4538
; 		print #composite "*** Failed to evaluate (spc-name)!"
; 		print msg
; 	]
; 	:result
; ]
; do-global: function [map [map!] path [block!] event [event! none!] type [word!]] [
; 	unless list: map/:type [exit]
; 	kind: either map =? previewers ["previewer"]["finalizer"]
; 	foreach fn list [
; 		pcopy: cache/hold path					;-- copy in case user modifies/reduces it, preserve index
; 		error: try/all [(fn get path/1 pcopy event)  'ok]
; 		cache/put pcopy
; 		unless 'ok == error [
; 			print #composite "*** Failed to evaluate event (kind) (mold/part/flat :fn 100)!"
; 			print form/part error 400
; 		]
; 	]
; ]

this style design can't be bound - didn't work
; cell [
; 	bgnd: [
; 		fill-pen (svmc/panel)
; 		box 0x0 (size)
; 	]
; 	render: function [] [
; 		before: compose/deep self/before
; 		?? draw
; 		drawn:  draw
; 		bgnd:   compose/deep self/bgnd
; 		after:  compose/deep self/after
; 		compose [(bgnd) (before) (drawn) (after)]	;-- composed order differs from evaluation order
; 	]
; ]

render now can accept a host face directly, and split into parts
; set 'render function [
; 	space [word! object!] "Space name; or host face as object"
; 	; /as style [word!]
; 	/only xy1 [pair! none!] xy2 [pair! none!]
; 	; /draw cmds [block! function!]
; 	; /root "Apply the styles/root as well (for topmost spaces)"
; ][
; 	either word? space [
; 		unset 'prefix
; 	][
; 		prefix: bind get-style 'host		;-- apply styles/root for topmost spaces
; 	]

; 	space: get name: space
; 	append current-style name			;-- used by get-style
; 	#assert [space? space]
; 	style: get-style					;-- call it before calling draw or draw/only, in case it modifies smth
	
; 	trap/all/catch [					;-- traps compose and draw calls errors
; 		if value? 'prefix [prefix: compose/deep prefix]
; 		either block? :style [
; 			style: compose/deep bind style space		;@@ how slow this bind will be? any way not to bind? maybe construct a func?
; 			draw: select space 'draw
; 			all [
; 				only
; 				function? :draw
; 				find spec-of :draw /only
; 				draw: draw/only xy1 xy2
; 			]
; 			render: compose [(style) (draw)]			;-- call the function if not called yet, inline blocks
; 		][
; 			#assert [function? :style]
; 			render: (style space)						;@@ TODO: /only support for it?
; 		]
; 	][
; 		msg: form/part thrown 400						;@@ should be formed immediately - see #4538
; 		print #composite "*** Failed to compose the style of (name)!^/(msg)"
; 		render: copy []
; 	]
; 	take/last current-style									;-- draw should be called before take/last, in case `draw` relies on current-style
; 	compose/only [(:prefix) push (render)]					;-- push should shield from style propagation
; ]

this fails because it considers context of the word, but we don't care about it
; same-paths?: function [p1 [block! path!] p2 [block! path!]] [
; 	to logic! all [
; 		(length? p1) = length? p2
; 		find/match/same p1 p2							;@@ won't work in master branch yet (#4165)
; 	]
; ]

this is too naive
; same-paths?: function [p1 [block! path!] p2 [block! path!]] [
; 	to logic! all [
; 		p1 == as p1 p2									;-- spelling & length match
; 		(
; 			repeat i n: length? p1 [					;-- values sameness
; 				unless same? get/any p1/:i get/any p2/:i [return no]
; 			]
; 			yes
; 		)
; 	]
; ]

REP #104 experiments, have no use for them anyway
; same-scalar?: function [v1 [any-type!] v2 [any-type!]] [
; 	to logic! any [
; 		:v1 =? :v2
; 		all [
; 			series? :v1
; 			(type? :v1) = type? :v2
; 			(length? :v1) = n: length? :v2
; 			(repeat i n [unless same-scalar? :v1/:i :v2/:i [return false]]  true)
; 		]
; 	]
; ]
; ;-- `find/match` using `same-scalar?` comparator
; find-match-same-scalar: function [series [series!] match [any-type!]] [
; 	if series? :match [
; 		repeat i n: length? match [
; 			unless same-scalar? :series/:i :match/:i [return none]
; 		]
; 		return skip series n
; 	]
; 	all [same-scalar? :series/1 :match  next series]
; ]
; ;-- `find` using `same-scalar?` comparator
; find-same-scalar: function [series [series!] value [any-type!]] [
; 	; while [series: find/case series :value] [		can't be used because find will never match nans
; 	while [not tail? series] [
; 		if find-match-same-scalar series :value [return series]
; 		series: next series
; 	]
; 	none
; ]
; #assert [same-scalar? 1.#nan 1.#nan]
; #assert [same-scalar? reduce [1.#nan] reduce [1.#nan]]
; #assert [r: find-match-same-scalar reduce [0.0 / 0.0 1.0 * 1.#inf] 0.0 / 0.0  'r]
; #assert [r: find-match-same-scalar b: reduce [0.0 / 0.0 1.0 * 1.#inf] copy b  'r]
; #assert [r: find-match-same-scalar b: reduce [0.0 / 0.0 reduce [1.0 * 1.#inf]] copy/deep b  'r]
; #assert [2 = index? r: find-same-scalar reduce [0.0 / 0.0 1.0 * 1.#inf] 1.0 * 1.#inf  'r]
; #assert [2 = index? r: find-same-scalar b: reduce [0 0.0 / 0.0 reduce [1.0 * 1.#inf]] copy next b  'r]

from grid/draw: this broke tabbing because cell objects were replaced after redraw
thus making keyboard/focus point to invalid object
of course it couldn't have a clue - replaced objects must be treated as different ones
;@@ TODO: this should be documented in the widget builders guide
; unless mcspace [
; 	render mcspace: rcache/:mcell: wrap-space mcell-content-name
; ]

from events/dispatch - causes stack overflow and crashes as expected (when UI lags a bit)
; if commands/update? [
; 	face/draw: render face
; 	do-events/no-wait
; ]

this window model was too convoluted to work with
; last-origin: last-size: none							;-- geometry during previous call to `renew`
; renew: function [] [
; 	unless all [last-origin last-size = max-size] [		;-- first ever invocation or size changed
; 		self/last-origin: origin
; 		self/last-size: max-size
; 		fill 0x0 max-size
; 		exit
; 	]
; 	if 0x0 = offset: origin - last-origin [exit]		;-- has not been moved
; 	self/last-origin: origin
; 	unless caching? [
; 		clear map
; 		fill 0x0 max-size
; 		exit
; 	]

; 	remove-each [name geom] map [				;-- clear the map of invisible spaces
; 		o: geom/offset: geom/offset + offset	;-- and relocate visible ones
; 		not bbox-overlap?  0x0 max-size  o o + geom/size
; 	]
; 	case [										;-- fill top/bottom before left/right (random decision)
; 		offset/y > 0 [fill  0x0  as-pair max-size/x top: offset/y]
; 		offset/y < 0 [fill  as-pair 0 btm: max-size/y + offset/y  max-size]
; 	]
; 	default top: 0
; 	default btm: max-size/y
; 	case [										;-- left/right excludes already drawn top/bottom regions
; 		offset/x > 0 [fill  as-pair 0 top  as-pair offset/x btm]
; 		offset/x < 0 [fill  as-pair max-size/x + offset/x top  as-pair max-size/x btm]
; 	]
; ]
; draw: function [/only xy1 [pair!] xy2 [pair!]] [
; 	old-origin: origin							;-- renew may change origin, in which case we don't wanna miss the viewport
; 	renew
; 	either only [
; 		visible: []
; 		foreach [name geom] map [				;@@ should be map-each
; 			if bbox-overlap? 0x0 max-size xy1 xy2 [append visible name]
; 		]
; 		r: compose-map/only/limits map visible xy1 - old-origin xy2 - old-origin
; 		clear visible							;-- let GC free it up
; 	][
; 		r: compose-map map
; 	]
; 	self/size: either empty? map [
; 		0x0
; 	][
; 		item-last: last map
; 		min max-size item-last/offset + item-last/size
; 	]
; 	r

(dispatch) this was supposed to provide real time updates but due to #4881 totally blocked the UI
; if commands/update? [
; 	face/draw: render face
; 	;@@ TODO: fix the lag once #4881 gets a solution
; 	do-atomic [									;-- uses reactivity to unroll the recursion and prevent stack overflow
; 		do-events/no-wait						;@@ this still does not prevent GUI huge lags :(
; 	]
; ]

now that there's proper grid-view, this list of lists hack is not needed anymore
; table-ctx: context [
; 	;@@ TODO: func to automatically balance column widths to minimize table height
; 	; balance: function [] 

; 	spaces/table-row: make-space/block 'list [
; 		spacing: 4x3
; 		margin: 0x0
; 		data: none
; 		table: none				;-- should be set by the table

; 		make-layout: has [r] [
; 			r: make row-layout [
; 				pinned: table/pinned/x
; 				widths: table/widths
; 				axis: 'x
; 			]
; 			r/axis:    axis
; 			r/margin:  margin
; 			r/spacing: spacing
; 			r
; 		]

; 		;@@ TODO: unify this with data-view block variant somehow
; 		fill: function [] [
; 			#assert [block? data]
; 			n: length? data
; 			repeat i n [
; 				value: :data/:i
; 				unless item: items/:i [
; 					append items item: anonymize 'item make-space 'data-view []
; 				]
; 				item: get item
; 				maybe item/width: table/widths/:i
; 				set/any 'item/data :value
; 				item/set-content
; 			]
; 			clear skip items n
; 		]

; 		list-draw: :draw
; 		draw: function [] [
; 			fill		;@@ TODO: caching
; 			list-draw
; 		]
; 	]

; 	;@@ TODO: spacers between pinned and not pinned data
; 	spaces/table: make-space/block 'list [
; 		pinned: 0x1							;-- pinned columns x rows (headers)
; 		margin: 0x0	
; 		data-columns: [1 2]					;-- indexes of visible DATA columns in the order of appearance
; 		;-- NOTE: don't use #() here because it's ignored by copy/deep
; 		widths: make map! [1 100 2 100]		;-- data column index -> it's visible width
; 		axis: 'y

; 		source: []										;-- block of blocks or a function returning one
; 		;-- user can override `data` for more complex `source` layouts support
; 		data: function [/pick x [integer!] y [integer!] /size] [
; 			s: source									;-- eval in case it's a function
; 			case [
; 				pick [if row: s/:y [row/:x]]			;-- s/:y can be `none`
; 				empty? s [0x0]
; 				'else [
; 					#assert [block? s/1]
; 					as-pair  length? s/1  length? s
; 				]
; 			]
; 		]

; 		prep-data-row: function [
; 			"preps data row for display, independent of `source` format"
; 			y [integer!]
; 		][
; 			dsize: data/size
; 			if any [y <= 0  y > dsize/y] [return none]	;-- out of data limits case
; 			ncol: length? data-columns
; 			if 0 = ncol [return []]						;-- empty row case (no allocation needed)

; 			;@@ TODO: make a free list of blocks for this
; 			r: make [] ncol
; 			repeat x ncol [append/only r data/pick data-columns/:x y]	;@@ should be map-each, but it's slow
; 			r
; 		]

; 		headers: make-space 'list-view [hscroll/size/y: 0]
; 		columns: make-space 'list-view []
; 		headers/data: func [/pick i /length] [
; 			either pick
; 				[prep-data-row i]
; 				[min pinned/y second data/size]
; 		]
; 		columns/data: func [/pick i /length] [
; 			either pick
; 				[prep-data-row i + pinned/y]
; 				[max 0 (second data/size) - pinned/y]
; 		]
; 		headers/wrap-data:
; 		columns/wrap-data: function [item-data [block!]] [
; 			anonymize 'row make-space 'table-row compose/only [table: (self) data: (item-data)]
; 		]

; 		items: [headers columns]

; 		list-draw: :draw
; 		draw: function [] [
; 			maybe headers/origin: as-pair columns/origin/x headers/origin/y	;-- sync origin/x
; 			; headers/invalidate
; 			; columns/invalidate
; 			render 'headers
; 			render 'columns
; 			;-- don't let headers occupy more than half of height
; 			maybe headers/size: min headers/list/size size / 1x2 - (margin * 2x1)
; 			maybe columns/size: size - (headers/size * 0x1) - (margin * 2x2) - (spacing * 0x1)
; 			list-draw
; 		]

; 		;@@ do this as a function called inside draw!
; 		; on-change*: function [word old [any-type!] new [any-type!]] [
; 		; 	if word = 'dimensions [						;-- automatically show just added columns
; 		; 		#assert [pair? :old]
; 		; 		#assert [pair? :new]
; 		; 		set-quiet 'columns union columns rng: range old/x new/x
; 		; 		foreach i rng [widths/:i: 100]			;@@ externalize the default width?
; 		; 	]
; 		; ]
; 	]
; ]

this was crazy complex
; list-view-ctx: context [
; 	spaces/list-view: make-space/block 'inf-scrollable [
; 		source: []		;@@ or a function [index]? or support both?
; 		data: function [/pick i [integer!] /length] [
; 			either pick [source/:i][length? source]
; 		]
; 		index: 1										;-- index of the first item within source
		
; 		wrap-data: function [item-data [any-type!]][
; 			spc: make-space 'data-view []
; 			set/any 'spc/data :item-data
; 			if list/axis = 'y [spc/width: window/max-size/x - (list/margin/x * 2)]		;@@ what data width to use for horizontal lists?
; 			anonymize 'item spc
; 		]

; 		list: make-space 'list [axis: 'y]				;-- list/axis can be changed to get a horizontal list ;@@ but then setup becomes wrong
; 		window/map: [list [offset 0x0 size 0x0]]

; 		window/max-size: 1000x1000		;@@ this is where sizing strategy would be cool to have

; 		extra?: function [dir [word!]] [			;-- measure dangling extra size along any direction
; 			if empty? map: window/map [return 0]
; 			#assert [2 = length? map]
; 			r: max 0x0
; 				switch dir [
; 					w n [negate map/2/offset]
; 					e s [map/2/offset + map/2/size - window/max-size]
; 				]
; 			r/x + r/y
; 		]

; 		window/available?: function [dir [word!] requested [integer!]] [
; 			#assert [0 < requested]
; 			if any [
; 				all [list/axis = 'y  find [e w] dir]
; 				all [list/axis = 'x  find [n s] dir]		;@@ not sure about this yet, /width doesn't guarantee it
; 			] [return 0]
; 			reserve: extra? dir
; 			requested: requested - reserve

; 			r: 0
; 			if requested > 0 [
; 				lt: extend-layout dir requested
; 				r: lt/content-size/(list/axis)
; 				unless empty? lt/items [r: r + lt/spacing/(list/axis)]
; 			]
; 			r: max 0 r + reserve
; 			; print ["avail?" dir "=" r "of" requested "(reserve:" reserve ")"]
; 			r
; 		]

; 		;@@ ensure this one is called only from inf-scrollable/draw
; 		extend-layout: function [dir [word!] amount [integer!] /keep where [block!]] [
; 			; print ["extend" dir amount]
; 			lt: list/make-layout
; 			unless empty? list/items [amount: amount - lt/spacing/(list/axis)]
; 			switch dir [
; 				n w [+-: :-  n-max: (base: index) - 1]
; 				s e [+-: :+  n-max: data/length - base: index - 1 + length? list/items]
; 			]
; 			#assert [(select [n y s y e x w x] dir) = list/axis]
; 			repeat i n-max [
; 				name: wrap-data data/pick base +- i		;-- guarantee at least 1 item (else spacing could be bigger than the requested amount)
; 				#assert [not find/same list/items name]
; 				render name
; 				lt/place select get name 'size
; 				if keep [append where name]
; 				if lt/content-size/(list/axis) >= amount [break]
; 			]
; 			lt
; 		]

; 		;-- this func is quite hard to get right, many aspects to consider
; 		;-- * window moves list within it's map before calling `fill`,
; 		;--   but we'll have to move list back and move all items within list accordingly
; 		;-- * move offset can be used right away to know what spaces will be hidden
; 		;-- * list may have extra dangling items partially clipped by window (before the move), which now become visible
; 		;--   i.e. list/size may be > window/max-size because it contains whole items, not necessarily aligning to window borders
; 		;-- * these hidden parts should be subtracted from the xy1-xy2 area to know how much to extend the list itself
; 		;-- * there may be no new items to add, just the hidden area to show
; 		;-- * list may initially be empty (spacing to consider), or not rendered (undefined size)
; 		;-- * when filling from above, list should be aligned with the top border, when from below - the opposite
; 		;@@ and I haven't considered the case where window/max-size <= list-view/size (it isn't working)
; 		window/fill: function [xy1 [pair!] xy2 [pair!]] [
; 			; ?? size print ["fill" xy1 xy2]
; 			;@@ TODO: remove these or add x=opposite support
; 			#assert [0 = xy1/x]
; 			#assert [window/max-size/x = xy2/x]
; 			#assert [any [xy1/y = 0  xy2/y = window/max-size/y]]

; 			unit: select [x 1x0 y 0x1] x: list/axis
; 			dir: select
; 				pick [ [x e y s] [x w y n] ] xy2/:x = window/max-size/:x	;-- s/e = tail fill (or head to tail), n/w = head fill (partial)
; 				x
; 			negative?: none <> find [n w] dir
; 			either negative? [											;-- get already rendered parts out of the requested area
; 				xy2/:x: xy2/:x - extra? dir
; 			][	xy1/:x: xy1/:x + extra? dir
; 			]
; 			lgeom: window/map/list

; 			;-- xy area now lies purely outside the list, so we can fill it
; 			lt: extend-layout/keep dir (xy2/:x - xy1/:x) clear new: []

; 			;-- sometimes it's possible that `new` is empty and `fill` should only move the list to show `extra?` (hidden) area
; 			unless empty? new [
; 				;@@ TODO: some automatic extension calculation? right now it won't work for arbitrary layout
; 				pixels-added: lt/content-size/:x + either empty? list/items [0][lt/spacing/:x]

; 				offset: lgeom/offset						;-- we can count invisibles right now from list/offset
; 				initial-fill?: offset = 0x0					;-- on first fill, do not align with the lowest/rightmost edge
				
; 				n-remove: 0									;-- count how many invisible spaces to remove
; 				foreach': switch dir [n w [:foreach-reverse] s e [:foreach]]	 ;@@ should be for-each/reverse
; 				;@@ list should have no timer in the map, else we'll have to check names for `item`
; 				foreach' [_: geom:] list/map [
; 					o: geom/offset + offset
; 					visible?: bbox-overlap?  0x0 window/max-size  o o + geom/size
; 					either visible? [break][n-remove: n-remove + 1]
; 				]

; 				either negative? [									;-- insert new items
; 					insert list/items reverse new
; 					self/index: self/index - length? new
; 				][
; 					append list/items new
; 					maybe self/index: self/index + n-remove			;-- n-remove can be 0
; 				]

; 				pixels-removed: 0									;-- along the list/axis
; 				if n-remove > 0 [
; 					removed: either negative? [						;-- remove invisibles from `items` & `map`
; 						take/last/part list/items n-remove
; 						take/last/part list/map n-remove * 2
; 					][
; 						remove/part list/items n-remove
; 						take/part list/map n-remove * 2
; 					]

; 					rem-1st: removed/2
; 					rem-last: last removed
; 					pixels-removed: rem-last/offset + rem-last/size - rem-1st/offset + lt/spacing		;@@ TODO: automatic calculation if possible?
; 					pixels-removed: pixels-removed/:x
; 				]

; 				;-- now that we know removed size we can calculate how much to shift the list in window/map
; 				offset: unit * either negative? [pixels-added][pixels-removed * -1]

; 				foreach [_ geom] list/map [					;-- relocate visible spaces now that we know the offset
; 					geom/offset: geom/offset - offset
; 				]

; 				either new-size: list/size [
; 					;-- update the size, without re-rendering anything
; 					new-size/:x: new-size/:x - pixels-removed + pixels-added
; 					maybe list/size: new-size
; 				][
; 					;-- render the list to get it's size - should only be needed first time it's shown
; 					render/only 'list xy1 xy2
; 				]
; 			]
; 			#assert [list/size]

; 			;-- update list geometry inside the window
; 			lgeom/size: list/size
; 			lgeom/offset: either any [negative? initial-fill?] [
; 				0x0												;-- align to top-left corner of the window
; 			][	min 0x0 window/max-size - list/size * unit		;-- to bottom-left, but only if list > window(!)
; 			]
; 		]

; 		setup: function [] [
; 			if size [									;-- if size is defined, adjust the window (paragraphs adjust to window then)
; 				pages: 10								;@@ make this configurable?
; 				unit: select [x 1x0 y 0x1] list/axis
; 				maybe window/max-size: size + (pages - 1 * size * unit)
; 			]
; 		]

; 		inf-scrollable-draw: :draw
; 		draw: function [] [
; 			setup
; 			inf-scrollable-draw
; 		]
; 	]
; ]

call to `available?` to window's limits is very expensive - renders whole window
; window/draw: function [/only xy1 [pair!] xy2 [pair!]] [
; 	#debug grid-view [#print "window/draw is called with xy1=(xy1) xy2=(xy2)"]
; 	#assert [word? content]
; 	map/1: content								;-- rename it properly
; 	cspace: get content
; 	geom: map/:content
; 	o: geom/offset
; 	;-- there's no size for infinite spaces so we use `available?` to get the drawing size
; 	s: max-size
; 	foreach x [x y] [s/:x: available? x 1 (0 - o/:x) s/:x]
; 	default xy1: 0x0
; 	default xy2: s
; 	geom/size: s - o
; 	self/size: s							;-- limit window size by content size
; 	cdraw: render/only content xy1 - o xy2 - o
; 	compose/only [translate (o) (cdraw)]
; ]

no longer relevant in the new styles design
; set 'closures reshape [		;-- closures come after the main drawing code
; 	; hscroll/thumb vscroll/thumb [
; 	; 	(when focused?/parent [compose/deep [
; 	; 		push [
; 	; 			;@@ MEH DOESNT WORK YET -- CHECK PATTERN PEN WHEN IT"S FIXED
; 	; 			; pen pattern 4x4 [line-width 0 fill-pen black box 0x0 2x2 box 2x2 4x4]
; 	; 			; fill-pen 0.100.200.200
; 	; 			; line-width 0
; 	; 			; box 0x0 (size)
; 	; 			; line-width 2
; 	; 			line-width 0
; 	; 			fill-pen !(svmc/text + 0.0.0.100)
; 	; 			box 4x3 (size - 4x3)
; 	; 			line-width 2
; 	; 		]
; 	; 	]])
; 	; ]	
; ]

too complicated, hard to support reordering (e.g. left-to-right placement)
; tube-layout-ctx: context [
; 	~: self

; 	place: function [layout [object!] item [word!]] [
; 		sz: select get item 'size
; 		#assert [sz]									;-- item must have a size
; 		data: tail layout/raw-map
; 		x: switch layout/align/1 [n s ['x] w e ['y]]
; 		y: select [x y x] x
; 		rw: data/-1/:x									;-- row width accumulated so far
; 		cs: layout/content-size
; 		sp: layout/spacing

; 		if rw > 0 [rw: rw + sp/:x]						;-- add size to row
; 		rw: rw + sz/:x
; 		if all [
; 			rw > sz/:x									;-- put at least 1 item per row, even if it's wider
; 			layout/margin/:x * 2 + rw > layout/width	;-- jump to next row if needed
; 		][
; 			cs/:y: cs/:y + sz/:y						;-- count height in content-size
; 			if 3 < index? data [cs/:y: cs/:y + sp/:y]
; 			data: insert insert/only data copy [] 0x0
; 			rw: sz/:x
; 		]
; 		if all [
; 			rw > sz/:x
; 			0 < added: sz/:y - data/-1/:y
; 		][cs/:y: cs/:y + added]
; 		data/-1/:x: max data/-1/:x rw					;-- update row size
; 		data/-1/:y: max data/-1/:y sz/:y
; 		layout/content-size: max data/-1 cs				;-- update content size (x from row-size, y from cs)

; 		guide: select [x 1x0 y 0x1] x
; 		ofs: rw - sz * guide
; 		compose/deep/into [(item) [offset (ofs) size (sz)]] tail data/-2
; 	]

; 	build-map: function [layout] [
; 		al: layout/align
; 		x: switch al/1 [n s ['x] w e ['y]]
; 		y: select [x y x] x
; 		; guide: select [x 1x0 y 0x1] y
; 		sign: switch al/1 [n w [1] e s [-1]]
; 		move-items: sign * (switch al/3 [n w [-1] c [0] e s [1]]) + 1 / 2	;@@ use -1/+1 instead of nw/es pairs?
; 		move-rows:  sign * (switch al/2 [n w [-1] c [0] e s [1]]) + 1 / 2
; 		pos: layout/margin
; 		r: make [] 20
; 		foreach [row row-size] layout/raw-map [
; 			gap: layout/width - (layout/margin/:x * 2) - row-size/:x	;-- can be negative, still correct
; 			pos/:x: to 1 gap * move-rows
; 			if layout/dir < 0 [reverse/skip row 2]
; 			foreach [name geom] row [
; 				if move-items <> 0 [
; 					gap: row-size/:y - geom/size/:y
; 					geom/offset/:y: geom/offset/:y + to 1 (move-items * gap)
; 				]
; 				geom/offset: geom/offset + pos
; 			]
; 			append r row
; 			pos/:y: pos/:y + layout/spacing/:y + row-size/:y
; 		]
; 		; set 'xx layout
; 		; ?? layout
; 		r
; 	]

; 	set 'tube-layout object [
; 		;-- interface
; 		width:   100
; 		; origin:  0x0			;@@ TODO - if needed
; 		margin:  0x0
; 		spacing: 0x0
; 		align:   [n w n]		;-- 3 alignments: tube itself (nesw), then list within row (neswc), then item within list (neswc)
; 		dir: 1

; 		content-size: 0x0
; 		size:  does [margin * 2 + content-size]
; 		place: func [item [word!]] [~/place self item]
; 		map:   does [~/build-map self]

; 		;-- used internally
; 		raw-map: [[] 0x0]		;-- accumulated map so far (make object! copies this deeply)
; 	]

; 	#assert [not same? tube-layout/raw-map/1 (first select make tube-layout [] 'raw-map)]
; ]

old attempt to hack the grid via list of lists, nothing to do with new row (stretch-list) layout
; row-layout-ctx: context [
; 	place: function [layout [object!] item [pair!]] [
; 		set [ofs: siz: org:] list-layout-ctx/place layout item
; 		guide: select [x 1x0 y 0x1] x: layout/axis
; 		index: (length? layout/items) / 3
; 		if w: layout/widths/:index  [siz/x: w]			;-- enforce size if provided
; 		if h: layout/heights/:index [siz/y: h]
; 		if index > pinned: layout/pinned [				;-- offset and clip unpinned items
; 			either pinned > 0 [
; 				plim: skip items pinned - 1 * 3
; 				lim: plim/1 + plim/2 + layout/spacing * guide
; 			][
; 				lim: 0x0
; 			]
; 			ofs: ofs + (layout/origin * guide)
; 			if ofs/:x < lim/:x [
; 				org: org - dx: (lim - ofs) * guide
; 				siz: max 0x0 siz - dx
; 				ofs/:x: lim/:x
; 			]
; 		]
; 		layout/content-size/:x: ofs/:x + siz/:x - layout/margin/:x
; 		;-- content-size height accounts for all items, even clipped (by design)
; 		reduce/into [ofs siz org] clear skip tail layout/items -3
; 	]
; 	set 'row-layout make list-layout [
; 		origin: 0
; 		pinned: 0
; 		widths: []				;-- can be a map: index -> integer width
; 		heights: []				;-- same

; 		place: function [item [pair!]] [row-layout-ctx/place self item]
; 	]
; ]

old render code, before /on introduction (apply kludge)
; all [
	; only
	; function? :draw
	; find spec-of :draw /only
	; do copy/deep [draw: draw/only xy1 xy2]	;@@ workaround for #4854 - remove me!!
; ]

tube layout code before autosizing
; cache: []				;-- various values used by `place`
; raw-map: [[] 0x0]		;-- accumulated rows and row-sizes so far (make object! copies this deeply)
; #assert [not same? tube/raw-map/1 (first select make tube [] 'raw-map)]
; ;; fills a set of flags that are used by `place` func every time
; ;; flags do not change so no need to recompute them
; fill-cache: function [layout [object!]] [
	; data: tail layout/raw-map
	; y: anchor2axis layout/axes/1
	; x: anchor2axis layout/axes/2
	; xvec: axis2pair x
	; yneg?: find [n w] layout/axes/1
	; xneg?: find [n w] layout/axes/2
	; #assert [y <> x]								;-- have to be normal to each other
	; cs: layout/content-size
	; sp: layout/spacing
	; maxw: layout/width - (layout/margin/:x * 2)

	; cache-names: [data x y cs sp maxw xvec xneg? yneg?]
	; reduce/into cache-names layout/cache
; ]
; place: function [
	; "Add ITEM space to LAYOUT"
	; layout [object!] item [word!]
; ][
	; sz: select get item 'size
	; #assert [sz]									;-- item must have a size
	; if tail? layout/cache [fill-cache layout]
	; set [data: x: y: cs: sp: maxw: xvec: xneg?: yneg?:] layout/cache
	; rsz: data/-1									;-- row size accumulated so far
	; first?: 0 = rw: rsz/:x							;-- row width accumulated so far
	
	; rw: rw + sz/:x
	; unless first? [
		; rw: rw + sp/:x
		; if rw > maxw [								;-- jump to next row if needed
			; cs/:y: cs/:y + sp/:y
			; data: insert insert/only data make block! 16 rsz: 0x0
			; rw: sz/:x
			; first?: yes
		; ]
	; ]
	; if 0 < added: sz/:y - rsz/:y [cs/:y: cs/:y + added]
	; rsz: max rsz sz									;-- update row size
	; rsz/:x: rw
	; layout/content-size: max data/-1: rsz cs		;-- update content size (x from row-size, y from cs)

	; ofs: rsz - sz * xvec
	; if yneg? [ofs/:y: 0 - ofs/:y - sz/:y]
	; if xneg? [ofs/:x: 0 - ofs/:x - sz/:x]
	; reduce/into [data x y cs sp maxw xvec xneg? yneg?] clear layout/cache
	; compose/deep/into [(item) [offset (ofs) size (sz)]] tail data/-2
; ]
; build-map: function [
	; "Produce a final MAP from LAYOUT accumulated so far"
	; layout [object!]
; ][
	; al: layout/align
	; set [data: x: y: cs: sp: maxw: xvec: xneg?: yneg?:] layout/cache
	; ox: anchor2pair layout/axes/2
	; oy: anchor2pair layout/axes/1
	; shift: 0x0
	; if ox/:x < 0 [shift/:x: maxw]
	; if oy/:y < 0 [shift/:y: cs/:y]
	; pos: shift + mg: layout/margin
	; move-items: al/2 + 1 / 2
	; move-rows:  al/1 + 1 / 2
	; r: make [] length? layout/raw-map
	; foreach [row row-size] layout/raw-map [
		; gap: maxw - row-size/:x						;-- can be negative, still correct
		; row-shift: gap * move-rows * ox
		; if move-items <> 0 [
			; foreach [name geom] row [
				; gap: row-size - geom/size * oy
				; geom/offset: geom/offset + (move-items * gap)
			; ]
		; ]
		; foreach [name geom] row [
			; geom/offset: geom/offset + pos + row-shift
		; ]
		; append r row
		; pos: pos + (sp + row-size * oy)
	; ]
	; r
; ]

layouts old design
; layouts: context [

	; list: none											;-- reserve names
	; row:  none
	; tube: none

	; ;@@ TODO: free list of these
	; list-layout-ctx: context [
		; ~: self

		; place: function [layout [object!] item [word!]] [	;-- held separately to minimize the size of list-layout itself
			; sz: select get item 'size
			; #assert [sz]									;-- item must have a size
			; guide: select [x 1x0 y 0x1] layout/axis
			; cs: layout/content-size
			; if 0x0 <> cs [cs: cs + (layout/spacing * guide)]
			; ofs: cs * guide + layout/margin + layout/origin
			; cs: cs + (sz * guide)
			; cs: max cs sz
			; layout/content-size: cs
			; compose/deep/into [(item) [offset (ofs) size (sz)]] tail layout/map
		; ]

		; set 'list object [
			; origin:  0x0			;-- used by list-view
			; margin:  0x0
			; spacing: 0x0
			; axis:    'x

			; content-size: 0x0
			; size: does [margin * 2 + content-size]
			; map: []			;-- accumulated map so far
			; place: func [item [word!]] [~/place self item]
		; ]
	; ]
	
	; tube-layout-ctx: context [
		; ~: self
		
		; place: function [layout [object!] item [word!]] [
			; append layout/items item
		; ]
		
		; build-map: function [layout [object!]] [
			; ;; to support automatic sizing, each item's constraints has to be analyzed
			; ;; obviously there can be two strategies:
			; ;;  1. fill everything with max size, then shrink, and rearrange as possible
			; ;;  2. fill everything with min size, then expand within a single row
			; ;;  2nd option seems more predictable and easier to implement
			; ;; constraint presence does not mean that space can reach that size,
			; ;; so it should only be used as hint (canvas size) to obtain min size
			; ;; then, every item that has a nonzero weight has to be rendered twice:
			; ;; once to get it's minimum appearance, second time to expand it
			; ;; other items also has to be rendered twice - to fill the row height
			
			; ;; obtain constraints info
			; ;@@ info can't be static since render may call another build-map; use block-stack!
			; info: make block! length? layout/items
			; i: 0 foreach item layout/items [			;@@ use for-each when becomes native
				; i: i + 1
				; space: get item
				; min-size: all [space/limits space/limits/min]	;@@ REP #113
				; max-size: all [space/limits space/limits/max]	;@@ REP #113
				; ;@@ this is inconsistent with list which does NOT render it's items:
				; drawn: render/on item min-size			;-- needed to obtain space/size
				; #assert [pair? space/size]
				; weight: any [select space 'weight 0.0]
				; #assert [number? weight]
				; available: case [
					; weight <= 0  [0]					;-- fixed size
					; not max-size [2e9]					;-- unlimited extension possible
					; 'else [max-size/x - space/size/x / weight]	;@@ REP #113
				; ]
				; append/only info reduce [				;@@ use block stack
					; i item space drawn space/size max-size 1.0 * available weight
				; ]
			; ]
			
			; ;; split info into rows
			; rows: copy []								;@@ use block-stack
			; row:  copy []
			; row-size: layout/spacing/x * -1x0			;@@ not gonna work for empty rows
			; row-max-width: layout/width - (2 * layout/margin/x)
			; canvas: layout/width - (2 * layout/margin/x) by 2e9		;@@ use canvas ?
			; foreach item info [
				; set [_: name: _: _: item-size:] item
				; new-row-size: as-pair
					; row-size/x + item-size/x + layout/spacing/x
					; max row-size/y item-size/y
				; row-size: either all [					;-- row is full, but has at least 1 item?
					; new-row-size/x > row-max-width
					; not tail? row
				; ][
					; reduce/into [row-size copy row] tail rows
					; clear row
					; item-size
				; ][
					; new-row-size
				; ]
				; append/only row item
			; ]
			; reduce/into [row-size row] tail rows
			
			; ;; expand row items - facilitates a second render cycle of the row
			; foreach [row-size row] rows [
				; free: row-max-width - row-size/x
				; if free > 0 [							;-- any space left to distribute?
					; ;; free space distribution mechanism relies on continuous resizing!
					; ;; render itself doesn't have to occupy max-size or the size we allocate to it
					; ;; and since we don't know what render is up to,
					; ;; we can only "fix" it by re-rendering until we fill whole row space
					; ;; but this will be highly inefficient, and not even guaranteed to ever finish
					; ;; so a proper solution in this case should be to use a custom layout or resize hook
					; ;@@ this needs to be documented, and maybe another sizing type should be possible: a list of valid sizes
					; weights: clear []
					; extras:  clear []
					; foreach item row [
						; append weights item/8
						; append extras  item/7
					; ]
					; exts: distribute free weights extras
					
					; i: 0 foreach item row [				;@@ should be for-each
						; i: i + 1
						; set [_: name: space: drawn: item-size: max-size: available: weight:] item
						; new-size: item-size/x + exts/:i by row-size/y
						; item/4: render/on name new-size
						; item/5: space/size				;@@ or use new-size in a map?
					; ]
				; ]
			; ]
			
			; map: clear []
			; margin:  layout/margin
			; spacing: layout/spacing
			; row-y: margin/y
			; total-length: 0
			; foreach [row-size row] rows [
				; ofs: margin/x by row-y
				; foreach item row [
					; set [_: name: space: drawn: item-size: max-size: available: weight:] item
					; ofs/y: to integer! row-size/y - item-size/y / 2 + row-y
					; geom: reduce ['offset ofs 'size item-size]
					; repend map [name geom]
					; ofs/x: ofs/x + spacing/x + item-size/x
				; ]
				; total-length: total-length + row-size/y + spacing/y
				; row-y: margin/y + total-length
			; ]
			; total-length: total-length - spacing/y
			; layout/content-size: row-max-width by total-length
			; layout/size: 2x2 * margin + layout/content-size
			; copy map
		; ]

		; size: function [layout [object!]] [
			; ;-- does not contract size if it's > width
			; ;-- does not expand it either if some item is > width, otherwise can get this picture:
			; ;-- [  ] = width
			; ;-- XXXXXXXXXX
			; ;-- X X        <- if expanded, these rows will look like they're half filled
			; ;-- X X           instead, let the big item stick out
			; sz: layout/margin * 2 + layout/content-size
			; switch layout/axes/1 [
				; n s [layout/width by sz/y]
				; w e [sz/x by layout/width]
			; ]
		; ]

		; set 'tube object [
			; ;-- interface
			; width:   100			;@@ TODO: use canvas instead?
			; origin:  0x0			;@@ TODO - if needed
			; margin:  0x0
			; spacing: 0x0
			; ;@@ align can be a pair, total 9 options; though pair is interpreted in XY coordinate terms usually..
			; align:   [-1 -1]		;-- 2 alignments: list within row (-1/0/1), then item within list (-1/0/1)
			; axes:    [s e]			;-- 4x2 total; default placement order: top-down rows, left-right items

			; content-size: 0x0
			; place: func [item [word!]] [~/place self item]
			; map:   does [~/build-map self]
			; size:  0x0

			; ;-- used internally
			; items: []
		; ]
	; ]
; ]

singular get-cache & set-cache - no use, even list-view renders each space on 2 canvases
; get-cache: function [space [object!] canvas [pair! none!] xy1 [pair! none!] xy2 [pair! none!]] [
	; all [
		; true =? select space 'cache?
		; space/size
		; cached: find/only/same space-cache space
		; cached/2 =? canvas
		; cached/3 =? xy1
		; cached/4 =? xy2
		; cached/5
	; ]
; ]
; set-cache: function [space [object!] canvas [pair! none!] xy1 [pair! none!] xy2 [pair! none!] drawn [block!]] [
	; reduce/into [space canvas xy1 xy2 drawn] data: clear []
	; cached: any [
		; find/only/same space-cache space
		; tail space-cache
	; ]
	; change cached data
; ]

list layout settings as object support - probably wont be needed as object is heavy
; either object? settings [
	; bound: append clear [] words
	; set words bind bound settings
; foreach word [			
	; axis: margin: spacing: canvas: origin:
	; viewport: cache-visible?: cache-invisible?:
; ][
	; set word select settings word
; ]

part of cell/draw - this makes cleaner draw blocks but does not make it any faster and adds complexity 
; clip?: not 0x0 +<= free
; move?: offset <> 0x0
; if any [clip? move?] [
	; buf: clear []
	; if clip? [repend buf ['clip 0x0 space/size]]
	; if move? [repend buf ['translate offset]]
	; drawn: copy append/only buf drawn
; ]

this cache idea didn't work well since it has to deeply visit all tree nodes which is 10x slower than rendering
; ;; cache format for now: [space-object space-path canvas xy1 xy2 drawn-size drawn-code ...]
; ;;   from find/tail:           -1           1        2    3   4      5           6         
; ;@@ once #5116 gets fixed, check if find/same .. #static-reduce [..] is going to be faster
; space-cache: make hash! 4096

; find-cache: function [space [object!] path [path!] canvas [pair! none!] xy1 [pair! none!] xy2 [pair! none!]] [
	; cached: space-cache
	; while [cached: find/only/same/tail cached space] [		;@@ watch out for #5116 fix, or use for-each
		; all [												;@@ also maybe search in reverse?
			; cached/2 =? canvas
			; cached/3 =? xy1
			; cached/4 =? xy2
			; same-paths? cached/1 path
			; return back cached
		; ]
	; ]
	; none
; ]

; ;; assumes that given the same canvas & xy1/2, inner spaces will not be resized/relocated
; children-cached?: function [space [object!] path [path!]] [
	; if map: select space 'map [						;-- composite space?
		; foreach [name geom] map [
			; inner: get name
			; cached: space-cache
			; while [cached: find/only/same/tail cached inner] [		;@@ watch out for #5116 fix, or use for-each
				; unless child-cached?: all [							;@@ also maybe search in reverse?
					; ;@@ this is not gonna work for scrollables which are using xy1 xy2 too?
					; geom/size =? cached/5
					; geom/size =? inner/size 
					; same-paths? cached/1 path
					; (
						; append path name
						; also children-cached? inner path
						; remove top path
					; )
				; ] [return no]
			; ]
		; ]
	; ]
	; yes
; ]

; get-cache: function [space [object!] path [path!] canvas [pair! none!] xy1 [pair! none!] xy2 [pair! none!]] [
	; all [
		; true =? select space 'cache?
		; space/size
		; cached: find-cache space path canvas xy1 xy2
		; children-cached? space path
		; cached/7
	; ]
; ]

; ;@@ TODO: limit number of caches per single space somehow, e.g. for list which has limitless xy1/xy2 combos!
; set-cache: function [
	; space [object!] path [path!] canvas [pair! none!] xy1 [pair! none!] xy2 [pair! none!] drawn [block!]
; ][
	; either cached: find-cache space path canvas xy1 xy2 [
		; cached/6: space/size
		; cached/7: drawn
	; ][
		; repend space-cache [space copy path canvas xy1 xy2 space/size drawn]
	; ]
; ]

; clear-cache: function [space [object!]] [
	; while [pos: find/same/only space-cache space] [
		; unless pos =? other: skip tail space-cache -7 [change pos other]
		; clear other
	; ]
; ]

version of constrain that does not accept `none` canvas size
; constrain: function [
	; "Sets TARGET to SIZE clipped within LIMITS"
	; 'target [set-word! set-path!]
	; size    [pair!]
	; limits  [none! word! object!]
	; /force "Set it even if it's equal, to trigger reactions"
; ][
	; case [
		; limits = 'fixed [size: get target]				;-- cannot be changed ;@@ need to think more about this
		; range? limits  [
			; case [
				; none = min: limits/min [min: 0x0]
				; number? min [min: min by 0]				;@@ should numbers only apply to X, or to main axis (harder)? 
			; ]
			; case [
				; none = max: limits/max [max: 2000000000x2000000000]
				; number? max [max: max by 2e9]
			; ]
			; size: clip [min max] size
		; ]
		; ;-- rest is treated as `none`
	; ]
	; set target size
	; if any [force  not size == get target] [set target size]
	; size
; ]

working tube until alignments/axes were added
; tube: context [
	; ;; settings for tube layout:
	; ;;   axes          [block! none!]   2 words, any of [n e] [n w] [s e] [s w] [e n] [e s] [w n] [w s]
	; ;;                                  in essence, any of n/e/s/w but both should be orthogonal, total 4x2
	; ;;                                  default = [s e] - top-down rows, left-to-right items
	; ;;   align         [block! none!]   2 integers, any of [-1 0 1]: list within row, then item within list
	; ;;                                  default = [-1 -1] ??????
	; ;@@ TODO: reverse or rework alignment order, it's awkward and impossible to understand
	; ;;   margin           [pair!]   >= 0x0
	; ;;   spacing          [pair!]   >= 0x0
	; ;;   canvas         [none! pair!]   > 0x0, cannot be none as tube needs to know it's width
	; create: function [
		; "Builds a tube layout out of given spaces and settings as bound words"
		; spaces [block! function!] "List of spaces or a picker func [/size /pick i]"
		; settings [block!] "Any subset of [axes align margin spacing canvas cache]"
		; ;; settings - imported locally to speed up and simplify access to them:
		; /local axes align margin spacing canvas
	; ][
		; func?: function? :spaces
		; count: either func? [spaces/size][length? spaces]
		; if count <= 0 [return copy/deep [0x0 []]]
		; foreach word settings [						;-- free settings block so it can be reused by the caller
			; set bind word 'local get word			;@@ check that only allowed words are overwritten, not e.g. `count`
		; ]
		; #debug [typecheck [
			; axes     [none! block! (find/only [[n e] [n w] [s e] [s w] [e n] [e s] [w n] [w s]] axes)]
			; align    [none! block! (all [find [-1 0 1] align/1 find [-1 0 1] align/2])]
			; margin   [      pair! (0x0 +<= margin)]
			; spacing  [      pair! (0x0 +<= spacing)]
			; canvas   [none! pair! (0x0 +< canvas)]
		; ]]
		; default axes:  [s e]
		; default align: [-1 -1]	;@@
		; y: ortho x: anchor2axis axes/1
		
		; ;; to support automatic sizing, each item's constraints (`limits`) has to be analyzed
		; ;; obviously there can be two strategies:
		; ;;  1. fill everything with max size, then shrink, and rearrange as possible
		; ;;  2. fill everything with min size, then expand within a single row
		; ;;  2nd option seems more predictable and easier to implement
		; ;; constraint presence does not mean that space can reach that size as content affects it too,
		; ;; so it should only be used as hint (canvas size passed to render) to obtain real min size
		; ;; then, every item that has a nonzero weight has to be rendered twice (so cache is not supported):
		; ;; once to get it's minimum appearance, second time to expand it along the row
		; ;; other items also has to be rendered twice - to fill the row height, even though width is constant
		
		; ;; constraints question is also a tricky one
		; ;; I decided to estimate min. size of each space by using 0x2e9 and 2e9x0 canvases (best fit for text/tube)
		; ;; then each space will report the "narrowest" possible form of it, suiting tube needs
		; ;; when limits/min is set, it overrides the half-unlimited canvas
		; ;; when only limits/max is set, it's "height" overrides the infinite 2e9, "width" stays zero
		; ;@@ for this to work, buttons/radios/etc must never wrap or ellipsize their text,
		; ;@@ and single-line generic text style is desirable with the option to: always show full text, ellipsize it, or clip
		; ;@@ also 4th cached canvas may be needed!
		
		; ;; obtain constraints info
		; ;; `info` can't be static since render may call another build-map; same for other arrays here
		; ;; info format: [space-name space-object draw-block drawn-width ]
		; info: obtain block! count * 5
		; #leaving [stash info]
		
		; stripe: 0 by infxinf/x						;-- thinnest canvas possible, used to estimate min. space/size
		; repeat i count [
			; space: get name: either func? [spaces/pick i][spaces/:i]
			; drawn: render/on name stripe			;-- 1st render needed to obtain min *real* space/size, which may be > limits/max
			; weight: any [select space 'weight 0]
			; #assert [number? weight]
			; available: 1.0 * case [					;-- max possible width extension length, normalized to weight
				; weight <= 0 [0]						;-- fixed size
				; not max-size: all [space/limits space/limits/max] [infxinf/x]	;-- unlimited extension possible ;@@ REP #113
				; pair? max-size [max-size/x - space/size/x / weight]
				; number? max-size [max-size - space/size/x / weight]		;@@ only use on vertical tubes
			; ]
			; ;; if width is infinite, this 1st `drawn` block and `space/size` will be used as there's no meaningful width to fill
			; ;; otherwise they're just drafts and will be replaced by proper size & block
			; repend info [name space drawn available weight]
		; ]
		
		; ;; split info into rows according to found min widths
		; rows: obtain block! 40
		; row:  obtain block! count * 5
		; row-size: -1x0 * spacing					;@@ not gonna work for empty rows
		; allowed-row-width: either all [canvas canvas/x < infxinf/x] [canvas/x - (2 * margin/x)][infxinf/x]
		; peak-row-width: 0							;-- will be used to determine full layout size
		; canvas: layout/width - (2 * margin/x) by 2e9		;@@ use canvas ?
		; foreach [name space drawn available weight] info [
			; new-row-size: as-pair					;-- add item-size and check if it hangs over
				; row-size/x + space/size/x + spacing/x
				; max row-size/y space/size/y			;-- height will only be needed in infinite width case (no 2nd render)
			; peak-row-width: max peak-row-width new-row-size/x
			; row-size: either any [					;-- row either fits allowed-row-width, or has no items yet?
				; new-row-size/x <= allowed-row-width
				; tail? row
			; ][										;-- accept new width
				; new-row-size
			; ][										;-- else move this item to next row
				; append (new-row: obtain block! length? row) row
				; repend rows [row-size new-row]
				; clear row
				; space/size
			; ]
			; repend row [name space drawn available weight]
		; ]
		; repend rows [row-size row]
		; #leaving [foreach [_ row] rows [stash row]  stash rows]
		
		; ;; expand row items - facilitates a second render cycle of the row
		; if allowed-row-width < infxinf/x [			;-- only if width is constrained
			; forall rows [							;@@ use for-each
				; set [row-size: row:] rows
				; free: allowed-row-width - row-size/x
				; if free > 0 [						;-- any space left to distribute?
					; ;; free space distribution mechanism relies on continuous resizing!
					; ;; render itself doesn't have to occupy max-size or the size we allocate to it
					; ;; and since we don't know what render is up to,
					; ;; we can only "fix" it by re-rendering until we fill whole row space
					; ;; but this will be highly inefficient, and not even guaranteed to ever finish
					; ;; so a proper solution in this case should be to use a custom layout or resize hook
					; ;@@ this needs to be documented, and maybe another sizing type should be possible: a list of valid sizes
					; weights: clear []				;-- can be static, not used after distribute
					; extras:  clear []
					; foreach [_ _ _ available weight] row [	;@@ use 2 map-eachs
						; append weights weight
						; append extras  available
					; ]
					; extensions: distribute free weights extras
					
					; row-size: -1x0 * spacing		;@@ not gonna work for empty rows
					; peak-row-width: 0
					; repeat i length? extensions [	;@@ use for-each
						; set [name: space:] item: skip row i - 1 * 5
						; desired-size: space/size/x + extensions/:i by row-size/y
						; item/3: render/on name desired-size
						; item/4: space/size			;-- use real `space/size` for positioning, not `desired-size`
						; row-size: as-pair			;-- update row size with the new render results
							; row-size/x + space/size/x + spacing/x
							; max row-size/y space/size/y
					; ]
					; rows/1: row-size
					; peak-row-width: max peak-row-width row-size/x
				; ]
				; rows: next rows
			; ]
		; ]
		
		; ;; build the map & measure the final layout size using results of 1st or 2nd render
		; map:   clear []
		; row-y: margin/y
		; total-length: 0
		; foreach [row-size row] rows [
			; ofs: margin/x by row-y
			; foreach [name space drawn _ _] row [
				; ofs/y: to integer! row-size/y - space/size/y / 2 + row-y
				; geom: reduce ['offset ofs 'size space/size 'drawn drawn]	;@@ use alignment
				; repend map [name geom]
				; ofs/x: ofs/x + spacing/x + space/size/x
			; ]
			; total-length: total-length + row-size/y + spacing/y
			; row-y: margin/y + total-length
		; ]
		; total-length: total-length - spacing/y
		
		; size: 2x2 * margin + (peak-row-width by total-length)
		; #assert [size +< infxinf]
		; reduce [size copy map]
	; ]

; ]

this invalidation doesn't work if space contains itself (or another space with this space inside) - overflows
; set 'invalidate-cache function [
	; "If SPACE's draw caching is enabled, enforce next redraw of it and all it's ancestors"
	; space [object! tag!] "Use <everything> to affect all spaces"
; ][
	; either tag? space [
		; #assert [space = <everything>]
		; clear render-cache
	; ][
		; if pos: find/same parents-list space [		;-- no matter if cache?=yes or no, parents still have to be invalidated
			; foreach [node parent] pos/2 [
				; while [node: find/same/tail node space] [
					; change/dup at node 3 'free slots		;-- remove cached draw blocks but not the children node!
				; ]
				; #assert [not space =? parent]
				; if parent [invalidate-cache parent]			;-- can be none if upper-level space
			; ]
		; ]
	; ]
; ]

grid-cell is no longer needed as general cell is available
; spaces/grid-cell: make-template 'space [
	; map: [space [offset 0x0 size 0x0]]
	; map/1: make-space/name 'space []
	; draw: function [] [
		; spc: get name: map/1
		; cdrawn: render name
		; map/2/size: spc/size
		; unless size [self/size: spc/size]
		; compose/only [
			; box 0x0 (size)	;-- already done in styles
			; (cdrawn)
		; ]
	; ]
; ]

parts of the prehistoric data-view template, now handled by box and on-change
; invalidate: does [set-quiet 'valid? no]
; set-content: function [] [
	; case [
		; block? :data [								;-- only recreates item spaces as necessary
			; unless content = 'list [set-quiet 'content make-space/name 'list []]
			; list: get content
			; maybe list/margin: 0x0					;-- fit the list contents tightly, as we already have a margin
			; maybe list/spacing: spc: spacing * 1x1	;-- ensure a pair value
			; mrg: margin * 1x1
			; n: length? data
			; ;-- evenly distribute the items	only when width is fixed:  ;@@ any better idea??
			; ;@@ also how to or should we apply width to images?
			; item-width: all [width  to 1 width - (n - 1 * spc/x) - (2 * mrg/x) / n]
			; repeat i n [
				; value: :data/:i
				; unless item: list/item-list/:i [
					; append list/item-list item: anonymize 'item make-space 'data-view []
				; ]
				; item: get item
				; maybe item/width: item-width
				; set/any 'item/data :value
				; item/set-content
			; ]
			; clear skip list/item-list n
		; ]
		; image? :data [
			; unless content = 'image [set-quiet 'content make-space/name 'image []]
			; img: get content
			; img/data: data			;@@ copy or not? images consume RAM easily; need them at least GC-able to copy
			; img/data: copy data
		; ]
		; 'else [
			; text: either string? :data [copy data][mold :data]		;@@ limit it or not?
			; unless content = 'paragraph [set-quiet 'content make-space/name 'paragraph []]
			; para: get content
			; maybe para/margin: margin
			; maybe para/text: text
			; unless para/font =? font [para/font: font]
		; ]
	; ]
	; set-quiet 'valid? yes
; ]
; draw: function [/on canvas [pair! none!]] [
	; unless valid? [set-content]
	; obj: get content
	; cdraw: render/on content canvas					;-- apply style to get the size
	; sz: (mrg: margin * 1x1) * 2 + obj/size
	; fsz: any [canvas sz]							;-- adapts it's size to canvas, if provided
	; foreach x [x y] [								;-- but if it's unlimited, uses rendered size
		; if fsz/:x >= 2e9 [fsz/:x: sz/:x]
	; ]
	; self/size: fsz
	; change/only change map content compose [offset: (mrg) size: (sz - mrg)]
	; compose/deep/only [
		; clip 0x0 (sz) [				;@@ clipping should be done automatically somewhere for all spaces
			; translate (mrg) (cdraw)
		; ]
	; ]
; ]

attempt to make click+drag UX for radial menus - not so good		
; radial-visible?: no
; register-finalizer [up down] function [				;-- finalizer so other spaces can eat the event
	; space [object! none!] path [block!] event [event! none!]
	; /extern radial-visible?
; ][
	; either event/type = 'down [
		; if all [
			; menu: find-field path 'menu block!
			; has-flag? :menu/1 'radial
		; ][
			; offset: face-to-window event/offset event/face
			; reset-hint event
			; show-menu event/window 1 offset menu
			; start-drag/with path event/offset
			; radial-visible?: yes
		; ]
	; ][
		; if radial-visible? [
			; radial-visible?: no
			; picked: all [pos: find find path 'radial-menu 'round-clickable]
			; ?? path
			; ?? picked
		; ]
	; ]
; ]

attempt in on-time to work around #5130, but it's slower, text is not smooth
and image cannot filled with transparent color using draw (need change/dup which is an extra draw)
; face/image: any [face/image make image! face/size]
; draw face/image compose [pen off fill-pen white box 0x0 (face/size)]
; draw face/image render face
; maybe face/draw: none
 
old 'expected' custom parse rule - it lead to very cryptic code I couldn't read myself 
; ;; parse helper: reshape [ !(expected block!) or !(expected [integer! | float!]) ]
; expected: function ['rule] [
    ; reshape [!(rule) | p: (ERROR "Expected (mold quote !(rule)) at: (mold/part p 100)")]
; ]

rendering as it was in the tree model that proved not so useful
; context [
	; ;; render cache format: [space-object [children] last-write-index 4x [canvas space-size map drawn] ...] (a tree of hashes)
	; ;;   it holds rendered draw block of all spaces that have /cache? = true
	; ;;   such cache only has slots for 4 canvas sizes, which should be enough for most cases hopefully
	; ;;   otherwise we'll have to iterate over all cached canvas sizes which is not great for performance
	; ;;   last write index helps efficiently fill the cache (other option - use random 4, which is less efficient)
	; ;;   space-size is required because `draw` usually changes space/size and if draw is avoided, /size still must be set
	; ;;   unused slots contain 'free word to distinguish committed canvas=none case from unused cache slot
	; ;; parent cache format: [space-object [containing-node parent-object ...] ...] (flat 2-leveled)
	; ;;   parent cache is used by `invalidate` to go up the tree and invalidate all parents so the target space gets re-rendered
	; ;;   it holds rendering tree of parent/child relationships on the last rendered frame
	
	; ;; caching workflow:
	; ;; - drawn spaces draw blocks are committed to the cache if they have /cache? enabled
	; ;; - render checks cache first, and only performs draw if cache is not found
	; ;;   each block corresponds to a particular canvas size (usually 3: unlimited, half-unlimited and limited, but tube uses 3 except none)
	; ;; - spaces should detect changes in their data that require new rendering effort and call `invalidate`
	; ;;   invalidate uses last rendered parents tree to locate upper nodes and invalidate them all
	; ;;   (there can be multiple parents to the same space)
	; ;@@ TODO: document this in a proper place
	
	; hash!: :block!
	; period:         4									;-- size occupied by a single cached entry
	; slots:          16									;-- size occupied by cache of single space - a multiple of period!
	; ;@@ TODO: both render-cache and parents-list require cleanup on highly dynamic layouts, or they slow down
	; ;@@ will need a flat registry of still valid spaces
	; render-cache:   make hash! slots + 3 * 3
	; parents-list:   make hash! 2048
	
	; visited-nodes:  make block! 32						;-- stack of nodes currently visited by render
	; visited-spaces: make block! 32						;-- stack of spaces currently visited by render
	; append/only visited-nodes render-cache				;-- currently rendered node (hash) where to look up spaces
	
	; ;@@ a bit of an issue here is that <everything> doesn't call /invalidate() funcs of all spaces
	; ;@@ but maybe they won't be needed as I'm improving the design?
	; set 'invalidate function [
		; "Invalidate SPACE content and cache, or use <everything> to affect all spaces' cache"
		; space [word! object! tag!] "If contains `invalidate` func, it is evaluated"
	; ][
		; if word? space [
			; space: get space
			; #assert [object? space]
		; ]
		; invalidate-cache space
		; all [
			; object? space
			; any-function? custom: select space 'invalidate
			; custom
		; ]
	; ]
	
	; invalidation-stack: make hash! []
	
	; set 'invalidate-cache function [
		; "If SPACE's draw caching is enabled, enforce next redraw of it and all it's ancestors"
		; space [object! tag!] "Use <everything> to affect all spaces"
		; /only "Do not invalidate parents (e.g. if they are invalid already)"
	; ][
		; #debug profile [prof/manual/start 'invalidation]
		; either tag? space [
			; #assert [space = <everything>]
			; dump-parents-list parents-list render-cache
			; ;@@ what method to prefer? parse or radical?
			; clear render-cache
			; clear parents-list
			; parse render-cache rule: [any [skip into rule skip slots change skip 'free]]
		; ][
			; unless find/same invalidation-stack space [			;-- stack overflow protection for cyclic trees 
				; #debug cache [#print "Invalidating space=[(mold/part/only/flat body-of space 80)]"]
				; if pos: find/same parents-list space [			;-- no matter if cache?=yes or no, parents still have to be invalidated
					; append invalidation-stack space
					; foreach [node parent] pos/2 [
						; while [node: find/same/tail node space] [
							; change/dup at node 3 'free slots	;-- remove cached draw blocks but not the children node!
						; ]
						; #assert [not space =? parent]
						; all [
							; not only
							; parent								;-- can be none if upper-level space
							; invalidate-cache parent
						; ]
					; ]
					; remove top invalidation-stack
				; ]
			; ]
		; ]
		; #debug profile [prof/manual/end 'invalidation]
	; ]
	
	; find-cache: function [
		; "Find location of SPACE in the currently rendered cache node"
		; space [object!]
	; ][
		; find/same last visited-nodes space
	; ]
	
	; get-cache: function [
		; "If SPACE's draw caching is enabled and valid, return it's cached draw block"
		; space [object! word!] canvas [pair! none!]		;-- word helps debugging
	; ][
		; if word? space [space: get name: space]			;@@ remove me once cache is stable to speed it up
		; r: all [
			; cache: find-cache space								;-- must have a cache
			; find/skip/part skip cache 3
				; any [canvas 'none] period slots					;@@ workaround for #5126
			; find/skip/part skip cache 3 canvas 3 slots			;-- search for the same canvas among 3 options
			; print mold~ copy/part cache >> 2 slots
		; ]
		; if cache [print rejoin ["cache=" map-each/eval [a b _] copy/part skip cache 3 slots [[a b]]]]
		; #debug cache [
			; name: any [name 'space]
			; either r [
				; #print "Found cache for (name) size=(space/size) on canvas=(canvas): (mold/flat/only/part to [] r 40)"
			; ][
				; reason: case [
					; cache [rejoin ["cache=" mold to [] extract copy/part skip cache 3 slots period]]
					; not space/size ["never drawn"]
					; not select space 'cache? ["cache disabled"]
					; 'else ["not cached or invalidated"]
					; 'else [probe~ last visited-nodes "not cached or invalidated"]
				; ]
				; #print "Not found cache for (name) size=(space/size) on canvas=(canvas), reason: (reason)"
			; ]
		; ]
		; r
	; ]
	
	; commit-cache: function [
		; "Save SPACE's Draw block on this CANVAS in the cache"
		; space  [object! word!]							;-- word helps debugging
		; canvas [pair! none!]
		; drawn  [block!]
	; ][
		; if word? space [space: get name: space]			;@@ remove me once cache is stable to speed it up
		; unless select space 'cache? [exit]				;-- do nothing if caching is disabled
		; cache: find/same last visited-nodes space
		; #assert [cache]
		; canvas: any [canvas 'none]						;@@ workaround for #5126
		; unless pos: find/skip/part skip cache 3 canvas period slots [
			; pos: skip cache 3 + (cache/3 * period)
			; change at cache 3 cache/3 + 1 % (slots / period)	;@@ #5120 ;-- rotate slot for the next canvas
			; pos/1: canvas								;@@ #5120
			; change pos canvas
		; ]
		; pos/2: drawn									;@@ #5120
		; #assert [pair? space/size]
		; rechange next pos [space/size select space 'map drawn]
		; #debug cache [
			; name: any [name 'space]
			; #print "Saved cache for (name) size=(space/size) on canvas=(canvas): (mold/flat/only/part drawn 40)"
		; ]
	; ]
	
	; set-parent: function [
		; "Mark parent/child relationship in the new parents cache"
		; child  [object!]
		; parent [object! none!]							;-- parent=none is allowed to mark top level spaces as cacheable
	; ][
		; #assert [not child =? parent]
		; node: last visited-nodes						;-- tree node where current `child` is found
		; either parents: select/same parents-list child [
			; pos: any [
				; find/same/only parents node				;-- do not duplicate parents
				; tail parents
			; ]
			; rechange pos [node parent]					;-- each parent contains different node with this child 
		; ][
			; repend parents-list [child reduce [node parent]]
		; ]
	; ]
	
	; enter-cache-branch: function [
		; "Descend down the render cache tree into SPACE's branch"
		; space [object!] "Branch is created if doesn't exist"
	; ][
		; set-parent space last visited-spaces 			;-- once set, next renders will look it up in the cache
		; append visited-spaces space
		; append/only visited-nodes any [
			; select/same level: last visited-nodes space
			; also branch: make hash! 3 + slots * 2
				; append/dup repend level [space branch 0] 'free slots
		; ]
	; ]
	
	; leave-cache-branch: function [
		; "Ascend up the render cache tree"
	; ][
		; remove top visited-nodes
		; remove top visited-spaces
	; ]

	; #debug cache [										;-- for cache creep detection
		; cache-size?: function [node [any-block!]] [
			; size: length? node
			; forall node [
				; inner: node/2
				; size: size + cache-size? inner
				; node: skip node 2 + slots
			; ]
			; size
		; ]
		; parents-size?: function [] [
			; size: length? parents-list
			; foreach [_ block] parents-list [size: size + length? block]
		; ]
	; ]

	; #if true = get/any 'disable-space-cache? [
		; clear body-of :invalidate-cache
		; append clear body-of :get-cache none
		; clear body-of :commit-cache
		; clear body-of :set-parent
		; clear body-of :enter-cache-branch
		; clear body-of :leave-cache-branch
	; ]
	
	; ;-- draw code has to be evaluated after current-path changes, for inner calls to render to succeed
	; with-style: function [
		; "Draw calls should be wrapped with this to apply styles properly"
		; name [word!] code [block!]
	; ][
		; append current-path name
		; trap/all/catch code [
			; msg: form/part thrown 1000					;@@ should be formed immediately - see #4538
			; #print "*** Failed to render (name)!^/(msg)^/"
		; ]
		; take/last current-path
	; ]
	
	; render-face: function [
		; face [object!] "Host face"
		; /only xy1 [pair! none!] xy2 [pair! none!]
	; ][
		; #debug styles [#print "render-face on (face/type) with current-path: (mold current-path)"]
		; #assert [
			; is-face? :face
			; face/type = 'base
			; in face 'space
			; empty? current-path
		; ]

		; host: face										;-- required for `same-paths?` to have a value (used by cache)
		; with-style 'host [
			; style: compose/deep bind get-current-style face	;-- host style can only be a block
			; drawn: render-space/only/on face/space xy1 xy2 face/size
			; #assert [block? :drawn]
			; unless face/size [								;-- initial render: define face/size
				; space: get face/space
				; #assert [space/size]
				; face/size: space/size
				; style: compose/deep bind get-current-style face	;-- reapply the host style using new size
			; ]
			; render: reduce [style drawn]
		; ]
		; #debug cache [#print "cache size=(cache-size? render-cache) parents size=(parents-size?)"]
		; any [render copy []]
	; ]

	; render-space: function [
		; name [word!] "Space name pointing to it's object"
		; /only xy1 [pair! none!] xy2 [pair! none!]
		; /on canvas [pair! none!]
	; ][
		; if name = 'cell [?? canvas]
		; #debug profile [prof/manual/start 'render]	
		; space: get name
		; if canvas [canvas: max 0x0 canvas]				;-- simplifies some arithmetics; but subtract-canvas is better
		; #assert [space? :space]
		; #assert [not is-face? :space]					;-- catch the bug of `render 'face` ;@@ TODO: maybe dispatch 'face to face
		; #assert [
			; any [
				; none = canvas canvas +<= (1e6 by 1e6) canvas/x = 2e9 canvas/y = 2e9
				; also no #print "(name): canvas=(canvas)" 
			; ] "Oversized canvas detected!"
		; ]
		; #assert [
			; any [
				; none = canvas  0x0 +<= canvas
				; also no #print "(name): canvas=(canvas)" 
			; ] "Negative canvas detected!"
		; ]

		; with-style name [
			; style: get-current-style
			; ;@@ this does not allow the style code to invalidate the cache
			; ;@@ which is good for resource usage, but limits style power
			; ;@@ so maybe compose styles first, then check the cache?
			
			; either all [
				; not xy1 not xy2							;-- usage of region is not supported by current cache model
				; cache: get-cache name canvas
			; ][
				; set [size: map: render:] next cache
				; #assert [pair? size]
				; maybe space/size: size
				; if in space 'map [space/map: map]
				; set-parent space last visited-spaces	;-- mark it as cached in the new parents tree
				; #debug cache [							;-- add a frame to cached spaces after committing
					; render: compose/only [(render) pen green fill-pen off box 0x0 (space/size)]
				; ]
			; ][
				; if name = 'list [print ["canvas:" canvas mold space/item-list]]
				; #debug profile [prof/manual/start name]
				; enter-cache-branch space
				
				; either block? :style [
					; style: compose/deep bind style space	;@@ how slow this bind will be? any way not to bind? maybe construct a func?
					; draw: select space 'draw
					
					; ;@@ this basically cries for FAST `apply` func!!
					; if function? :draw [
						; spec: spec-of :draw
						; either find spec /only [only: any [xy1 xy2]][set [xy1: xy2: only:] none]
						; canvas': either find spec /on [		;-- must not affect `canvas` used by cache, thus new name
							; constrain canvas space/limits
						; ][
							; on: none						;-- don't constrain if no /on refinement
						; ]
						; code: case [						;@@ workaround for #4854 - remove me!!
							; all [canvas' only] [[draw/only/on xy1 xy2 canvas']]
							; only               [[draw/only    xy1 xy2        ]]
							; canvas'            [[draw/on              canvas']]
						; ]
					; ]
					; draw: either code [do copy/deep code][draw]	;-- call the draw function if not called yet
					; #assert [block? :draw]
					
					; if empty? style [unset 'style]
					; render: compose/only [(:style) (:draw)]		;-- compose removes style if it's unset
				; ][
					; #assert [function? :style]
					; ;@@ this basically cries for FAST `apply` func!!
					; spec: spec-of :style
					; either find spec /only [only: any [xy1 xy2]][set [xy1: xy2: only:] none]
					; canvas': either find spec /on [		;-- must not affect `canvas` used by cache, thus new name
						; constrain canvas space/limits
					; ][
						; on: none						;-- don't constrain if no /on refinement
					; ]
					; code: case [					
						; all [canvas' only] [[style/only/on space xy1 xy2 canvas']]
						; only               [[style/only    space xy1 xy2        ]]
						; canvas'            [[style/on      space         canvas']]
					; ]
					; render: either code [do copy/deep code][style space]	;@@ workaround for #4854 - remove me!!
					; #assert [block? :render]
				; ]
				
				; leave-cache-branch
				; unless any [xy1 xy2] [commit-cache name canvas render]
				; commit-cache space canvas render
				
				; #debug profile [prof/manual/end name]
				; #assert [any [space/size name = 'grid] "render must set the space's size"]	;@@ should grid be allowed have infinite size?
			; ]
		; ]
		; #debug profile [prof/manual/end 'render]	
		; either render [
			; reduce ['push render]						;-- don't carry styles over to next spaces
		; ][
			; []											;-- never changed, so no need to copy it
		; ]
	; ]

	; set 'render function [
		; "Return Draw code to draw a space or host face, after applying styles"
		; space [word! object!] "Space name, or host face as object"
		; /only "Limit rendering area to [XY1,XY2] if space supports it"
			; xy1 [pair! none!] xy2 [pair! none!]
		; /on canvas [pair! none!] "Specify canvas size as sizing hint"
	; ][
		; render: either word? space [:render-space][:render-face]
		; render/only/on space xy1 xy2 canvas
		; drawn: either word? space [					;@@ workaround for #4854 - remove me!!
			; render-space/only/on space xy1 xy2 canvas
		; ][
			; render-face/only space xy1 xy2
		; ]
		; #debug draw [									;-- test the output to figure out which style has a Draw error
			; if error? error: try/keep [draw 1x1 drawn] [
				; prin "*** Invalid draw block: "
				; attempt [copy/deep drawn]				;@@ workaround for #5111
				; probe~ drawn
				; do error
			; ]
		; ]
		; drawn
	; ]
; ]

simpler flat cache model, but I'm afraid it won't work with fixed number of slots
because if the same e.g. image is shared multiple times around, 4 slots now become a bottleneck
since it may be given a vast variety of canvases
I could apply limits before fetching canvas, but it's still not a solution but a kludge
what if limits are undefined, but size is fixed anyway?
; ;; after changing cache format multiple times, I'm using named constants now:
; prefix:         2									;-- size before the first slot
; period:         4									;-- size occupied by a single cached entry
; slots:          period * 4							;-- size occupied by cache of single space - a multiple of period!
; ;@@ TODO: both render-cache and parents-list require cleanup on highly dynamic layouts, or they slow down
; ;@@ will need a flat registry of still valid spaces
; render-cache:   make hash! slots + prefix * 3
; parents-list:   make hash! 2048

; free-list:      copy/deep block-stack				;-- used to reduce memory pressure
; free-list/size: slots

; ;@@ a bit of an issue here is that <everything> doesn't call /invalidate() funcs of all spaces
; ;@@ but maybe they won't be needed as I'm improving the design?
; set 'invalidate function [
	; "Invalidate SPACE content and cache, or use <everything> to affect all spaces' cache"
	; space [word! object! tag!] "If contains `invalidate` func, it is evaluated"
; ][
	; if word? space [
		; space: get space
		; #assert [object? space]
	; ]
	; invalidate-cache space
	; all [
		; object? space
		; any-function? custom: select space 'invalidate
		; custom
	; ]
; ]

; invalidation-stack: make hash! []

; set 'invalidate-cache function [
	; "If SPACE's draw caching is enabled, enforce next redraw of it and all it's ancestors"
	; space [object! tag!] "Use <everything> to affect all spaces"
	; /only "Do not invalidate parents (e.g. if they are invalid already)"
; ][
	; #debug profile [prof/manual/start 'invalidation]
	; either tag? space [
		; #assert [space = <everything>]
		; ;@@ what method to prefer? parse or radical (clear)?
		; clear render-cache
		; clear parents-list
		; parse render-cache rule: [any [skip into rule skip slots change skip 'free]]
	; ][
		; unless find/same invalidation-stack space [			;-- stack overflow protection for cyclic trees 
			; #debug cache [#print "Invalidating space=[(mold/part/only/flat body-of space 80)]"]
			; if node: find/same rendering-cache space [
				; fast-remove node prefix + slots
			; ]
			; ;; no matter if cache?=yes or no, parents still have to be invalidated
			; if all [
				; not only
				; parents: select/same parents-list space
			; ][
				; append invalidation-stack space
				; #assert [not find/same parents space]
				; foreach parent parents [invalidate-cache parent]
				; remove top invalidation-stack				;@@ not using take/last for #5066
			; ]
		; ]
	; ]
	; #debug profile [prof/manual/end 'invalidation]
; ]

; find-cache: function [
	; "Find location of SPACE in the currently rendered cache node"
	; space [object!]
; ][
	; find/same render-cache space
; ]

; get-cache: function [
	; "If SPACE's draw caching is enabled and valid, return it's cached slot for given canvas"
	; space [object! word!] canvas [pair! none!]		;-- word helps debugging
; ][
	; if word? space [space: get name: space]			;@@ remove me once cache is stable to speed it up
	; r: all [
		; cache: find-cache space						;-- must have a cache
		; find/skip/part skip cache prefix canvas period slots
	; ]
	; if cache [print rejoin ["cache=" map-each/eval [a b _] copy/part skip cache prefix slots [[a b]]]]
	; #debug cache [
		; name: any [name 'space]
		; either r [
			; #print "Found cache for (name) size=(space/size) on canvas=(canvas): (mold/flat/only/part to [] r 40)"
		; ][
			; reason: case [
				; cache [rejoin ["cache=" mold to [] extract copy/part skip cache 3 slots period]]
				; not space/size ["never drawn"]
				; not select space 'cache? ["cache disabled"]
				; 'else ["not cached or invalidated"]
			; ]
			; #print "Not found cache for (name) size=(space/size) on canvas=(canvas), reason: (reason)"
		; ]
	; ]
	; r
; ]

; commit-cache: function [
	; "Save SPACE's Draw block on this CANVAS in the cache"
	; space  [object! word!]							;-- word helps debugging
	; canvas [pair! none!]
	; drawn  [block!]
; ][
	; if word? space [space: get name: space]			;@@ remove me once cache is stable to speed it up
	; unless select space 'cache? [exit]				;-- do nothing if caching is disabled
	; cache: find/same render-cache space
	; #assert [cache]
	; #assert [pair? space/size]
	; map: select space 'map							;-- doesn't have to exist
	; either node: find/skip/part skip cache prefix canvas period slots [
		; rechange next node [space/size map drawn]
	; ][
		; node: skip cache cache/:prefix * period + prefix
		; rechange back node [
			; cache/:prefix + 1 % (slots / period) 	;-- rotate slot for the next canvas
			; canvas space/size map drawn
		; ]
	; ]
	; #debug cache [
		; name: any [name 'space]
		; #print "Saved cache for (name) size=(space/size) on canvas=(canvas): (mold/flat/only/part drawn 40)"
	; ]
; ]

; set-parent: function [
	; "Mark parent/child relationship in the parents cache"
	; child  [object!]
	; parent [object! none!]
; ][
	; #assert [not child =? parent]
	; unless parent [exit]							;-- no parent for top level spaces = no need to hold it
	; either parents: select/same parents-list child [
		; any [
			; find/same/only parents parent			;-- do not duplicate parents
			; append/only parents parent
		; ]
	; ][
		; append/only append parents-list child reduce [parent]
	; ]
; ]

timers that took 100% CPU time in tube-test
; foreach-space [path space] face/space [
	; unless all [
		; rate: select space 'rate				;-- no rate facet
		; positive? rate							;-- disabled
	; ] [continue]
	; #assert [any [time? rate  float? rate  integer? rate]]
	; if number? rate [rate: 0:0:1 / rate]		;-- turn rate into period
	
	; pos: find/same/tail marks space
	; set [prev: bias:] any [pos [0:0 0:0]]
	; delay: either pos [difference time prev + rate][0:0]		;-- estimate elapsed delay for this timer
	; if delay < negate timer-resolution / 2 + bias [continue]	;-- too early to call it?
	
	; args: reduce/into [to 1% delay / rate] clear []
	; path: new-line/all as [] path no
	; ;; even if no time handler, actors or previewers/finalizers may be defined
	; events/do-previewers top path event args
	; forall path [
		; compose/into [handlers (path) on-time] clear hpath		;-- not allocated
		; unless block? try [list: get hpath] [continue]			;-- no time handler ;@@ REP #113
		; foreach handler list [									;-- call the on-time stack
			; #assert [function? :handler]
			; events/do-handler next hpath :handler top path event args 
		; ]
	; ]
	; events/do-finalizers top path event args
	
	; unless pos [pos: tail append marks space]
	; delay: min delay rate * 5					;-- avoid frame spikes after a lag or sleep
	; change change pos time bias + delay			;-- mark last timer call time for this space
	; ;@@ TODO: cap bias at some maximum, for 50+ fps cases, so it won't run away
	
	; time: now/utc/precise						;-- update time after handlers evaluation
; ]

turns out touch-clicks generate `over over down over` event chain, so no need to catch `down` since `over` hides the menu
actually, I need to catch also `up` and not generate `click`, but doesn't seem worth it
; ;; eats touch events outside the visible menu window
; register-previewer [down] function [				;-- previewer so it takes precedence on menu things
	; space [object! none!] path [block!] event [event!]
; ][
	; stack: get-popups-for event/window
	; if all [
		; menu: stack/2								;-- menu exists
		; find/same event/window/pane menu			;-- menu visible
		; not same? event/face menu					;-- click didn't land on menu host
	; ][
		; hide-popups event/window 1
		; stop										;-- eat the event, closing the menu
	; ]
; ]

wanted to use this for grid but reconsidered, decided to support explicit return instead
; fit-pair: function [
	; "Fit pair XY into SIZE/X if it sticks out horizontally"
	; xy   [pair!]
	; size [pair! none! unset!]
; ][
	; if all [
		; pair? :size
		; xy/x > size/x
	; ][
		; xy/y: xy/y + to integer! xy/x - 1 / size/x
		; xy/x: xy/x - 1 % size/x + 1
	; ]
	; xy
; ]

; #assert [
	; 3x2 = fit-pair 3x2 none
	; 3x2 = fit-pair 3x2 10x10
	; 3x2 = fit-pair 3x2 3x3
	; 3x2 = fit-pair 7x1 4x0
	; 1x3 = fit-pair 3x2 2x3
; ]

original field handlers
; field: [
	; ;-- `key-down` supports key-combos like Ctrl+Tab, `key` does not seem to
	; ;-- OTOH `key` properly reflects Shift state in chars
	; ;-- so we have to use both
	; on-key [space path event] [				;-- char keys branch (inserts stuff as you type)
		; k: event/key
		; either space/active? [					;-- normal input when active
			; unless all [
				; char? k
				; any [
					; k >= #" "						;-- printable char
					; k = #"^-"						;-- Tab
					; if k = #"^M" [k: #"^/"]			;-- Enter -> NL
				; ]
			; ] [exit]
			; ;@@ allow new-line char only when multiline?
			; ;@@ TODO: input validation / filtering
			; t: space/text
			; ci: space/caret-index:
				; 1 + clip reduce [0 length? t]		;-- caret-index may be >len if text was changed
					; space/caret-index
			; insert at t ci  k
			; space/invalidate						;@@ TODO: should be caught maybe automatically?
			; update
		; ][										;-- has to handle Enter, or both key-down and key will handle it, twice
			; either k = #"^M" [
				; maybe space/active?: yes			;-- activate it on Enter
				; update								;-- let styles change
			; ][
				; pass								;-- pass keys in inactive state (esp. tab)
			; ]
		; ]
	; ]
	
	; on-key-down [space path event] [			;-- control keys & key combos branch (navigation)
		; k: event/key
		; unless space/active? [pass exit]			;-- keys should be passed thru (tab, arrows, ...); Enter is in on-key
													; ;-- else, keys should be used on content (e.g. arrows)
		; if all [
			; char? k									;-- ignore chars without mod keys
			; not any [
				; find "^[^H" k						;-- use only Esc and BS
				; event/ctrl?
			; ]
		; ] [pass exit]

		; len: length? t: space/text
		; ci: clip [0 len] space/caret-index			;-- may be >len if text was changed
		; switch/default k: event/key [
			; left   [ci: ci - 1]			;@@ TODO: ctrl-arrow etc logic
			; right  [ci: ci + 1]
			; home   [ci: 0]
			; end    [ci: len]
			; delete [remove skip t ci]
			; #"^H"  [remove skip t ci: ci - 1]		;-- backspace
			; #"^["  [maybe space/active?: no]		;-- Esc = deactivate
		; ][exit]									;-- not supported yet key
		; maybe space/caret-index: clip reduce [0 length? t] ci		;-- length may have changed, <> len
		; update
	; ]

	; on-key-up [space path event] []				;-- eats the event so it's not passed forth

	; on-click [space path event] [
		; #assert [space/paragraph/layout]
		; maybe space/caret-index: offset-to-caret space/paragraph/layout path/2
		; maybe space/active?: yes					;-- activate, so Enter is not required
		; update										;-- let styles update
	; ]

	; on-focus [space path event] [
		; maybe space/caret/visible?: yes
		; update
	; ]

	; on-unfocus [space path event] [
		; maybe space/caret/visible?: no
		; update
	; ]
; ]

window/max-size was a super messy concept, not needed after adding canvas to window (good riddance)
it's persistence just didn't work together with the volatility of /sizes, at all 
; autosize-window: function [] [
	; size: any [self/size if self/limits [self/limits/min]]
	; if 0x0 +< size [maybe window/max-size: pages * size]	;-- don't ever make window empty
	; #debug sizing [#print "autosized window to (window/max-size)"]
; ]
; ;; this initializes window size to a multiple of list-view sizes (paragraphs adjust to window then)
; ;; overrides inf-scrollable's own autosize-window because `list-view` has a linear `pages` interpretation (not 2D)
; autosize-window: function [lview [object!]] [
	; size: any [lview/size lview/limits/min]			;@@ rethink how to better handle integer or invalid limit
	; unit: axis2pair lview/list/axis
	; ;; account for scrollers size, since list-view is meant to always display one along main axis
	; ;; this will make window and it's content adapt to list-view width when possible
	; ;@@ it's a bit dumb to _always_ subtract scrollers even if they're not visible
	; ;@@ need more dynamic way of adapting window size
	; scrollers: lview/hscroll/size * 0x1 + (lview/vscroll/size * 1x0) * reverse unit
	; #assert [0x0 <> size]
	; maybe lview/window/max-size: lview/pages - 1 * unit + 1 * size - scrollers
	; #assert [0x0 <> lview/window/max-size]
	; #debug sizing [#print "autosized window to (lview/window/max-size)"]
; ]

glossy triangles - decided against it, less code
; make-triangular-shape: function [
	; "Make a curved triangle"
	; size [pair!]
	; dir  [word!]  "n/s/e/w"
; ][
	; size: size * 4 / 3
	; box: size - 2
	; corners: reduce select [
		; n [2 by box/y  size/x / 2 by 2  box]
		; s [2x2 size/x / 2 by box/y  box/x by 2]
		; w [box/x by 2  2 by (size/y / 2)  box]
		; e [2x2 box/x by (size/y / 2)  2 by box/y]
	; ] dir
	; centers: reduce [
		; corners/1 + corners/2 / 2
		; corners/2 + corners/3 / 2
		; corners/3 + corners/1 / 2
	; ]
	; shape: reduce [
		; 'move centers/2
		; 'qcurve corners/3 centers/3 corners/1 centers/1 corners/2 centers/2 
	; ]
	; mul: select [n 1x2 s 1x0 w 2x1 e 0x1] dir
	; ofs: size / -4 * mul / 2
	; compose/deep/only [translate (ofs) [shape (shape)]]
; ]
; draw-triangular-frame: function [
	; "Draw a glossy triangular frame"
	; size [pair!]
	; bgnd [tuple!] "Background color"
	; dir  [word!]  "n/s/e/w"
; ][
	; shape: make-triangular-shape size dir
	; compose/deep/only [
		; line-width 2
		; pen (bgnd) fill-pen (bgnd)
		; (shape)
		
		; fill-pen off
		; pen s4 translate -1x-1 (shape)
		; pen s0 translate  1x1  (shape)
		; line-width 1
		; pen w3 (shape)
	; ]
; ]
; draw-triangular-sheen: function [
	; "Draw a bumpy triangular sheen"
	; size  [pair!]
	; dir   [word!]  "n/s/e/w"
	; sheen [percent! float!] "How pronounced is the sheen, 0-100%"
; ][
	; shape: make-triangular-shape size dir
	; edge: max size/x size/y
	; scolor: 0.0.0.255 * (100% - sheen) + white
	; sheen: switch dir [
		; s [size / 2x4 - (1x1 * edge / 2)]
		; n [size * 2x2 / 4x3 - (1x1 * edge / 2)]
		; e [size / 4x2 - (1x1 * edge / 2)]
		; w [size * 2x2 / 3x4 - (1x1 * edge / 2)]
	; ]
	; compose/deep/only [
		; pen off
		; fill-pen radial (scolor) 0.0 glass 1.0 (1x1 * edge / 2) (to integer! 1.5 * edge / 2) (sheen)
		; (shape)
	; ]
; ]
; draw-glossy-triangle: function [
	; "Draw a glossy rounded triangle"
	; size  [pair!]
	; bgnd  [tuple!]
	; sheen [percent!]
	; dir   [word!]  "n/s/e/w"
; ][
	; compose/deep [
		; (draw-triangular-frame size bgnd dir) 
		; (draw-triangular-sheen size dir sheen)
	; ]
; ]

initial design of field, not so stylable as I would like it to be
; on-change: function [field [object!] word [any-word!] old [any-type!] new [any-type!]] [
	; switch to word! word [
		; origin selected [invalidate-cache field]	;-- invalidating just cache in enough since text is the same
		; text [
			; field/caret/offset: length? new			;-- auto position at the tail; invalidated by text
			; mark-history field
		; ]
	; ]
	; field/text-on-change word :old :new
; ]
; ;@@ field will need on-change handler & actor support for better user friendliness!
; ;; based directly on text to expose /text facet which would be hard to sync both ways otherwise
; templates/field: make-template 'text [
	; weight:    1
	; origin:    0
	; selected:  none
	; history:   make block! 100						;-- saved states
	
	; caret:     make-space 'caret []
	; selection: make-space 'rectangle []				;-- can be styled
	
	; edit: func [
		; "Apply a sequence of edits to the text"
		; plan [block!]
	; ][
		; ~/edit self plan
	; ]
	
	; text-draw: :draw
	; draw: func [/on canvas [none! pair!]] [~/draw self canvas]
	
	; text-on-change: :on-change*
	; #on-change-redirect
; ]

field-ctx/caret-to-offset but it's not yet needed
; caret-to-offset: func [
	; "Get (absolute) offset (as integer) of a caret location [0..length] from text beginning"	;@@ need a pair return?
	; field [object!] location [integer!]
; ][
	; first system/words/caret-to-offset layout
		; field/spaces/text/layout
		; location + 1
; ]

first iteration of the autofit, worked but not so resilient			
; ;; this should not use hcache, or it will have to be cleared all the time
; col-height?: function [grid [object!] col [integer!] width [integer!] rows [integer!]] [	;-- used by autofit only
	; r: 0
	; canvas: encode-canvas width by infxinf/y 1x-1
	; repeat i rows [
		; xy: col by i
		; h: any [grid/heights/:i grid/heights/default]		;-- row may be fixed
		; unless integer? h [
			; space: get name: any [grid/ccache/:xy  grid/wrap-space xy grid/cells/pick xy]
			; render/on name canvas
			; h: space/size/y
		; ]
		; r: r + h									;-- does not use any spacing or margins
	; ]
	; r
; ]
; ;; stochastic content-agnostic column width fitter
; autofit: function [
	; "Automatically adjust GRID column widths for best look"
	; grid  [object!]
	; width [integer!] "Total grid width to fit into"
; ][
	; #assert [not grid/infinite? "Adjustment of infinite grid will take infinite time!"]
	; ;; does not modify grid/heights - at least some of them must be `auto` for this func to have effect
	; bounds: grid/cells/size
	; nx: bounds/x  ny: bounds/y
	; if any [nx <= 1 ny <= 0] [exit]					;-- nothing to fit - single column or no rows
	
	; widths: grid/widths
	; w0: to integer! width / nx
	; repeat i nx [widths/:i: w0]						;-- starting point - uniform
	
	; min-width: any [grid/widths/min 5]
	; precision: 5									;-- limit when to stop adjusting (pixels)
	; loop 10 [										;-- prevent deadlocks
		; adjustment: 0
		; h2: col-height? grid 1 widths/1 ny
		; for x: 2 nx [
			; w1: widths/(x - 1)  w2: widths/:x
			; h1: h2  h2: col-height? grid x w2 ny
			; if h1 = h2 [continue]					;-- balanced - don't touch this time
			; ;@@ maybe make a few attempts? e.g. 50% 100% 150% 200% of dw, or a few random points?
			; ;@@ random might be bad for result stability, but more reliable in case of big spaces within
			; dh: clip [5% 50%] 50% * (h2 - h1) / (max 1 min h1 h2)
			; dw: to integer! (min w1 w2) * dh
			; w1: max min-width w1 - dw
			; w2: max min-width w2 + dw
			; new-h1: col-height? grid x - 1 w1 ny
			; new-h2: col-height? grid x     w2 ny
			; print [h1 h2 '-> new-h1 new-h2]
			; if positive? win: (max h1 h2) - (max new-h1 new-h2) [	;@@ maybe also smaller attempts?
				; h2: new-h2
				; widths/(x - 1): w1
				; widths/:x:      w2
				; adjustment: max adjustment win
			; ]
		; ]
		; ?? adjustment
		; if adjustment <= precision [break]
	; ]
	; invalidate grid									;-- also clears hcache
; ]

hyperbolic autofit that still supported multiple iterations, but it's totally not worth it, too slow for naught
; autofit: function [
	; "Automatically adjust GRID column widths to minimize grid height"
	; grid        [object!]
	; total-width [integer!] "Total grid width to fit into"
	; method      [word!]    "One of supported fitting methods: [hyperbolic weighted simple-weighted]"	;@@
; ][
	; #assert [any [row2 not grid/infinite?] "Adjustment of infinite grid will take infinite time!"]
	; ;; does not modify grid/heights - at least some of them must be `auto` for this func to have effect
	; bounds: grid/cells/size
	; nx: bounds/x  ny: bounds/y
	; if any [nx <= 1 ny <= 0] [exit]					;-- nothing to fit - single column or no rows
	
	; margin:  1x1 * grid/margin
	; spacing: 1x1 * grid/spacing
	; widths: grid/widths								;-- modifies widths map in place
	; min-width: any [widths/min 5]					;@@ make an option to control this?
	
	; set-widths: [
		; error: 0									;-- accumulated rounding error is added to next column
		; repeat i nx [
			; widths/:i: hit: round/to aim: W/:i + error 1
			; error: aim - hit
		; ]
	; ]
	
	; ;@@ TODO: min/max widths can most of the time be cached (should be an option), saving 2 renders
	; loop 1 [
		; ;@@ perhaps an optimization case for very small total-width here?
		; ;@@ although by current convention it should return minimal rendered widths
		
		; ;; render all columns on zero, get their min widths W1i and heights H1i
		; W1: make vector! reduce ['float! 64 nx]
		; H1: copy W1
		; repeat i nx [
			; size: measure-column grid i 0 1 ny
			; W1/:i: to float! max min-width size/x
			; H1/:i: to float! size/y
		; ]
		
		; ;; estimate space left SL = TW - sum(W1i), TW is total-width requested
		; TW: total-width - (2 * margin/x) - (nx - 1 * spacing/x)
		; SL: TW - TW0: sum W1
		; echo [total-width TW SL TW0]
		; ?? W1 ?? H1
		
		; ;; if SL <= 0, end here, set widths to found amounts
		; if SL <= 0 [W: W1  do set-widths  break]
		
		; ;; SL > 0 case: render all columns on W2i = W1i + SL, now I have heights H2i
		; W2: copy W1
		; H2: copy H1
		; repeat i nx [
			; if iterations > 1 [HE: HE + (pick tail h-vector -2) / 2]
			; size: measure-column grid i to integer! W1/:i + SL 1 ny
			; size: measure-column grid i infxinf/x 1 ny
			; W2/:i: to float! max W1/:i size/x			;-- generally W2i <= W1i + SL
			; H2/:i: to float! min H1/:i - 1 size/y		;-- 1px to avoid zero division, and ensure strict monotony
		; ]
		; TW2: sum W2
		
		; ;; if maximum possible width is less than requested, use it
		; ;@@ maybe make an option to stretch the grid to TW even if there's no point?
		; if TW2 <= TW [W: W2  do set-widths  break]
		
		; ?? W2 ?? H2
		
		; ;; 'true' and '1' are equivalent; and if /autofit is off and function is called manually, it does a single iteration
		; iterations: either integer? n: grid/autofit [n][1]
		
		; ;@@ observe off-hyperbola estimate misses (and imperfection constants) and check them vs other algorithms?
		; ;; now given initial W1-W2/H1-H2 bounds, find an optimum once per allowed iteration
		; repeat n-iter iterations [
		
			; C: (H2 * W2) - (H1 * W1) / (H1 - H2 + 1e-10)	;-- hyperbolae imperfection constants, epsilon to avoid zero division
; print "wtf"
; ?? H1 ?? W1 ?? H2 ?? W2
			; ?? C		
; W: (copy W2) + C * H2 / H1 - C			;-- (W + C) * H = (W2 + C) * H2
; ?? W ?? W1
		
			; ;; arrange all heights H1i and H2i in a vector, sort it by height, remembering i for each height
			; h-vector: clear any [h-vector  make block! nx * 2 * 2]
			; repeat i nx [									;@@ use map-each
				; repend h-vector [H1/:i 0  H2/:i 0]			;-- H1 >= H2, adding already back-sorted pair
			; ]
			; sort/skip/reverse h-vector 2					;-- sorted from the biggest height
			
			; ;; walk over this vector and for each point compute total width TWj (j now is sorted index on the vector)
			; ;; during the scan, choose the segment j=m where TWm < TW < TWm+1
			; h-vector/2: TW0									;-- start from min. total width
			; for-each [pos: Hj TWj | Hj+1] h-vector [...]
			; repeat j nx * 2 - 1 [							;@@ what a mess, use for-each when it's fast
				; set [Hj: TWj: Hj+1:] pos: skip h-vector j - 1 * 2
				; W: (copy W2) + C * H2 / Hj+1 - C			;-- (W + C) * H = (W2 + C) * H2
				; ?? W
				; TWj+1: 0.0
				; repeat i nx [TWj+1: TWj+1 + clip [W1/:i W2/:i] W/:i]	;-- clip within the segment of definition [W1i,W2i]
				; ?? TWj+1
				; pos/4: TWj+1
				; #assert [TWj+1 >= TWj]
				; if all [TWj <= TW  TW < TWj+1] [			;-- found the j-th segment containing desired total width
					; H+:  Hj   H-:  Hj+1
					; TW-: TWj  TW+: TWj+1
					; break
				; ]
			; ]
			; ?? h-vector
			; echo [H- H+ TW- TW+]
			
			; ;; now find height estimate HE corresponding to the closest width to TW on the j-th segment [Hj+1,Hj] using binary search
			; threshold: 10									;-- total width estimation precision (bigger requires less iterations)
			; either not H- [									;-- if total width is too big, no segment found
				; HE: Hj+1									;-- choose max width/min height
			; ][
				; HE: H+  TWE: TW-							;-- initial estimate is bigger height so TWE <= TW+
				; print "-- going into the search --"
				; ?? TW ?? TW- ?? TW+ ?? HE ?? TWE 
				; forever [									;-- perform binary search
					; ?? TWE
					; if all [TWE <= TW  TW <= (TWE + threshold)] [break]		;-- found it already; segment is too narrow
					; HE: H+ + H- / 2
					; WE: (copy W2) + C * H2 / HE - C
					; TWE: 0.0
					; repeat i nx [TWE: TWE + clip [W1/:i W2/:i] WE/:i]		;-- clip within the segment of definition [W1i,W2i]
					; either TWE <= TW						;-- use TWE as new low or high boundary
						; [TW-: TWE H+: HE]					;-- TWE(TW-) <= TW <= TW+
						; [TW+: TWE H-: HE]					;-- TW- <= TW < TWE(TW+)
				; ]
				; print ["found"]
				; ?? TWE ?? H- ?? H+ ?? WE
			; ]
			; #assert [(abs TWE - TW) <= threshold]
							
			; W: (copy W2) + C * H2 / HE - C
			; repeat i nx [W/:i: clip [W1/:i W2/:i] W/:i]
			; ?? W
			; W: W + (TW - TWE / length? W)					;-- evenly distribute remaining space
			; do set-widths

			; ;; they should in total sum to TW (need assertion here)
			; #assert [TW ~= sum W]
			
			; ;; prepare the next iteration: render columns on newly found widths and use that as new W1/H1 or W2/H2
			; ;; (otherwise it's up to `render` to draw everything)
			; if n-iter <> iterations [
				; print "-- iteration preparation --"
				; ;; estimate column sizes, to get total height
				; W: copy W1  H: copy H1
				; repeat i nx [
					; size: measure-column grid i widths/:i 1 ny
					; W/:i: to float! clip [W1/:i W2/:i] size/x		;-- whatever happens to new width, put it within [W1,W2]
					; H/:i: to float! clip [H2/:i H1/:i] size/y
				; ]
				; total-height: last sort copy H
				
				; ;; decide which points to use in the new iteration for each column
				; tolerance: 10						;-- distance from real to estimated column height that should be considered precise
				; limits-adjusted?: no
				; ?? W1 ?? W2 ?? H1 ?? H2 ?? W ?? H
				; ?? HE ?? TWE
				; repeat i nx [
					; if case [
						; true [
							; W1/:i: W/:i
							; H1/:i: H/:i
						; ]
						; H/:i < (HE - tolerance) [	;-- real height below the estimate, use it as new low limit (H2)
						; W/:i * H/:i > (WE/:i * HE + tolerance) [	;-- real height below the estimate, use it as new low limit (H2)
							; H2/:i: H/:i
							; W2/:i: W/:i
						; ]
						; H/:i > (HE + tolerance) [	;-- real height above the estimate, use it as new high limit (H1)
						; W/:i < (WE/:i - tolerance) [	;-- real height above the estimate, use it as new high limit (H1)
							; H1/:i: H/:i
							; W1/:i: W/:i
						; ]
						; ;; if it's near estimate, it's an ideal hyperbola and no correction needed
					; ] [limits-adjusted?: yes]
				; ]
				; unless limits-adjusted? [break]		;-- stop iterating if W/H vectors are precise and didn't change
				; ?? W1 ?? W2 ?? H1 ?? H2
				; TW0: sum W1
				; ;@@ make 2 algorithms: hyperbolic and golden section
			; ]
		; ]
	; ]
	
	; clear grid/hcache								;-- line height cache is no longer valid after widths have changed
; ]

analytical (mostly) solution for area-difference fitting algo, which I see no point in
binary search is shorter, simpler, and not slower, and if we add min/max support for vectors and fast sum, it will be faster
; area-difference [
	; ;; now given initial W1-W2/H1-H2 bounds, find an optimum
	; C: (H2 * W2) - (H1 * W1) / (H1 - H2 + 1e-6)	;-- hyperbolae offsets, +epsilon to avoid zero division

	; ;; arrange all heights H1i and H2i in a vector, sort it by height, remembering i for each height
	; h-vector: clear any [h-vector  make block! nx * 2 * 2]
	; repeat i nx [								;@@ use map-each
		; repend h-vector [H1/:i 0  H2/:i 0]		;-- H1 >= H2, adding already back-sorted pair
	; ]
	; sort/skip/reverse h-vector 2				;-- sorted from the biggest height
	
	; ;; walk over this vector and for each point compute total width TWj(TW-) (j now is sorted index on the vector)
	; ;; during the scan, choose the segment j where TWj(TW-) < TW < TWj+1(TW+)
	; h-vector/2: TW1								;-- start from min. total width
	; repeat j nx * 2 - 1 [						;@@ what a mess, use for-each when it's fast
		; set [H+: TW-: H-:] pos: skip h-vector j - 1 * 2
		; W: (copy W2) + C * H2 / H- - C			;-- (W + C) * H = (W2 + C) * H2
		; pos/4: TW+: sum clip-vector W W1 W2		;-- clip within [W1i,W2i] since hyperbola extends outside this segment
		; #assert [TW+ >= TW-]
		; if all [TW- <= TW  TW < TW+] [break]	;-- found the j-th segment containing desired total width
	; ]
	
	; ;; total width estimation precision (bigger requires less iterations but is more jumpy when resizing)
	; threshold: 5
	
	; ;; now find height estimate HE corresponding to the closest width to TW on the j-th segment [H-..H+] using binary search
	; set [H-: TW+: HE: TWE:]						;-- use lower width as estimate since it's <= TW
		; binary-search/with HE H- H+ TW threshold [
			; WE: (copy W2) + C * H2 / HE - C
			; sum clip-vector WE W1 W2			;-- clip within [W1i,W2i] since hyperbola extends outside this segment
		; ] TW+ TW-
	; #assert [(abs TWE - TW) <= threshold]
					
	; W: (copy W2) + C * H2 / HE - C
	; W: clip-vector W W1 W2
	; W: W + (TW - TWE / length? W)				;-- evenly distribute remaining space
; ]

failed attempt at timers optimization.. in vids-polygon no timers worked because memoizes an empty path before cell is finished
; set 'paths-from-space function [
	; "Get all paths for SPACE on the last rendered frame"
	; space  [object!]
	; return: [path! block!] "May return single path! or a block of"
; ][
	; #assert [is-face? host]
	; unless result: select/same memoized-paths space [
		; result: make [] 10
		; path: clear []
		; paths-continue* space path result
	; ]
	; result
; ]
	
; paths-continue*: function [
	; space  [object!]
	; path   [block!]
	; result [block!]
; ][
	; parents: select/same render-cache space
	; either empty? parents [
		; unless is-face? space [exit]				;-- not rendered space - cannot be traced to the root ;@@ is-face is slow for this!
		; append/only result reverse copy head path
	; ][
		; append invalidation-stack space				;-- defence from cycles ;@@ rename since it's also used here?
		; foreach [parent child-name] parents [
			; unless find/same invalidation-stack parent [
				; change path child-name
				; paths-continue* parent next path result
			; ]
		; ]
		; remove path
		; remove top invalidation-stack
	; ]
; ]

on-change model is no longer that dumb, unused macro
; #macro [#on-change-redirect] func [s e] [				;@@ see REP #115
	; copy/deep [											;-- copy so it can be bound to various contexts
		; on-change*: func [word [any-word!] old [any-type!] new [any-type!]] [
			; ~/on-change self word :old :new
		; ]
	; ]
; ]

old slow invalidation code
; set 'invalidate function [
	; "Invalidate SPACE content and cache, or use <everything> to affect all spaces' cache"
	; space [word! object! tag!] "If contains `invalidate` func, it is evaluated"
	; /local custom									;-- can be unset during construction
; ][
	; if word? space [
		; space: get space
		; #assert [object? space]
	; ]
	; invalidate-cache space
	; all [
		; object? space
		; any-function? set/any 'custom select space 'invalidate
		; custom
	; ]
; ]
; invalidation-stack: make hash! 32
; set 'invalidate-cache function [
	; "If SPACE's draw caching is enabled, enforce next redraw of it and all it's ancestors"
	; space [object! tag!] "Use <everything> to affect all spaces"
	; /only "Do not invalidate parents (e.g. if they are invalid already)"
	; /forget "Forget also location on the tree (space won't receive timer events until redrawn)"
	; ;; /forget should be used to clean up cache from destroyed spaces (e.g. hidden menu)
; ][
	; #debug profile [prof/manual/start 'invalidation]
	; either tag? space [
		; #assert [space = <everything>]
		; ;@@ what method to prefer? parse or radical (clear)? clear is dangerous - breaks timers by destroying parents tree
		; clear render-cache
		; clear memoized-paths
	; ][
		; unless find/same invalidation-stack space [			;-- stack overflow protection for cyclic trees 
			; #debug cache [#print "Invalidating (any [select space-names space 'unknown]) of size=(space/size)"]
			; if pos: find/same memoized-paths space [fast-remove pos 2]
			; either node: find/same render-cache space [
				; ;; currently rendered spaces should not be invalidated, or parents get lost:
				; unless find/same visited-spaces space [
					; unless only [
						; ;; no matter if cache?=yes or no, parents still have to be invalidated
						; #assert [not find/same node/:parents-index space]	;-- normally space should not be it's own parent
						; #debug cache [
							; ;; this may still happen normally, e.g. as a result of a reaction on rendered space
							; #assert [empty? visited-spaces "Tree invalidation during rendering cycle detected"]
						; ]
						; append invalidation-stack space
						; either forget					;@@ use apply
							; [foreach [parent _] node/:parents-index [invalidate-cache/forget parent]]
							; [foreach [parent _] node/:parents-index [invalidate-cache parent]]
						; remove top invalidation-stack	;@@ not using take/last for #5066
						; if in space 'dirty? [space/dirty?: yes]		;-- mark for redraw
					; ]
					; clear node/:slots-index				;-- clear cached slots
					; if forget [
						; clear node/:parents-index		;-- clear parents now
						; change node 'free				;-- mark free for claiming (so blocks can be reused)
					; ]
				; ]
			; ][
				; if in space 'dirty? [space/dirty?: yes]		;-- mark host for redraw
			; ]
		; ]
	; ]
	; #debug profile [prof/manual/end 'invalidation]
; ]

other old caching code
; ;; render cache format: [space-object [parent-object name  ...] name [canvas space-size map drawn ...] ...]
; ;;   it holds rendered draw block of all spaces that have /cache = true
; ;;   space-size is required because `draw` usually changes space/size and if draw is avoided, /size still must be set
; ;;   same for the map: it changes with canvas, has to be fetched from the cache together with the draw block
; ;;   unused slots contain 'free word to distinguish committed canvas=none case from unused cache slot
; ;;   parent list is used by `invalidate` to go up the tree and invalidate all parents so the target space gets re-rendered
; ;;   it holds rendering tree of parent/child relationships on the last rendered frame
; ;;   name is the space's name in that particular parent, used by paths-from-space which is used by timers

; ;; caching workflow:
; ;; - drawn spaces draw blocks are committed to the cache if they have /cache enabled
; ;; - render checks cache first, and only performs draw if cache is not found
; ;;   each slot group corresponds to a particular canvas size
; ;;   (usually 3 slots: unlimited, half-unlimited and limited, but tube uses 3 other except none)
; ;; - spaces should detect changes in their data that require new rendering effort and call `invalidate`
; ;;   invalidate uses last rendered parents tree to locate upper nodes and invalidate them all
; ;;   (there can be multiple parents to the same space, but see comments on limitations)
; ;@@ TODO: document this in a proper place, remove from here

; ;; after changing cache format multiple times, I'm using named constants now:
; parents-index:  2									;-- where parents are located
; slots-index:    3									;-- where slots are located
; slot-size:      4									;-- size occupied by a single cached entry
; ;@@ TODO: render-cache requires cleanup on highly dynamic layouts, or they slow down
; ;@@ will need a flat registry of still valid spaces
; render-cache:   make hash! slots-index * 1024

; get-cache: function [
	; "If SPACE's draw caching is enabled and valid, return it's cached slot for given canvas"
	; space [object!] canvas [pair! none!]
; ][
	; r: all [
		; cache: find/same render-cache space			;-- must have a cache
		; find/skip cache/:slots-index canvas slot-size
	; ]
	; #debug cache [
		; name: any [select space-names space 'unknown]
		; either r [
			; #print "Found cache for (name) size=(space/size) on canvas=(canvas): (mold/flat/only/part to [] r 40)"
		; ][
			; reason: case [
				; cache [rejoin ["cache=" mold to [] extract cache/:slots-index slot-size]]
				; not space/size ["never drawn"]
				; not select space 'cache ["cache disabled"]
				; 'else ["not cached or invalidated"]
			; ]
			; #print "Not found cache for (name) size=(space/size) on canvas=(canvas), reason: (reason)"
		; ]
	; ]
	; r
; ]

; commit-cache: function [
	; "Save SPACE's Draw block on this CANVAS in the cache"
	; space  [object!]
	; canvas [pair! none!]
	; drawn  [block!]
; ][
	; unless select space 'cache [exit]				;-- do nothing if caching is disabled
	; #assert [pair? space/size]
	; map: select space 'map							;-- doesn't have to exist
	; node: find/same render-cache space
	; #assert [node "Node has been invalidated during render"]
	; either slot: find/skip node/:slots-index canvas slot-size [
		; rechange next slot [space/size map drawn]
	; ][
		; repend node/:slots-index [canvas space/size map drawn]
	; ]
	; #debug cache [
		; name: any [select space-names space 'unknown]
		; #print "Saved cache for (name) size=(space/size) on canvas=(canvas): (mold/flat/only/part drawn 40)"
	; ]
; ]

; set-parent: function [
	; "Mark parent/child relationship in the parents cache"
	; child  [object!] "Space"
	; name   [word!]
	; parent [object! none!] "Space or host face"
; ][
	; ;; `none` may happen during init phase, e.g. autofit calls render to estimate row sizes
	; ;; in this case cache slot has still to be created
	; #assert [not child =? parent]
	; case [
		; parents: select/same render-cache child [
			; any [
				; not parent							;-- happens only when render is called without host
				; find/same/only parents parent		;-- do not duplicate parents
				; append append parents parent name	;@@ should name be updated if parent is found?
			; ]
		; ]
		; node: find render-cache 'free [
			; change node child
			; if parent [append append node/:parents-index parent name]
		; ]
		; 'else [
			; parents: make hash! 2
			; if parent [reduce/into [parent name] parents]
			; repend render-cache [child parents make hash! slot-size * 4]	;@@ doesn't seem to be any performance win from hash here
		; ]
	; ]
; ]

; visited-spaces: make block! 50						;-- used to track parent/child relations
; enter-space: function [
	; space [object!] name [word!]
; ][
	; set-parent space name last visited-spaces
	; append visited-spaces space
; ]
; leave-space: does [remove top visited-spaces]

; cache-size?: function [] [							;-- for cache creep detection
	; size: length? render-cache
	; for-each [inner [block! hash!]] render-cache [
		; size: size + length? inner
	; ]
	; size
; ]

; #if true = get/any 'disable-space-cache? [
	; clear body-of :invalidate
	; append clear body-of :get-cache none
	; clear body-of :commit-cache
	; clear body-of :set-parent
	; clear body-of :enter-space
	; clear body-of :leave-space
; ]

some old probe variant
; context [
	; containers: make typeset! [block! object! map! hash! paren! function!]
	; openings: reduce [block! "[" object! "object [" map! "#(" hash! "make hash! [" paren! "(" function! "function"]
	; closings: reduce [block! "]" object! "]"        map! ")"  hash! "]"            paren! ")" function! ""]

	; indent-text: function [text [string!] isize [integer!] /after] [
		; if isize <= 0 [return text]
		; text: copy text
		; indent: append/dup clear "" #" " isize
		; append append clear line: "" "^/" indent
		; unless after [insert text indent]
		; replace/all text #"^/" line
	; ]
	
	; set '?p function [depth [integer!] value [any-type!] /indent isize [integer!]] [
		; isize: any [isize 0]
		; either find containers type: type? :value [
			; either depth = 0 [
				; prin mold/flat/part :value 40
			; ][
				; either any [object? :value map? :value function? :value] [
					; either function? :value [
						; prin [select openings type  mold/flat spec-of :value  ""]
						; ?p/indent depth - 1 body-of :value isize
					; ][
						; print indent-text select openings type isize
						; foreach [k v] to [] :value [
							; prin [indent-text pad mold k 10 isize + 4 ""]
							; ?p/indent depth - 1 :v isize + 4
							; print ""
						; ]
						; print indent-text select closings type isize
					; ]
				; ][
					; prin select openings type
					; if nl?: new-line? value [prin ["^/" indent-text "" isize + 4]]
					; repeat i length? value [
						; ?p/indent depth - 1 :value/:i isize + 4
						; unless i = length? value [prin " "]
						; if new-line? skip value i [prin ["^/" indent-text "" isize + 4]]
					; ]
					; if nl? [prin ["^/" indent-text "" isize]]
					; prin select closings type
				; ]
			; ]
		; ][
			; prin indent-text/after mold/part :value 40 isize
		; ]
	; ]
; ]

find-deep I used to debug complex cache
; find-deep: none
; context [
	; path: make path! 10
	
	; find-deep*: function [list [any-block!] value [any-type!]] [
		; ;; find should be faster on hashes than parse
		; either pos: find/only/same list :value [
			; throw copy append path index? pos
		; ][
			; append path 1
			; forall list [								;@@ for-each can't be used with throw yet!
				; inner: list/1
				; ;@@ [hash! block!] value filter seems buggy in for-each! can't locate the bug!
				; unless any [hash? inner block? inner] [continue]	
				; change top path index? list
				; find-deep* inner :value
			; ]
			; remove top path
		; ]
		; none
	; ]
	
	; set 'find-deep function [list [any-block!] value [any-type!]] [
		; clear path
		; catch [find-deep* list :value]
	; ]
; ]
; dump-parents-list: function [list [hash! block!] cache [hash! block!]] [			;-- used for cache debugging only
	; #print "parents-list: (\size = ((length? list) / 2)) ["
	; foreach [space parents] list [
		; prin ["   " mold/part/flat space 40 "(" pad find-deep cache space 12 ")" "-> "]
		; foreach [node parent] parents [
			; prin [find-deep cache node find-deep cache parent "| "]
		; ]
		; print ""
	; ]
	; print "]"
; ]

kludges that won't be needed with objects in place of words
; fix-paths: function [
	; "Replaces convenient but invalid space-referring paths with valid ones"
	; code [block!] "Block where to replace paths"
	; /local path
; ][
	; parse r: copy/deep code [any [
		; change only set path any-path! (to path expand-space-path path)
	; |	skip
	; ]]
	; r
; ]
; ;; helper to work with words as objects in paths
; ;@@ can there be a -> operator for select+get+maplookup?
; expand-space-path: function [path [any-word! any-path!] /local coll] [
	; if word? path [path: to path! path]
	; set/any 'coll get/any path/1
	; out: head clear next copy path 
	; for-each [pos: item] as [] next path [				;@@ as [] = workaround for #4421
		; if any-function? :coll [append out pos  break]
		; space: if word? :item [
			; ;; substitute global word in the path with a word that refers to a space
			; any [
				; all [object? :coll  in coll 'map  found: find coll/map item  found/1]
				; all [object? :coll  host? coll  any [item = 'space  item = select coll 'space]  coll/space]
				; all [block?  :coll  found: find coll item  found/1]
			; ]
		; ]
		; set/any 'coll either space [
			; append clear out space
			; get/any space
		; ][
			; unless any [series? :coll  any-object? :coll  map? :coll] [
				; #print "Error getting path (path) after (out) which is (type?/word :coll)"
			; ]
			; append out :item
			; :coll/:item
		; ]
	; ]
	; if single? out [out: out/1]
	; case [
		; any [get-word? path get-path? path] [out: either word? out [to get-word! out][as get-path! out]]
		; any [set-word? path set-path? path] [out: either word? out [to set-word! out][as set-path! out]]
	; ]
	; out
; ]

another failed design remnant
; invalidate-face: function [
	; "Remove all spaces used by HOST face from cache"
	; host [object!]
; ][
	; foreach path list-spaces host/space [
		; invalidate/forget/only get last path
	; ]
; ]

paragraph that splits on line granularity - I might return to that if speed requires
; layouts/paragraph: context [
	; ;; unlike tube, this will require extra render and will split text spaces at right margin
	; ;; settings for paragraph layout:
	; ;;   align         [word! none!]   'left (default), 'center, 'right, 'fill
	; ;;   margin        [integer! pair!]   >= 0x0
	; ;;   spacing       [integer! pair!]   >= 0x0
	; ;;   canvas         [none! pair!]   if none=inf, width determined by widest item
	; ;;   limits        [none! object!]
	; create: function [
		; "Build a rich pagagraph out of given spaces and settings as bound words"
		; list [block! function!] "List of spaces & strings/urls, or a picker func [/size /pick i]"
		; settings [block!] "Any subset of [align margin spacing canvas limits]"
		; ;; settings - imported locally to speed up and simplify access to them:
		; /local align margin spacing canvas limits
	; ][
		; foreach word settings [							;-- free settings block so it can be reused by the caller
			; set bind word 'local get word				;@@ check that only allowed words are overwritten, not e.g. `count`
		; ]
		; axes: [e s]										;-- hardcoded
		; original-canvas: canvas
			
		; ;@@ how do I make 'fill alignment? or drop it and use -1/0/1 for it?
		; ;@@ perhaps, it should just assign weight= 1 to all text spaces? but stretching a text line requires kerning..
		; default align: 'left
		; align: select #(left -1x0 center 0x0 right 1x0) align
		
		; spaces: map-each item list [
			; switch/default type?/word item [
				; string! [make-space 'text [text: item]]
				; url!    [make-space 'link [text: item]]
				; object! [item]
			; ][assert [false]]							;@@ raise an error
		; ]
		; ;@@ if no strings - early exit
		
		; ;@@ ensure it doesn't fill the height, save a render
		; canvas: infxinf									;-- lay out a row first
		; settings: [axes align margin spacing canvas limits]
		; set [size: map:] make-layout 'tube spaces settings
		
		; ;@@ if size/x < canvas return early but align it
		
		; ;; now that each item's width is known, can split
		; ;@@ should cache created text spaces? text cannot be focused so maybe no reason to
		
		; mrg2: margin * 2x2
		; spc: spacing along 'x
		; set [canvas: fill:] decode-canvas original-canvas
		; left: total: canvas/x - mrg2/x				;@@ if infinite, shouldn't bother; check for positivity
		; assert [total < 1e5]
		; spaces: clear copy list
		; for-each [/i item] list [
			; set [space: geom:] skip map i - 1 * 2
			; width: geom/size/x
			; switch/default type?/word item [
				; string! [
					; cut: 0
					; while [left < width] [
						; limit: at head item offset-to-char space/layout cut + left by 0
						; if limit =? item [limit: next item]	;-- take at least 1 char
						; limit: any [				;-- wrap on word boundary if possible
							; find/last/tail/part item space! limit
							; limit
						; ]
						; cut:   first caret-to-offset/lower length? limit
						; width: geom/size/x - cut
						; part:  trim copy/part item item: limit
						; left:  total
						; append spaces make-space 'text [text: part]
					; ]
					; space: make-space 'text [text: copy item]
				; ]
				; url! [
					; space: make-space 'link [
						; text:  item
						; flags: [underline]				;-- don't wrap
						; command: compose [browse (copy item)]	;@@ make local openers
					; ]
				; ]
				; object! [space: item]
			; ] [assert [false]]							;@@ raise an error
			; left: left - width - spc
			; if left <= 0 [left: total]
			; append spaces space
		; ]
		
		; canvas: original-canvas
		; make-layout 'tube spaces settings
	; ]
; ]

experiment in high level paragraph
; layouts/paragraph: context [
	; ;; unlike tube, this will require extra render and will split text spaces at right margin
	; ;; settings for paragraph layout:
	; ;;   align         [word! none!]   'left (default), 'center, 'right, 'fill
	; ;;   margin        [integer! pair!]   >= 0x0
	; ;;   spacing       [integer! pair!]   >= 0x0
	; ;;   canvas         [none! pair!]   if none=inf, width determined by widest item
	; ;;   limits        [none! object!]
	; create: function [
		; "Build a rich pagagraph out of given spaces and settings as bound words"
		; list [block! function!] "List of spaces & strings/urls, or a picker func [/size /pick i]"
		; settings [block!] "Any subset of [align margin spacing canvas limits]"
		; ;; settings - imported locally to speed up and simplify access to them:
		; /local align margin spacing canvas limits
	; ][
		; func?: function? :list
		; count: either func? [list/size][length? list]
		; if count <= 0 [return copy/deep [0x0 []]]	;-- empty list optimization
		; foreach word settings [						;-- free settings block so it can be reused by the caller
			; set bind word 'local get word			;@@ check that only allowed words are overwritten, not e.g. `count`
		; ]
		; axes: [e s]									;-- hardcoded
		; default align: 'left
		; map: #(left -1x1 center 0x1 right 1x1 fill 0x1)		;-- vertically align along the line's bottom
		; align: select map para-align: align			;-- convert into alignment supported by tube
		; set [canvas: _:] decode-canvas canvas		;-- doesn't use the fill flag
		; canvas: constrain canvas limits
		; width: canvas/x - (margin along 'x * 2)		;-- max text width
		
		; ;; prototypes used for faster space creation - is 5x faster than new space creation (57 vs 10us)
		; ;@@ will this trick work? spaces are not designed for copy safety, but in their initial state it should be fine
		; text-proto:    make-space 'text []
		; #assert [text-proto/weight = 0]
		; link-proto:    make-space 'link [
			; quietly weight: 0
			; quietly flags: [underline]				;-- don't wrap inline links
		; ]
		; stretch-proto: make-space 'stretch [
			; quietly weight: either para-align = 'fill [1][0]
		; ]
		; #assert [not stretch-proto/cache]			;-- requirement to use shallow copy on it
		; linebreak-proto: make-space 'space [
			; quietly type: 'linebreak
			; quietly size: width by 0 
		; ]
		
		; ;; measure and set minimal space size
		; space: copy/deep text-proto
		; space/text: " "
		; render space
		; limit: caret-to-offset/lower space/layout 2	;-- size-text doesn't work without letters, using caret-to-offset
		; stretch-proto/limits: limit .. none			;-- nonzero height is needed for multiple empty lines case
		
		; init: [
			; quietly space/cached: clone link-proto/cached space/cached	;-- required because copy wrecks it
			; quietly space/color:  color
			; quietly space/flags:  copy flags
		; ] 
		; spaces: clear []							;-- use shared buffer until length is known
		; flags:  clear []
		; repeat i count [
			; item: either func? [list/pick i][list/:i]
			; switch/default type: type?/word :item [
				; string! [
					; parse item [collect after spaces any [
						; ;; every space group is significant as it determines separation from adjacent items
						; some space! keep (copy stretch-proto)	;-- don't copy /limits object
					; |	#"^M"						;@@ I ignore it but markdown spec doesn't
					; |	#"^/" keep (copy linebreak-proto)
						; opt [ahead #"^/" keep (copy stretch-proto)]	;-- separate multiple linebreaks by empty lines
					; |	copy word some non-white! keep (space: copy/deep text-proto) (
							; quietly space/text: word
							; do init
						; )
					; ]]
				; ]
				; url! [								;@@ wrap if too long
					; append spaces space: copy/deep link-proto
					; quietly space/text: item
					; do init
				; ]
				; refinement! [alter flags to word! item]
				; tuple!      [color: item]
				; none!       [color: none]
				; object!     [append spaces item]
			; ] [ERROR "Items of type (type) are not supported by the paragraph layout"]
		; ]
		
		; ;; add final stretch - so last line won't stretch in fill mode
		; if para-align = 'fill [
			; append spaces space: copy stretch-proto
			; quietly space/limits: none
			; quietly space/weight: 1e6
		; ]
		
		; spaces: copy spaces							;-- free shared buffer for reentrancy
		
		; ;@@ if no strings - early exit
		
		; settings: [axes align margin spacing canvas limits]
		; limits: canvas/x .. canvas/x
		; make-layout 'tube spaces settings
	; ]
; ]
	
first implementation of paragraph/flow layout, rather boring and buggy
; foreach [space drawn] info [				;@@ use for-each
	; index:  index + 1
	; breaks: pick breakpoints index
	; slice:  none
	
	; new-row-size: as-pair					;-- add item-size and check if it hangs over
		; row-size/x + space/size/x + spacing/x
		; max row-size/y space/size/y
		
	; ;; try to split the crossing space itself, maybe multiple times
	; while [
		; left: allowed-row-width - (row-offset/x + row-size/x + spacing/x)	;-- allowed to be negative, e.g. if canvas/x = 0!
		; all [
			; left < space/size/x						;-- doesn't fully fit (still)?
			; not empty? breaks						;-- any more breakpoints ahead?
			; any [left > 0  empty? row]				;-- either have free space or have to put at least 1 slice per row
		; ]
	; ][
		; ;; breaks may not be at head here if space spans more than 2 rows
		; #assert [breaks/1 >= 0]						;-- should never be at a negative integer here
		; if empty? row [breaks: next breaks]			;-- enforce at least one slice per row
		; while [not tail? breaks] [					;@@ locate would be a muuuch better fit
			; if breaks/1 > left [break]
			; breaks: next breaks
		; ]
		
		; ;; breaks are now before the breakpoint index that is too wide, or at tail
		; ;; but it can be at head too - no break possible then (and row is not empty)
		; if head? breaks [break]
		; either negative? breaks/-1 [				;-- ignorable interval (spacing)?
			; slice: breaks/-2
			; shift: breaks/-1
		; ][
			; slice: breaks/-1
			; shift: 0
		; ]
		
		; ;; count this space in the row; offset cannot be estimated until row is finished
		; repend row [space 0x0 drawn]				;-- space will appear on 2 or more rows
		; row-size: as-pair
			; row-size/x + spacing/x + slice
			; new-row-size/y							;-- slice affects both spanned rows height
		
		; ;; commit the accumulated row
		; append (new-row: obtain block! length? row) row
		; repend rows [row-offset 0x0 row-size new-row]	;-- row-size includes the clipped part
		; print ["partial commit:" row-offset row-size mold new-row]
		
		; ;; estimate the initial next row properties
		; row-offset: as-pair
			; shift - slice
			; row-offset/y + row-size/y + spacing/y
		; row-size: -1x0 * spacing
		; new-row-size: space/size
		; clear row
	; ]
	
	; ;; variants to consider now:
	; ;; - item fully fits (possibly a slicing leftover) -> no new row
	; ;; - item doesn't fit (possibly big slicing leftover) but it's not the 1st on the row -> new row
	; ;; - item doesn't fit (possibly big slicing leftover) but it is the 1st -> no new row
	
	; either all [
		; not empty? row
		; left < space/size/x
	; ][												;-- start a new row
		; ;; commit the accumulated row
		; append (new-row: obtain block! length? row) row
		; repend rows [row-offset 0x0 new-row-size new-row]	;-- row-size includes the clipped part
		; print ["full commit:" row-offset new-row-size mold new-row]
		
		; clear row
		; repend row [space 0x0 drawn]
		; row-offset: row-offset + new-row-size + spacing * 0x1
		; row-size:   space/size
		
		; ;; special case for opening break (space) - shift the row
		; ;; e.g. text starting with a space comes after a non-text item and starts a new row
		; if all [breaks  0 = breaks/1  shift: breaks/2  negative? shift] [
			; row-offset/x: row-offset/x + shift
		; ]
	; ][												;-- don't start a new row
		; repend row [space 0x0 drawn]
		; row-size:   new-row-size					;-- just accept new width
	; ]
	
	; total-width: max total-width row-offset/x + row-size/x	;-- clipped part excluded from total width
; ]
; repend rows [row-offset 0x0 row-size row]
; print ["final commit:" row-offset row-size mold row]
; nrows: (length? rows) / 3
; total-length: row-offset/y + row-size/y
; #leaving [foreach [_ _ _ row] rows [stash row]  stash rows]

; ;; adjust row alignment
; if factor: select #(right 1 center 0.5) align [
	; forall rows [							;@@ use for-each
		; set [row-offset: _: row-size: _:] rows
		; ?? [row-offset row-size total-width]
		; free: max 0 total-width - (row-size/x + row-offset/x)
		; rows/2: free * factor * 1x0
		; rows/1: rows/1 + rows/2
		; ?? [free rows/2]
		; rows: skip rows 3
	; ]
; ]

; ;; build the map & measure the final layout size
; ;; map cannot have doubled (wrapped) items, because focus should be set on the whole item
; ;; so coordinates must be unrolled, but for simplicity I'll make a map without coordinates
; map: clear []
; foreach [_ _ row-size row] rows [
	; pos: 0x0
	; forall row [							;@@ use for-each
		; space: row/1
		; row/2: pos + (row-size - space/size * 0x1)	;-- remember offset within the row (used by /draw and /into)
		; unless space =? pick tail map -2 [	;-- do not duplicate
			; repend map [space none]			;-- list-spaces rely on maps having 2 columns ;@@ for-each could fix that
		; ]
		; pos: pos + (space/size + spacing * 1x0)
		; row: skip row 2
	; ]
; ]
; size: 2 * margin + (total-width by total-length)
; #debug sizing [print ["paragraph c=" canvas "cc=" ccanvas "stripe=" stripe ">> size=" size]]
; #assert [size +< infxinf]

; ;; container/draw cannot be used with this layout due to it's tricky coordinate shifts
; ;; so return format is different too ;@@ any way to unify return format with the others?
; reduce [size copy map copy/deep rows]

another unfinished flow attempt, not better
; length: 0									;-- height of all committed (previous) rows = offset - spacing of current row
; width:  0									;-- width used by current row so far
; nitems: 0									;-- number of spaces fully committed so far
; next-spacing: 0
; while [nitems < count] [
	; set [space: drawn:] skip info nitems * 2
	; unless breaks [
		; breaks: any [pick breakpoints nitems + 1  []]
		; breakable?: 2 < length? breaks
	; ]
	; left: allowed-row-width - width
	; if empty? row [next-spacing: 0]
	; offset: width + next-spacing			;-- vertical offset will be determined later once row sizes are known
	
	; ;; add full space
	; if all [
		; head? breaks						;-- only when at beginning of the space
		; any [
			; offset + space/size/x <= allowed-row-width
			; all [not breakable?  empty? row]
		; ]
	; ][
		; repend row [space offset drawn]
		; nitems: nitems + 1
		; width:  offset + space/size/x
		; next-spacing: spacing/x
		; continue
	; ]
	
	; ;; add part of the space
	; if breakable? [
		; #assert [0 = first head breaks]				;-- required for algorithm's simplicity
		; #assert [space/size/x = last breaks]		;-- also
		; set [offset1: offset2:] breaks
		; if offset2 < hide: 0 [
			; set [hide: offset2:] next breaks
		; ]
		; empty-part?: hide < 0
		; part: offset2 - offset1
		; if any [									;-- only if part fits or enforced by empty row
			; offset + part <= allowed-row-width		;-- fits fully?
			; empty? row								;-- 
			; empty-part?
		; ][
			; if any [head? breaks  empty? row] [		;-- don't list the same space twice
				; if empty? row [offset: offset + hide]
				; repend row [space offset drawn]
			; ]
			; breaks: skip breaks either hide = 0 [1][2]
			; either single? breaks [
				; breaks: none
				; nitems: nitems + 1
				; next-spacing: spacing/x
			; ][
				; next-spacing: 0
			; ]
			; continue
		; ]
	; ]
	
; ]

scaling decision that will downscale rows that are too big
not sure it's a good thing though, since if line is huge in a paragraph it will become unreadable
the opposite - upscaling smaller rows to total-width - will also be as bad
instead, no downscaling should be allowed, and upscaling only to the canvas
or else, rows should be split by the maximum space width rather than by canvas/x (but I don't prefer that)
; if align = 'fill [						;-- set the scale
	; closing?: any [
		; 'break = select (pick tail row -3) 'type	;-- avoid scaling rows ending with a break (currently stands alone)
		; tail? skip rows 5							;-- avoid scaling last row
	; ]
	; width: row-clip-end - row-clip-start
	; if any [
		; not closing?
		; width > allowed-row-width		;-- allow downscaling closing rows if they're too big
	; ][
		; ;; using allowed-row-width it can be both zooming in and out (<1 or >1)
		; rows/2: allowed-row-width / (max 1 width)
	; ]
; ]

line scaling variant that doesn't limit the scale, but disables scaling before line breaks and paragraph end
I realized if I limit the scale, I don't need to bother with breaks at all
; forall rows [								;@@ use for-each or map-each
	; set [row-offset: _: row-clip-start: row-clip-end: row:] rows
	; left:  total-width - (row-clip-end/x - row-clip-start/x)	;-- can be negative and it's fine
	; shift: left * select #(left 0 fill 0 right 1 center 0.5) align
	; if align = 'fill [						;-- set the scale
		; either all [
			; not empty? row
			; row/1/type = 'break
		; ][
			; if last-row [last-row/2: 1.0]	;-- reset scaling for lines before linebreak
		; ][
			; width: first row-clip-end - row-clip-start
			; if width < allowed-row-width [	;-- only upscale smaller rows, never downscale
				; ;@@ maybe also require a width limit, e.g. not less than 90% of the canvas?
				; ;@@ and then downscale < 110% ?
				; ;; scale around allowed-row-width, not total-width
				; ;; allowing big rows to stick out, still aligning the rest:
				; probe rows/2: allowed-row-width / (max 1 width)
			; ]
		; ]
	; ]
	; rows/1: row-offset + (shift by 0)
	; pos: 0x0
	; forall row [							;@@ use for-each or map-each
		; space: row/1
		; row/2: row/2 by (row-clip-end/y - space/size/y)	;-- remember offset within the row (used by /draw and /into)
		; unless space =? pick tail map -2 [	;-- do not duplicate items in the map
			; repend map [space none]			;-- list-spaces rely on maps having 2 columns ;@@ for-each could fix that
		; ]
		; row: skip row 2
	; ]
	; last-row: rows
	; rows: skip rows 4
; ]
; if last-row [last-row/2: 1.0]				;-- reset scaling for last line
; size: 2 * margin + (total-width by total-length)

first, futile attempt at abstracting row format
; abstract-item: function [
	; "Get visual box of a child in space's coordinates (may stick out of margin FUCK"
	; prow [block!] "Location in row data" pitem [block!] "Location in the row"
; ][
	; all [
		; set [row-offset: row-scale: clip-start: clip-end: row:] prow
		; set [child: child-offset:] pitem
		; compose [
			; item:   (child)
			; offset: (space/margin + xscale child-offset + row-offset row-scale)
			; size:   (xscale child/size row-scale)
		; ]
	; ]												;-- may return none on empty slot
; ]

; abstract-item: function [pos [block!] "Location in the row"] [
	; all [
		; set [child: child-offset:] pos
		; compose [
			; item:   (child)
			; offset: (space/margin + xscale child-offset + row-offset row-scale)
			; size:   (xscale child/size row-scale)
		; ]
	; ]												;-- may return none on empty slot
; ]

; abstract-row: function [
	; "Get visual box of a whole row in space's coordinates"
	; space [object!] pos [block!] "Location in rows block"
; ][
	; if set [row-offset: row-scale: clip-start: clip-end: row:] pos [
		; compose/only [
			; length: ((length? row) / 3)
			; offset: (row-offset + clip-start + space/margin)	;-- returns visible (clipped & scaled) box only
			; size:   (as-pair  clip-end/x - clip-start/x * row-scale  clip-end/y - clip-start/y)
			; scale:  (row-scale)
			; items:  (row)
		; ]
	; ]												;-- may return none on empty slot
; ]

; abstract-row: function [space [object!] pos [block!] "Location in rows block"] [
	; all [
		; set [row-offset: row-scale: clip-start: clip-end: row:] pos
		; compose/only [
			; length:     ((length? row) / 3)
			; offset:     (row-offset)
			; clip-start: (clip-start)
			; clip-end:   (clip-end)
			; scale:      (row-scale)
			; items:      (row)
		; ]
	; ]												;-- may return none on empty slot
; ]

; get-row-item: function [space [object!] rowxcol [pair!]] [
	; if 0 < r: rowxcol/1 [
		; rows: skip space/rows r - 1 * 5
		; if row: rows/5 [
			; pos: skip row rowxcol/2 - 1 * 3
			; abstract-item abstract-row rows pos
		; ]
	; ]
; ]
; get-row: function [space [object!] row [integer!]] [
	; if row > 0 [abstract-row skip space/rows rowxcol/1 - 1 * 5]
; ]
; row-count?: function [space [object!]] [
	; (length? space/rows) / 5
; ]
; next-item: function [
	; "Find existing next/previous item's RC or returns none"
	; space [object!] rowxcol [pair!] side [word!] (find [left right] side)
; ][
	; either side = 'left [
		; rowxcol: rowxcol - 0x1
		; while [rowxcol/2 <= 0] [
			; row: get-row space rowxcol/1: rowxcol/1 - 1
			; unless row [return none]
			; rowxcol/2: row/length
		; ]
	; ][
		; rowxcol: rowxcol + 0x1
		; while [
			; row: get-row space rowxcol/1
			; unless row [return none]
			; rowxcol/2 > row/length
		; ][
			; rowxcol: rowxcol/1 + 1 by 1
		; ]
	; ]
; ]
; next-item: function [
	; "Find existing next/previous item's RC or returns none"
	; space [object!] prow [block!] pcol [block!] side [word!] (find [left right] side)
; ][
	; either side = 'left [
		; while [head? pcol] [
			; if head? prow [return none]
			; prow: skip prow -5
			; pcol: prow/5
		; ]
	; ][
		; pcol: skip pcol 3
		; while [tail? pcol] [
			; prow: skip prow 5
			; unless pcol: prow/5 [return none]
		; ]
	; ]
	; reduce [prow pcol]
; ]

; rc-to-caret: function [space [object!] rowxcol [pair!] side [word!] "left/right/both"] [

; ]

; caret-to-box: function [space [object!] caret [integer!] side [word!] "left/right"] [
; ]

; xy-to-rc: function [space [object!] xy [pair!]] [	;-- never fails, 1x1 if no rows
	; xy: xy - space/margin
	; rows: tail space/rows
	; while [not head? rows] [
		; rows: skip rows -5
		; set [row-offset: row-scale: clip-start: clip-end: row:] pos
		; row: tail row
		; row-xy: xscale xy - row-offset
		; while [not head? row] [
			; set [child: child-offset:] row: skip row -3
			; child-xy: row-xy - child-offset
			; if child-offset
		; ]
	; ]
	
	; if set [rows: row-xy: row: child-xy:] rich-paragraph-ctx/locate-child space xy [
		; child:  row/1
		; #assert [find/same space/ranges/spaces child]
		; crange: pick find/same space/ranges/spaces child -1
		; either crange/1 + 1 = crange/2 [
			; index: crange/2
			; caret: pick crange child-xy/x < (child/size/x / 2)
		; ][
			; index: crange/1 + offset-to-char  child/layout child-xy
			; caret: crange/1 + offset-to-caret child/layout child-xy
		; ]
		; reduce [child child-xy index caret]			;@@ what to return?
	; ]
; ]



; locate-point: function [space [object!] xy [pair!]] [
	; if set [rows: row-xy: row: child-xy:] rich-paragraph-ctx/locate-child space xy [
		; child:  row/1
		; #assert [find/same space/ranges/spaces child]
		; crange: pick find/same space/ranges/spaces child -1
		; either crange/1 + 1 = crange/2 [
			; index: crange/2
			; caret: pick crange child-xy/x < (child/size/x / 2)
		; ][
			; index: crange/1 + offset-to-char  child/layout child-xy
			; caret: crange/1 + offset-to-caret child/layout child-xy
		; ]
		; reduce [child child-xy index caret]			;@@ what to return?
	; ]
; ]

; ;; returns thin 2D box for specified caret offset either on the left or right side (same result unless it spans rows)
; get-caret-box: function [
	; space [object!]
	; caret [integer!] (caret >= 0)
	; side  [word!] (find [left right both] side)
; ][
	; rows: space/frame/rows
	; foreach [child range] space/ranges/spaces [
		; if all [range/1 <= caret caret <= range/2] [
			; set [row-offset row-scale clip-start clip-end row] rows [
		; ]
	; ]
; ]

event handlers for selection over rich-content
I decided it has to be done by the container of rich-content instead
; rich-content: [
	; on-down [space path event] [
		; unless space/selectable? [exit]
		; space/selected: none
		; start-drag/with path space/point-to-caret path/2
	; ]
	; on-over [space path event] [
		; unless dragging? [exit]
		; caret1: drag-parameter
		; caret2: space/point-to-caret path/2
		; space/selected: caret1 by caret2
	; ]
	; on-up [space path event] [
		; if space/selectable? [stop-drag]
	; ]
; ]

I wanted to make /editable facet for text spaces... reconsidered, limited to /measure
; remove: function [offset [integer!] length [integer!]] with :edit [
	; rng:  ranges/decode space/flags
	; rng1: ranges/extract rng 0 by offset
	; rng2: ranges/extract rng offset by (offset + length)
	; rng:  ranges/join rng1 offset rng2
	; system/words/remove/part skip space/text offset length
	; space/flags: ranges/encode rng				;-- invalidates
; ]
; copy:   function [offset [integer!] length [integer!]] with :edit [
	; -> data
; ]
; insert: function [offset [integer!] side [word!] data [block!]] with :edit [
; ]

first attempt at range arithmetic, don't wanna even see it
; non-pair!: complement make typeset! [pair!]
; ranges: context [
	; ;@@ some of these funcs are general, some only apply to text space
	; decoded-length?: function [map [map!]] [
		; len: 0
		; foreach [attr list] map [					;@@ use map-each
			; len: max len maximum-of keys-of list
		; ]
		; len
	; ]
	; union: function [ranges1 [block!] ranges2 [block!]] [
		; map1: decode ranges1
		; map2: decode ranges2
		; len:  max decoded-length? map1 decoded-length? map2
		; foreach [attr list2] map2 [
			; map1/:attr: either map1/:attr [
				; extend map1/:attr map2/:attr
			; ][
				; copy map2/:attr
			; ]
		; ]
		; encode map1 len
	; ]
	; shift: function [ranges [block!] offset [integer!] /local pair] [
		; if offset <> 0 [
			; parse ranges [any [						;@@ use map-each
				; change set pair pair! (offset by 0 + pair)
			; |	skip
			; ]]
		; ]
		; ranges
	; ]
	; ;@@ should interval/2 clip the result here? extra work, but may save some other work later
	; extract: function [ranges [block!] interval [pair!] /local pair] [
		; ranges: shift copy ranges negate interval/1
		; parse ranges [any [							;@@ use map-each
			; ahead set pair pair! [
				; if (pair/1 + pair/2 > 2)			;-- keep the range
				; [
					; if (pair/1 < 1)					;-- normalize pair to start from 1 if it's <= 0
					; change skip (1 by (pair/1 + pair/2 - 1))
				; |	skip
				; ]
				; any non-pair!
			; |	remove [skip any non-pair!]  
			; ]
		; |	skip
		; ]]
		; ranges
	; ]
	; join: function [ranges1 [block!] offset [integer!] ranges2 [block!]] [
		; union ranges1 shift copy ranges2 offset
	; ]
	; decode: function [ranges [block!] /local pair flag value] [
	; ;@@ need to support simple (pair-less) flags here too
		; attrs: make map! 10
		; parse ranges [any [
			; ;@@ should pair be clipped to length here or allow expanding unapplied attributes?
			; set pair pair! any [
				; [
					; set flag [
						; ['bold | 'italic] (value: true)
					; |	['underline | 'strike] [set value tuple! | (value: true)]
					; |	'backdrop set value tuple!
					; ]
				; |	set value [
						; tuple!   (flag: 'color)
					; |	integer! (flag: 'size)
					; |	string!  (flag: 'font)
					; ]
				; ]
				; (
					; list: any [attrs/:flag  attrs/:flag: make map! 10]
					; repeat i pair/2 [put list (i + pair/1 - 1) value]
				; )
			; ]
		; ]]
		; attrs
	; ]
	; encode: function [attrs [map!] length [integer!]] [
		; ;; instead of grouping all the attrs together I just list them one by one since it's much simpler:
		; flags: clear []
		; foreach [attr list] attrs [
			; add-value: switch attr: to word! attr [
				; bold italic               [[append flags attr]]
				; color size font           [[append flags old]]
				; underline strike backdrop [[append append flags attr only old]]
			; ];; rest is ignored as it's not supported
			; start: old: none
			; repeat i length [
				; case [
					; old = list/:i [continue]
					; old [
						; append flags start by (i - start)
						; do add-value
						; old: start: none
					; ]
					; 'started [old: select list start: i]
				; ]
			; ]
			; if old [
				; append flags start by (length + 1 - start)
				; do add-value
			; ]
		; ] 
		; copy flags
	; ]
	; ;@@ shouldn't be part of ranges? also not sure about arg list
	; ;@@ this should work not only on text but on arbitrary items
	; refine: function [text [string!] attrs [map!]] [
		; ;; instead of grouping all the attrs together I just list them one by one since it's much simpler:
		; source: clear []
		; buf: clear ""
		; old: clear #()
		; len: length? text
		; openings: make map! [
			; bold      [[ bold ]]
			; italic    [[ italic ]]
			; color     [[ color: (value) ]]
			; size      [[ size: (value) ]]
			; font      [[ font: (value) ]]
			; backdrop  [[ backdrop: (value) ]]
			; underline [either value [[ underline: (value) ]][[ underline ]]]
			; strike    [either value [[ strike: (value) ]][[ strike ]]]
			; ;@@ more?
		; ]
		; closures: make map! [
			; bold      [[ /bold      ]]
			; italic    [[ /italic    ]]
			; color     [[ /color     ]]
			; size      [[ /size      ]]
			; font      [[ /font      ]]
			; backdrop  [[ /backdrop  ]]
			; underline [[ /underline ]]
			; strike    [[ /strike    ]]
		; ]
		; repeat i len [
			; foreach [attr list] attrs [
				; attr: to word! attr
				; case [
					; old/:attr = list/:i [continue]
					; old/:attr [
						; value: old/:attr
						; unless empty? buf [append source copy buf  clear buf]
						; append source compose do closures/:attr
						; old/:attr: none
					; ]
					; 'opening  [
						; value: list/:i
						; unless empty? buf [append source copy buf  clear buf]
						; append source compose do openings/:attr
						; old/:attr: list/:i
					; ]
				; ]
			; ]
			; append buf text/:i
		; ]
		; unless empty? buf [append source copy buf  clear buf]
		; foreach [attr list] attrs [
			; if old/:attr [
				; value: old/:attr
				; append source compose do closures/:attr
				; unless empty? buf [append source copy buf  clear buf]
			; ]
		; ]
		; copy source
	; ]
; ]

pair list version of masks - requires too much code to support it
; context [	;@@ how to name it?
	; ~: self												;-- allows to combine 'ranges' context with 'ranges' word
	
	; ranges: context [
		; to-rtd-pair:
		; from-rtd-pair:
		; normalize:
		; shift:
		; union:
		; clip:
		; exclude:
		; remove:
			; none
	; ]
	
	; ranges/to-rtd-pair: function [
		; "Convert source range into RTD range"
		; range [pair!]
	; ][
		; range/1 + 1 by (range/2 - range/1)
	; ]

	; ranges/from-rtd-pair: function [
		; "Convert RTD range into source range"
		; range [pair!]
	; ][
		; range/1 - 1 by (range/2 + range/1 - 1)
	; ]
	
	; #assert [2x5 = ranges/from-rtd-pair ranges/to-rtd-pair 2x5]
	
	; ranges/normalize: function [
		; "Bring a list of ranges into it's canonical minimal representation (modifies)"
		; list [block!]
	; ][
		; list: sort list
		; while [2 <= length? list] [						;@@ use for-each
			; set [a: b:] list
			; either a/2 >= b/1 [
				; remove change list a/1 by max a/2 b/2
			; ][
				; list: next list
			; ]
		; ]
		; head list
	; ]
	
	; ranges/shift: function [
		; "Return a copy of LIST moved by a given OFFSET"
		; list [block!] offset [integer!]
	; ][
		; list: copy list
		; forall list [list/1: list/1 + offset]			;@@ use map-each
		; list
	; ]
	
	; ranges/union: function [
		; "Unify and normalize two lists of ranges"
		; list1 [block!] list2 [block! pair!]
	; ][
		; ranges/normalize compose [(list1) (list2)]
	; ]
	
	; ranges/clip: function [
		; "Return sublist of ranges local to a specific range"
		; list [block!] range [pair!]
	; ][
		; result: clear []
		; forall list [									;@@ use map-each
			; pair: clip list/1 range/1 range/2
			; if pair/1 < pair/2 [append result pair]
		; ]
		; copy result
	; ]
	
	; ranges/exclude: function [
		; "Return copy of LIST with RANGE absent from it"
		; list [block!] range [pair!]
	; ][
		; ranges/union
			; ranges/clip list 0 by range/1
			; ranges/clip list range/2 by infxinf/x
	; ]
	
	; ranges/remove: function [
		; "Return copy of LIST with RANGE removed from it (excludes and shifts)"
		; list [block!] range [pair!]
	; ][
		; ranges/union
			; ranges/clip list 0 by range/1
			; ranges/shift
				; ranges/clip list range/2 by infxinf/x
				; range/1 - range/2
	; ]
	
	; split: function [
		; "Split ranges at given offset"
		; list [block!] offset [integer!]
	; ][
		; reduce [
			; clip list 0 by offset
			; shift
				; clip list offset by infxinf/x
				; negate offset
		; ]
	; ]
	
	; values: context [
		; normalize:
			; none
	; ]
	
	; values/normalize: function [
		; "Returns a copy of values list without intersections"
		; vlist [block!] "Latter values take priority"
	; ][
		; vlist: skip tail vlist -2
		; coverage: vlist/2								;-- maintaining coverage allows it to be O(number of values)
		; while [not head? vlist] [						;@@ use for-each/reverse
			; vlist: skip vlist -2
			; vlist/2: ranges/exclude vlist/2 coverage
			; unless head? vlist [coverage: ranges/union coverage vlist/2]
		; ]
	; ]
	
	; values/
	

; attributes: context [
	; {
		; attrs format: #(
			; name [
				; value1 [range range ...]				;-- ranges sorted (by start then end)
				; value2 [range range ...]				;-- value is 'true' for words, anything else for set-words
				; ...
			; ]
			; ...
		; )
	; }
	; to-rtd-flag: function [attr [word!] value [tuple! logic! string! integer!]] [
		; switch attr [
			; bold italic underline strike [attr]
			; color size font [value]
			; backdrop [compose [backdrop (value)]]
		; ]
	; ]
	
	; rtd-attrs: make hash! [bold italic underline strike color backdrop size font]
	; make-rtd-flags: function [
		; "Make an RTD flags block out of given attributes"
		; attrs [map!] range [pair!]
	; ][
		; flags: clear []
		; foreach [attr value-list] attrs [
			; unless find rtd-attrs attr [continue]
			; foreach [value range-list] value-list [
				; ;; z-order: in RTD later styles take priority, and my range list is sorted by starting offset
				; foreach range range-list [				;@@ use map-each
					; pair: ranges/to-rtd-pair range
					; flag: to-rtd-flag attr value
					; append append flags pair flag
				; ]
			; ]
		; ]
		; copy flags
	; ]
	
	; get-length: function [item] [
		; case [
			; object? :item [
				; measure: select item 'measure
				; either :measure [measure [length]][1]
			; ]
			; series? :item [
				; length? item
			; ]
			; 'else [1]
		; ]
	; ]
	
	; get-ranges: function [attrs [map!] attr [word!] value] [
		; values: any [attrs/:attr attrs/:attr: make [] 2]
		; unless ranges: select/same/skip values :value 2 [
			; repend values [:value ranges: make [] 4]
		; ]
		; ranges
	; ]
	
	; split-at: function [source [block!] offset [integer!] side [word!] /local s] [
		; pos: 0
		; =skip-attrs=: when side = 'right [refinement! | word! | set-word! skip]
		; parse source [any [
			; =skip-attrs=
		; |	if (pos >= offset) p: (return p)			;-- no split required
		; |	char! object! (pos: pos + 1)
		; |	p: set s string! [
				; if ((left: offset - pos) < len: length? s) 	;-- must split the string
				; :p change skip (reduce [copy/part s left  copy skip s left])	;@@ use 'split' func for this when available
				; (return next p)
			; |	(pos: pos + len)
			; ]
		; |	skip
		; ]]
		; tail source										;-- offset is past-tail
	; ]
	
	; inject-token: function [source [block!] offset [integer!] side [word!] token] [
		; insert/only split-at source offset side :token
	; ]
	
	; inject: function [
		; "Inject attribute into a source block (modified)"
		; source [block!] attr [word!] value range [pair!]
	; ][
		; opening: either true = :value [attr][reduce [to set-word! attr :value]]
		; closing: to refinement! attr
		; inject-token source range/1 opening 'right
		; inject-token source range/2 closing 'left
		; source
	; ]
	
	; copy-range: function [
		; "Copy selected range of items (some items may span multiple offsets)"
		; items [block!] attrs [map!] range [pair!]
	; ][
		; items: copy items
		; s: split-at items range/1
		; e: split-at items range/2
		; items: copy/part s e
		; attrs: map-each/eval/drop [attr value-list] attrs [
			; value-list: map-each/eval/drop [value range-list] value-list [
				; range-list: ranges/shift ranges/clip range-list range negate range/1
				; either empty? range-list [continue][[:value range-list]]
			; ]
			; either empty? value-list [continue][[attr value-list]]
		; ]
		; reduce [items attrs]
	; ]
	
	; remove-range: function [
		; "Copy selected range of items (some items may span multiple offsets)"
		; items [block!] attrs [map!] range [pair!]
	; ][
		; items: copy items
		; s: split-at items range/1
		; e: split-at items range/2
		; remove/part s e
		; attrs: map-each/eval/drop [attr value-list] attrs [
			; value-list: map-each/eval/drop [value range-list] value-list [
				; range-list: ranges/remove-range range-list range
				; either empty? range-list [continue][[:value range-list]]
			; ]
			; either empty? value-list [continue][[attr value-list]]
		; ]
		; reduce [items attrs]
	; ]
	
; ]

; ;; externalization avoids name collision for common names like insert, copy, etc

; attributes/shift: function [
	; "Shift all ranges in ATTRS by SHIFT value (modifies)"
	; attrs [map!] shift [integer!]
; ][
	; foreach [attr value-list] attrs [
		; foreach [value range-list] value-list [
			; ranges/shift range-list range
		; ]
	; ]
	; attrs
; ]

; attributes/insert: function [
	; "Insert OTHER attributes into ATTRS at given OFFSET"
	; attrs [map!] offset [integer!] other [map!] length [integer!] "Length of OTHER segment"
; ][
	; left:  attributes/clip attrs 0 by offset
	; right: attributes/clip attrs offset by infxinf/x
	; attributes/shift right length
	; attributes/shift other offset
	; attributes/union attributes/union left other right
; ]

; attributes/clip: function [
	; "Return submap of attributes local to a specific range"
	; attrs [map!] range [pair!]
; ][
; ]

; attributes/union: function [
	; "Unify two attribute maps"
	; attrs [map!] other [map!]
; ][
	; names: union keys-of attrs keys-of other
	; result: make map! length? names
	; foreach name names [
	; ;@@ THIS FORMAT IS SO COMPLEX FFS MAYBE JUST USE PLAIN BLOCK/HASH?
		; value-list: clear []
		; result/:name:
	; ]
; ]

; source: context [
	; ;@@ need to make modularity somehow, later
	; datatypes: make map! reduce [
		; string! object [
			
		; ]
	; ]
	
	; deserialize: function [
		; "Split source into [items attributes]"
		; source [block!]
		; /local attr value item
	; ][
		; items:   clear copy source						;@@ should items be just chars and objects? other types support, e.g. image?
		; attrs:   make #() 10
		; pending: make #() 10
		; offset:  0
		; parse source [any [
			; set attr [word! (value: on) | set-word! set value skip] (
				; attr:  to word! attr
				; stack: any [pending/:attr  pending/:attr: make [] 8]
				; repend stack [offset :value]
			; )
		; |	set attr refinement! (						;-- attributes work stack-like and do not close automatically
				; attr:  to word! attr
				; unless empty? stack: pending/:attr [	;-- extra closings are silently ignored
					; value: take/last stack
					; start: take/last stack
					; range-list: get-ranges attrs attr :value
					; repend range-list start by offset
				; ]
			; )
		; |	set item string! (							;@@ make it a module
				; parse item [collect after items keep pick to end]
				; offset: offset + length? item
			; )
		; |	set item skip (
				; append/only items item
				; offset: offset + 1
			; ]
		; ]]
		; foreach [attr stack] pending [					;-- auto-close unclosed ranges
			; attr: to word! attr
			; foreach [start value] stack [
				; range-list: get-ranges attrs attr :value
				; repend range-list start by offset
			; ]
		; ]
		; foreach [attr value-list] attrs [				;-- normalize obtained ranges (else may be unsorted since I add in closing order)
			; foreach [value range-list] value-list [
				; ranges/normalize range-list
			; ]
		; ]
		; reduce [items attrs]
	; ]
	
	; serialize: function [
		; "Create a source block out of items and attributes"
		; items [block!] attrs [map!]
	; ][
		; queue: clear []
		; foreach [attr value-list] attrs [
			; foreach [value range-list] value-list [
				; opening: either true = :value [attr][[to set-word! attr :value]]
				; closing: to refinement! attr
				; foreach range range-list [
					; repend queue [range/1 opening range/2 closing]
				; ]
			; ]
		; ]
		; sort/skip queue 2
		; result: clear []
		; foreach [offset marker] queue [
			; append/part result items part: offset - skip? items
			; items: skip items part
			; append result marker
		; ]
		; parse result [any [
			; change copy part [char! some char!] (to string! part)
		; |	skip
		; ]]
		; copy result
	; ]
	
; ]

bitset version of masks - more problematic than binary, slower due to allocations in bitset<->binary conversion
; context [	;@@ how to name it?
	; ~: self												;-- allows to combine 'ranges' context with 'ranges' word
	
	; ranges: context [
		; to-rtd-pair: function [
			; "Convert source range into RTD range"
			; range [pair!]
		; ][
			; range/1 + 1 by (range/2 - range/1)
		; ]
	
		; from-rtd-pair: function [
			; "Convert RTD range into source range"
			; range [pair!]
		; ][
			; range/1 - 1 by (range/2 + range/1 - 1)
		; ]
		
		; #assert [2x5 = from-rtd-pair to-rtd-pair 2x5]
	; ]
		
		
		
	; masks: context [
		; from-range:
		; to-ranges:
		; normalize:
		; empty?:
		; shift:
		; clip:
		; exclude:
		; remove:
			; none
	; ]
	
	; masks/from-range: function [range [pair!]] [
		; if range/2 < range/1 [range: reverse range]
		; charset when range/2 <> range/1 (
			; reduce [range/1 '- range/2 - 1]
		; )
	; ]
	
	; zero!:          charset [0]
	; nonzero!:       complement zero!
	; nonzero-digit!: complement charset "0"
	
	; masks/to-ranges: function [mask [bitset!]] [
		; mask: to binary! mask
		; parse mask [any zero! mask:]					;-- optimization: skip leading zeroes
		; ranges: clear []
			; unless empty? mask [
			; base: 8 * skip? mask
			; mask: enbase/base mask 2
			; parse mask [any [
				; any #"0" opt [s: some #"1" e: (
					; append ranges base + as-pair skip? s skip? e
				; )]
			; ]]
		; ]
		; copy ranges
	; ]
	
	; masks/normalize: function [mask [bitset!]] [
		; make bitset! trim/tail to binary! mask			;@@ workaround for bitset weirdness - auto trim the tail
	; ]
	
	; masks/empty?: function [mask [bitset!]] [			;@@ workaround for bitset weirdness
		; mask = make bitset! length? mask
	; ]
	
	; masks/shift: function [mask [bitset!] offset [integer!]] [
		; if zero? offset [return copy mask]
		; #assert [not complement? mask]
		; mask: enbase/base to binary! mask 2
		; either offset < 0 [
			; remove/part mask negate offset
		; ][
			; insert/dup mask #"0" offset
		; ]
		; clear find/last/tail mask nonzero-digit!		;@@ workaround for bitset weirdness
		; to bitset! debase/base mask 2
	; ]
	
	; masks/clip: function [mask [bitset!] range [pair!]] [
		; masks/normalize mask and masks/from-range range
	; ]
	
	; masks/exclude: function [mask [bitset!] range [pair!]] [
		; masks/normalize exclude mask masks/from-range range		;-- exclude 1.5x faster than `or complement`
	; ]
	
	; masks/remove: function [mask [bitset!] range [pair!]] [
		; if zero? span? range [return copy mask]
		; #assert [not complement? mask]
		; mask: enbase/base to binary! mask 2
		; clear find/last/tail mask nonzero-digit!		;@@ workaround for bitset weirdness
		; remove/part skip mask range/1 range/2 - range/1 
		; to bitset! debase/base mask 2
	; ]
	
	
	
	; values: context [
		; normalize:
			; none
	; ]
	
	; empty-set: make bitset! #{}
	; #assert [empty? empty-set]
	
	; values/normalize: function [
		; "Returns a copy of values list without intersections and empty ranges"
		; vlist [block!] "Latter values take priority"
	; ][
		; vlist: skip tail copy vlist -2
		; coverage: vlist/2								;-- maintaining coverage allows it to be O(number of values)
		; while [not head? vlist] [						;@@ use for-each/reverse
			; vlist: skip vlist -2
			; vlist/2: masks/exclude vlist/2 coverage
			; unless head? vlist [coverage: coverage or vlist/2]
			; if vlist/2 = empty-set [remove/part vlist 2]	;-- empty-set works because masks/exclude trims it
		; ]
		; vlist
	; ]
	
	; values/map-each: function [							;@@ use normal map-each when it's native
		; "Map value list into another one, transforming masks"
		; spec [block!] "[value mask]" vlist [block!] code [block!] "Should return a new mask"
	; ][
		; result: clear copy vlist
		; foreach (spec) vlist [repend result [:value do code]]
		; result 
	; ]
	
	; values/remove: function [vlist [block!] range [pair!] /local value mask] [
		; values/normalize values/map-each [value mask] vlist [masks/remove mask range]
	; ]
	
	; values/clip: function [vlist [block!] range [pair!] /local value mask] [
		; values/normalize values/map-each [value mask] vlist [masks/clip mask range] 
	; ]
	
	; values/shift: function [vlist [block!] offset [integer!] /local value mask] [
		; values/map-each [value mask] vlist [masks/shift mask offset]
	; ]
	
	; values/union: function [vlist1 [block!] vlist2 [block!]] [
		; vlist1: copy vlist1
		; foreach [value mask2] vlist2 [
			; either pos: find/only/same/skip vlist1 :value 2 [
				; pos/2: pos/2 or mask2
			; ][
				; repend vlist1 [:value copy mask2]
			; ]
		; ]
		; values/normalize vlist1
	; ]
	
	; values/insert: function [vlist [block!] range [pair!] other [block!]] [
		; part1: values/clip vlist 0 by range/1
		; part2: values/clip vlist range/2 by infxinf/x
		; other: values/shift other range/1
		; values/union values/union part1 part2 other
	; ]

original /source decoder monstrosity
; on-source-change: function [
	; space [object!] word [word!] new-source [block!]
	; /local range attr value char string obj2
; ][
	; if unset? :space/ranges [exit]					;-- not initialized yet
	; clear att-ranges: space/ranges/attributes
	; clear spc-ranges: space/ranges/spaces
	; clear content:    space/content
	; buffer: clear ""
	; offset: 0										;-- using offset, not indexes, I avoid applying just opened (empty) ranges
	; start: clear #()								;-- offset of each attr's opening
	; attrs: clear #()								;-- last value of each attribute
	; get-range-blueprint: [
		; switch/default attr [						;-- transforms attributes into RTD low-level format
			; bold italic underline strike [[pair attr]]
			; color size font command [[pair attrs/:attr]]
			; backdrop [[pair 'backdrop attrs/backdrop]]
		; ][ [] ]
	; ]
	; flush: [
		; if 0 < text-len: length? buffer [
			; text-ofs: offset - text-len				;-- offset of the buffer
			; command: none
			; flags: clear []
			; parse att-ranges [collect after flags any [	;-- add closed ranges if they intersect with text
				; set range pair! if (range/2 > text-ofs)		;-- nonzero intersection found
				; [
					; set command block!						;-- command is RTD dialect extension
				; |	keep (as-pair  1 + max 0 range/1 - text-ofs  range/2 - range/1)
					; keep to [pair! | end]
				; ]
			; |	skip to pair!
			; ]]
			; ?? [offset text-ofs buffer att-ranges flags start]
			; main-attr: attr
			; foreach [attr attr-ofs] start [			;-- add all open ranges
				; attr: to word! attr
				; if attr-ofs >= offset [continue]	;-- empty range yet, shouldn't apply until at least 1 item
				; either attr = 'command [
					; command: attrs/command
				; ][									;-- rest goes into the /flags facet
					; flag-ofs: attr-ofs - text-ofs
					; pair: as-pair
						; 1 + max 0 flag-ofs
						; max 0 text-len - flag-ofs
					; repend flags do get-range-blueprint
				; ]
				; ?? [attr pair flags]
			; ]
			
			; ;@@ whether to commit whole buffer or split it into many spaces by words - I'm undecided
			; ;@@ less spaces = faster, but if single space spans all the lines it's many extra renders
			; ;@@ only benchmark can tell when splitting should occur
			; append content obj: make text-prototype [
				; quietly cached: spaces/ctx/clone text-prototype/cached cached
			; ]
			; quietly obj/text:  copy buffer
			; quietly obj/flags: copy flags
			; repend spc-ranges [text-ofs by offset obj]
			; ?? obj
			; clear buffer
			
			; ?? [offset main-attr command-group]
			; if main-attr = 'command [				;-- group multiple spaces into a clickable/hlist
				; unless empty? command-group [
					; clear back find/same spc-ranges first command-group		;-- remove ranges for subitems
					; ;; collapse all ranges
					; ;@@ this whole func needs a lot of refactoring, what a mess
					; ?? offset
					; offset: command-offset + 1
					; range-limit: command-offset by offset
					; ?? offset
					; ?? att-ranges
					; ?? start
					; forall att-ranges [				;@@ use map-each
						; att-ranges/1: min att-ranges/1 range-limit
						; att-ranges: next att-ranges
					; ]
					; foreach [attr attr-ofs] start [
						; start/:attr: min attr-ofs command-offset
					; ] 
					; ?? att-ranges
					; ?? start
					
					; obj: make-space 'clickable [
						; content: make-space 'list [
							; quietly axis:   'x
							; quietly margin: 0x0
						; ]
					; ]
					; quietly obj/content/spacing: space/spacing
					; quietly obj/content/content: copy command-group
					; quietly obj/command: command
					; insert clear command-group obj
					
					; repend spc-ranges [range-limit obj]
				; ]
				; command-group: unless main-attr == /command [tail content]	;-- offset in content (unlike `start`)
				; command-offset: offset
			; ]
			; attr: main-attr
		; ]
	; ]
	; commit-attr: [
		; attr: to word! attr							;-- convert /ref & set-word: to words
		; if start/:attr [
			; pair: start/:attr by offset
			; if pair/2 > pair/1 [repend att-ranges do get-range-blueprint]
		; ]
	; ]
	; =open-flag=:  [(unless start/:attr [start/:attr: offset  attrs/:attr: on])]
	; =open-attr=:  [(do commit-attr  start/:attr: offset  attrs/:attr: value)]
	; =close-attr=: [(do commit-attr  remove/key start attr  attrs/:attr: off)]
	; =color=: [
		; set value word! (value: get value #assert [tuple? value])
	; |	set value #expect tuple!
	; ]
	
	; parse/case new-source [any [
		; ahead word! set attr ['bold | 'italic | 'underline | 'strike] =open-flag=
	; |	ahead refinement! set attr [						;-- first closing closes the attribute
			; /bold | /italic | /underline | /strike
		; |	/color | /backdrop | /size | /font | /command
		; ] (if attr = 'command flush) =close-attr=
	; |	ahead set-word! [
			; set attr quote color:    =color= =open-attr=
		; |	set attr quote backdrop: =color= =open-attr=
			; ;; font and size split the result because otherwise a single big letter will make all rows distant
		; |	set attr quote size:     set value #expect integer! =open-attr= (do flush)
		; |	set attr quote font:     set value #expect string!  =open-attr= (do flush)
			; ;; command splits it because only single command per space is supported
		; |	set attr quote command:  set value #expect block!   =open-attr= (do flush)
		; ]
	; |	set string string! (
			; chunks: next split string #"^/"
			; append buffer chunks/-1
			; offset: offset + length? chunks/-1
			; forall chunks [							;@@ use for-each
				; do flush
				; append content obj2: copy linebreak-prototype
				; repend spc-ranges [offset + 0x1 obj2]
				; append buffer chunks/1
				; offset: offset + 1 + length? chunks/1
			; ]
		; )
	; |	set char char! (
			; either char = #"^/" [
				; do flush
				; append content obj2: copy linebreak-prototype
				; repend spc-ranges [offset + 0x1 obj2]
			; ][
				; append buffer char
			; ]
			; offset: offset + 1
		; )
	; |	paren! reserved
	; |	block! TODO grouping
	; |	set obj2 object! (							;-- flush will override 'obj', so 'obj2' here
			; do flush
			; #assert [space? obj2]
			; obj2: space/apply-attributes obj2 attrs
			; #assert [space? obj2  "apply-attributes must return the space object!"]
			; append content obj2
			; repend spc-ranges [offset + 0x1 obj2]
			; offset: offset + 1
		; )
	; |	end | p: (ERROR "Unexpected (type? :p/1) value at: (mold/part/flat p 40)")
	; ] end]
	; do flush										;-- commit last string
	; ?? content ?? ranges		
	
	; invalidate space
; ]

some feeble attempts at deep copy/paste
; clone: function [space [object!] range [pair!]] [
	; if range/1 > range/2 [range: reverse range]
		; text paragraph [
			; cloned: space/clone
			; len: get-length space
			; clipped: clip range 0 len
			; if clipped/2 < len [
				; clear skip cloned/text clipped/2
				; if cloned/flags [
					; cloned/flags: map-each [p [pair!]] cloned/flags [
						; e: p/2 + s: p/1
						; e: clip e s clipped/2		;@@ get rid of empty flags
						; s by e 
					; ]
				; ]
			; ]
			; if clipped/1 > 0 [
				; remove/part cloned/text clipped/1
				; if cloned/flags [
					; cloned/flags: map-each [p [pair!]] cloned/flags [
						; e: p/2 + s: p/1 - clipped/1
						; s by e 
					; ]
				; ]
			; ]
			; cloned
		; ]
	; switch/default space/type [
		; rich-content [
			; len: get-length cloned: space/clone
			; clipped: clip range 0 len
			; ;@@ use source facilities here; remove recursion
			; cloned
		; ]
	; ][
		; #assert [in space 'items]
		; content: make [] len: space/items/size
		; repeat i len [
			; child: space/items/pick i
			; len: get-length child
			; unless zero? span? clipped: clip range 0 len [
				; append content clone child clipped
			; ]
			; range: range - len
			; if range/2 <= 0 [break]
		; ]
		; either 0 by len = range [
			; cloned: space/clone
			; cloned/content: content
			; cloned
		; ][
			; content
		; ]
	; ]
; ]

generic section generation that uses explicit margin & spacing (decided to infer from map later)
; ;; this function assumes no scaling or anything fishy, plain map
; ;; uses geom/size/x, not space/size/x because parent's map may have been fetched from the cache,
; ;; while children sizes may not have been updated
; ;; it's not totally error-proof but I haven't come up with a better plan
; generate-sections: function [
	; "Generate sections block out of list of spaces; returns none if nothing to dissect"
	; map     [block!] "A list in map format: [space [size: ...] ...]" (parse map [end | object! block! to end])
	; margin  [integer!] (margin  >= 0)
	; spacing [integer!] (spacing >= 0)					;@@ or take spacing directly from the map?
; ][
	; switch n: half length? map [						;-- optimizations
		; 0 [return if margin <> 0 [reduce [margin * -2]]]
		; 1 [
			; if margin = 0 [
				; return if sections: select map/1 'sections [sections]	;-- calls if a function
			; ]
		; ]
	; ]
	; margin:   when margin  <> 0 (negate margin)
	; spacing:  when spacing <> 0 (negate spacing)
	; sections: make [] 16								;-- can't be shared due to reentrancy, needed length is unknown
	; append sections margin
	; foreach [space geom] map [
		; batch: if in space 'sections [space/sections]	;-- calls if a function, may return none
		; append append sections any [batch geom/size/x] spacing
	; ]
	; if integer? spacing [take/last sections]
	; unless all [single? sections  sections/1 >= 0] [	;-- optimize single positive out
		; sections
	; ]
; ]

first working paragraph layout that I decided to unroll into a row
; ;; unlike tube this allows the single space to span multiple lines, wrapping it accordingly
; ;; wrapping occurs between spaces and between sections (if supported by each item)
; ;; it is able to wrap any space without that space knowing about it, letting it keep simple box-like rendering logic
; ;; has no support for axes or weight
; ;@@ maybe remove limits and apply them to canvas in advance?
; paragraph: context [
	; ;; settings for paragraph layout:
	; ;;   align          [none! word!]   one of: [left center right fill], default: left
	; ;;   baseline      [float! percent!]  0=top to 1=bottom(default) normally, otherwise sticks out - vertical alignment in a row
	; ;;   margin        [integer! pair!]   >= 0x0
	; ;;   spacing       [integer! pair!]   >= 0x0 - mostly used for vertical distancing
	; ;;   canvas         [none! pair!]   if none=inf, width determined by widest item
	; ;;   limits        [none! object!]
	; ;;   indent        [none! block!]   [first: integer! rest: integer!], first and rest are independent of each other 
	; create: function [
		; "Build a paragraph layout out of given spaces and settings as bound words"
		; spaces [block! function!] "List of spaces or a picker func [/size /pick i]"
		; settings [block!] "Any subset of [align margin spacing canvas limits]"
		; ;; settings - imported locally to speed up and simplify access to them:
		; /local align baseline margin spacing canvas limits
	; ][
		; func?: function? :spaces
		; count: either func? [spaces/size][length? spaces]
		; if count <= 0 [return copy/deep [0x0 [] []]]
		; foreach word settings [						;-- free settings block so it can be reused by the caller
			; #assert [:self/create =? context? bind word 'local]
			; set bind word 'local get word
		; ]
		; #debug [typecheck [
			; align    [word! (find [left center right fill] align) none!]
			; baseline [percent! float!]
			; margin   [integer! (0 <= margin)  pair! (0x0 +<= margin)]
			; spacing  [integer! (0 <= spacing) pair! (0x0 +<= spacing)]
			; canvas   [none! pair!]
			; limits   [object! (range? limits) none!]
			; indent   [block! (valid-indent? indent) none!]
		; ]]
		; default align:    'left
		; default baseline: 80%
		; default canvas:   infxinf					;-- none to pair normalization
		; set [|canvas|: fill:] decode-canvas canvas
		; default indent:   []
		; indent1: any [indent/first 0]
		; indent2: any [indent/rest  0]
		; margin:  margin  * 1x1						;-- integer to pair normalization
		; spacing: spacing * 1x1
		; info: obtain block! count * 2
		; #leaving [stash info]
		
		; ;; clipped canvas - used for allowed width fitting
		; ccanvas: subtract-canvas constrain |canvas| limits 2 * margin
		; #debug sizing [#print "paragraph canvas=(canvas) ccanvas=(ccanvas)"]
		
		; ;; render everything
		; repeat i count [
			; space: either func? [spaces/pick i][spaces/:i]
			; #assert [space? :space]
			; ;; linebreaks will be rendered on finite canvas so they set their size (matters if they are made visible):
			; ;@@ not sure, maybe they should stretch to total-width, but canvas/x seems more reasonable
			; ;; using infxinf canvas for the rest to avoid wrapping and any canvas dependence (which also avoids extra renders)
			; ;@@ I could make an extra render run to stretch items vertically to row height,
			; ;@@ but that won't work for spaces that get wrapped to the next row: row sizes may differ
			; ;@@ I could use min of all of them, but so far I see no clear need in this slowdown
			; drawn: render/on space either space/type = 'break [canvas][infxinf]
			; repend info [space drawn]
		; ]
		
		; ;; split info into rows according to found widths
		; rows: obtain block! 50						;-- [row-offset row-scale clip-start clip-end row ...]
		; row:  obtain block! count * 3				;-- [item item-offset item-drawn ...]
		; #leaving [foreach [_ _ _ _ row] rows [stash row]  stash rows]
		
		; allowed-row-width: max 0 ccanvas/x			;-- how wide rows to allow (splitting margin)
		; total-length: total-width: 0				;-- total final extent of non-empty area
		; row-width: row-hidden: row-visible: row-height: 0	;-- per-row counters
		; row-indent: indent1
		
		; ;; next part relies on other functions from the context:
		; foreach [space: drawn:] info [				;@@ use for-each
			; sections: if in space 'sections [space/sections]	;-- calls if a function
			; either sections [
				; offset: 0
				; foreach width sections [
					; ;; empty part is significant at head - for code indentation
					; ;; and at tail - for sub-paragraphs (e.g. in urls) to not eat spaces (handled later)
					; either any [width > 0 offset = 0] [
						; commit-part space drawn offset offset + abs width
					; ][
						; commit-empty width: negate width	;-- soft break on empty region (whitespace)
					; ]
					; offset: offset + width
				; ]
			; ][
				; either space/type = 'break [		;-- ensure break is always on a separate line
					; new-row
					; commit-space space drawn
					; new-row
				; ][									;-- normal space
					; commit-space space drawn
					; commit-empty spacing/x
				; ]
			; ]
		; ]
		; row-visible: row-width - row-hidden			;-- force trailing space to become significant
		; unless empty? row [new-row]					;-- count last row's size
		; #assert [any [empty? rows  not empty? last rows]]	;-- can be empty if all spaces are whitespace
		; if total-length > 0 [total-length: total-length - spacing/y]
		
		; ;; build the map & fix alignment
		; ;; vertical alignment requires final row height
		; ;; horizontal alignment requires final total width (known after all rows are finished)
		; ;; map cannot have doubled (wrapped) items, because focus should be set on the whole item
		; ;; so coordinates must be unrolled, but for simplicity I'll make a map without coordinates
		; map: clear []
		; forall rows [								;@@ use for-each or map-each
			; set [row-offset: row-indent: row-clip-start: row-clip-end: row:] rows
			; rows/2: 1.0								;-- replace indent by scale 
			; left:  total-width - row-indent - (row-clip-end/x - row-clip-start/x)	;-- can be negative and it's fine
			; shift: left * select #(left 0 fill 0 right 1 center 0.5) align
			; if align = 'fill [						;-- set the scale
				; unless any [
					; empty? row
					; row/1/type = 'break				;-- don't scale linebreak row
					; tail? skip rows 5				;-- don't scale the last row or it's always scaled
				; ][
					; ;@@ ideally I should also stretch empty parts but it's tricky to implement
					; width: first row-clip-end - row-clip-start
					; limit: 90%
					; scale: allowed-row-width - row-indent / (max 1 width)
					; scale: clip scale limit 1 / limit
					; ;; reduce scale to align it to pixels, else width may become 1px bigger than the canvas:
					; rows/2: scale: min scale (to integer! scale * width) / width
					; total-width: max total-width row-indent + round/to width * scale 1
				; ]
			; ]
			; rows/1: row-offset + (shift by 0)
			; pos: 0x0
			; forall row [							;@@ use for-each or map-each
				; space: row/1
				; ;; remember vertical offset within the row (used by /draw and /into):
				; row/2: row/2 by round/to row-clip-end/y - space/size/y * baseline 1	
				; unless space =? pick tail map -2 [	;-- do not duplicate items in the map
					; repend map [space none]			;-- list-spaces rely on maps having 2 columns ;@@ for-each could fix that
				; ]
				; row: skip row 2
			; ]
			; rows: skip rows 4
		; ]
		; size: 2 * margin + (total-width by total-length)
		; #debug sizing [#print "paragraph c=(canvas) cc=(ccanvas) >> size=(size)"]
		; #assert [size +< infxinf]
		
		; ;; container/draw cannot be used with this layout due to it's tricky coordinate shifts
		; ;; so return format is different too ;@@ any way to unify return format with the others?
		; reduce [size copy map copy/deep rows]		;@@ should rows include margin offset? currently they do not
	; ]
	
	; ;; these are externalized from the /create function to avoid spawning new functions all the time
	; commit-empty: func [width] with :create [				;-- soft break (usually whitespace)
		; if empty? row [row-hidden: row-hidden + width]
		; row-width: row-width + width
	; ]
	; commit-space: func [space drawn] with :create [			;-- whole space object (indivisible)
		; claim space/size/x
		; row-height: max row-height space/size/y
		; repend row [space row-width - space/size/x drawn]
	; ]
	; commit-part: func [space drawn offset1 offset2] with :create [	;-- region of space (usually chars)
		; claim width: offset2 - offset1						;-- offsets carry the info on where this section is located
		; unless space =? pick tail row -3 [					;-- it's not the last added space? (was split or is a new one)
			; row-height: max row-height space/size/y
			; if empty? row [
				; row-hidden: offset1
				; row-width:  offset2
			; ]
			; repend row [space row-width - offset2 drawn]
		; ]
	; ]
	; claim: func [width] with :create [
		; if all [
			; not empty? row
			; row-indent + row-width - row-hidden + width > allowed-row-width
		; ] [new-row]
		; row-width:   row-width + width
		; row-visible: row-width - row-hidden
	; ]
	
	; ;; hidden [ visible ] empty  (both edges are hidden but I only keep track of the 1st, so I call it 'hidden')
	; ;; <-      row-width     ->
	; new-row: does with :create [
		; repend rows [
			; (row-indent - row-hidden) by total-length	;-- row offset
			; row-indent								;-- row indent at first, then replaced by row-scale
			; row-hidden by 0							;-- clip start
			; row-hidden + row-visible by row-height	;-- clip end
			; copy row
		; ]
		; clear row
		; total-length: total-length + row-height + spacing/y
		; total-width:  max total-width row-indent + row-visible
		; row-hidden: row-width: row-visible: row-height: 0
		; row-indent: indent2
	; ]
	
	; #debug [
		; valid-indent?: function [indent [block!]] [
			; all [
				; find [none! integer!] indent/first
				; find [none! integer!] indent/rest
			; ]
		; ]
	; ]
; ]

another failed attempt at rich-paragraph - too many complications caused by sections handling
e.g. when determining if row ended on an empty section, and it's real size is less than predicted
; ;; collect all sections on the map (not the same as sections on the paragraph layout)
; ;; for non-fill alignments it may skip spaces that fully fit
; dissect-map: function [] with :create [
	; words: make [] count * 5
	; row: clear []
	; ;@@ need to disable scaling for non-fill alignments
	; #assert [any [align = 'fill scaling = 0]]
	; max-width: to integer! 1 + scaling * allowed-row-width	;-- rounded down; allows bigger rows if scaled
	; row-width: 0
	; foreach [space geom] map [
		; width: space/size/x
		; either row-width + width <= max-width [
			; row-width: row-width + width
		; ][
		; ]
	; ]
	; words
; ]

; build-index: function [] with :create [
	; index: clear []
	; i: 0
	; foreach [space geom] map [					;@@ use for-each
		; reach: geom/offset/x + geom/size/x - 1 >> 4 + 1
		; enlarge index reach i: i + 1
	; ]
	; make vector! index
; ]

; ;; returns map before item that either contains x level
; locate: function [map [block!] index [vector!] level [integer!]] [
	; #assert [not empty? map]
	; n: half length? map
	; i: pick index level >> 4 + 1
	; #assert [i]
	; map: at map i * 2
	; while [all [geom: map/4  geom/offset/x <= level]] [map: skip map 2]	;@@ REP #113
	; #assert [not empty? map]
	; map
; ]

; ;; add up sections until width is reached (or less)
; ;; returns [used taken], where used <= width, taken can be > width but includes only empty regions
; add-sections: function [sections [block!] width [integer!]] [
	; taken: used: 0
	; foreach w sections [
		; either w >= 0 [
			; if used + w > width [break]
			; taken: used: taken + w
		; ][
			; taken: taken - w
		; ]
	; ] 
	; reduce [used taken]
; ]

; ;@@ must be rebuilt on alignment change
; ;; each "word" is either a whole space or a part of one
; ;; words format: [startxend space] where start and end are x offsets in the map
; split-map: function [] with :create [
	; words: make [] count * 5
	; row: clear []
	; ;@@ need to disable scaling for non-fill alignments
	; #assert [any [align = 'fill scaling = 0]]
	; max-width: to integer! 1 + scaling * allowed-row-width	;-- rounded down; allows bigger rows if scaled
	; x1: 0
	; x2: x1 + max-width
	; m1: map
	; m2: locate map index x2
	; ;@@ consider case when x2 = geom2/offset/x! - need not section that item
	; set [item2: geom2:] m2
	; sec: if in item2 'sections [item2/sections]
	; ;; determine actual width that fits (x2')
	; either sec [
		; base: geom2/offset/x
		; set [used: taken:] add-sections sections x2 - base
		; x2': base + used
		; #assert [x2' - x1 <= max-width]
		; ;@@ in fill mode - scale & split
		; ;@@ else add region as row or single space per word? single makes sense
		; x1:  base + taken
	; ][
		; x2': geom2/offset/x
		; ;@@ what if previous space ends with an empty region?
		; repeat i 1 + offset? m1 m2 [
			; set [item: geom:] skip m1 i - 1 * 2
			; repend words [item x1 x2']
		; ]
		; x1:  x2'
	; ]
	; ;; save it
	; ;; continue
	; words
; ]

how I hate these paragraph divisions..
; flush-word: [
	; if section-start > word-start [			;-- word pending?
		; append words word-start by word-start: row-start + row-width
	; ]
; ]
; flush-row: [
	; do flush-word							;-- split words on row flush
	; if row-used > 0 [						;-- not empty row pending?
		; append rows row-start by row-start: length? words
		; row-start: row-start + row-width
		; row-width: row-used: 0
		; max-width: max-width2
	; ]
; ]
; foreach w sections [
	; either w > 0 [							;-- significant section
		; if row-width + w > max-width [		;-- row overflow, need to flush
			; do flush-row
		; ]
		; row-width: row-used: row-width + w
		; word-width: word-width + w
	; ][										;-- empty section
		; do flush-word
		; row-width: row-width - w
		; word-start: section-start - w
	; ]
	; section-start: section-start + abs w
; ] 
; do flush-row

early experiments in advanced paragraph
; ;@@ must be rebuilt on alignment change
; ;@@ although word splitting can be done once, not relevant to alignment
; ;; each "word" is either a whole space or a part of one
; ;; words format: [startxend space] where start and end are x offsets in the map
; split-map: function [] with :create [
	; ;@@ needs map, total, scaling, align, allowed-row-width
	; generate-sections map total sections: clear []
	; ;; make leading whitespace significant - and it can split the row
	; ;; (otherwise whitespace may dictate the width on slim canvases)
	; ;; (all other whitespace trails the relevant row and does not split it)
	; parse sections [some change [set w integer! (if w < 0)] (abs w)]
	
	; ;@@ need to return copy of sections - with margins added should be used as paragraph sections
	; ;@@ alignment should be ignored on inf canvas - optimize
	
	; ;@@ need to disable scaling for non-fill alignments
	; #assert [any [align = 'fill scaling = 0]]
	; max-width1: to integer! 1 + scaling * max 0 allowed-row-width - indent1	;-- rounded down; allows bigger rows if scaled
	; max-width2: to integer! 1 + scaling * max 0 allowed-row-width - indent2
				
	; ;; words are sequential groups of significant sections, but new-lines split words
	; words: clear []
	; rows:  clear []
	; max-width: max-width1
	
	; flush-row: [
		; unless tail? row-words [				;-- row is not empty?
			; append rows as-pair					;-- keep it as range of words
				; skip? row-words
				; length? words
			; row-words: tail words
			; row-base: base
		; ]
	; ]
	; parse sections [
		; (word-base: row-base: 0  row-words: words)
		; any [
			; opt [
				; (word-base: base)
				; some [
					; set w integer! if (w >= 0) (
						; if base + w - row-base > max-width [	;-- row overflow
							; if word-base < base [				;-- word is not empty already?
								; append words word-base by word-base: base	;-- commit word part
							; ]
							; do flush-row
						; ]
						; base: base + w
					; )
				; ]
				; (append words word-base by base)				;-- commit the last word
			; ]
			; any [set w integer! if (w <= 0) (base: base - w)]	;-- skip empty parts
		; ]
		; (do flush-row)
	; ]
	
	; reduce [sections  copy words  copy rows]
; ]

; ;@@ need to draw rows now and vertically align
; ;@@ perhaps they can vertically intersect (by the empty bands) on drawing
; ;@@ draw will be later, this only creates a 2D layout out of 1D
; draw: function [] with :create [
	; ;@@ needs rows, words, map, index, indent1,2, allowed-row-width
	
	; ;; normal row widths in pixels
	; width1: max 0 allowed-row-width - indent1
	; width2: max 0 allowed-row-width - indent2
	; ;; min widths are used to distribute whitespace over the allowed scaling
	; min-width1: round/ceiling/to 1 - scaling * width1 1	;-- rounded up
	; min-width2: round/ceiling/to 1 - scaling * width2 1
	; max-width1: to integer!      1 + scaling * width1	;-- rounded down; allows bigger rows if scaled
	; max-width2: to integer!      1 + scaling * width2
	
	; min-width: min-width1
	; width: width1
	; if align = 'fill [
		; vector: make vector! compose [float! 32 8]
	; ]
	; foreach row rows [
		; n-words: length? row-words: append/part clear [] words row + 1
		; #assert [n-words > 0]
		; word1: row-words/1  wordn: last row-words
		; src-row-width: wordn/2 - row-base: word1/1
		; either align = 'fill [
			; ;; additional white space to insert between words
			; white: (max 0 min-width - src-row-width) / (max 1 n-words - 1)
			
			; dst-row-width: width
			; row-width: max min-width src-row-width
			; row-scale: dst-row-width / row-width
			
			; ;; calculate each word's x offset
			; x-offsets: clear []
			; item-offset: 0
			; repeat i n-words [
				; word:  row-words/:i
				; item-offset: item-offset + any [shifts/:i 0]
				; append x-offsets word/1 - row-base + item-offset
			; ]
			; row-drawn: clear []
			; i: 0
			; foreach word row-words [			;@@ use map-each
				; i: i + 1
				; word-offset: pick x-offsets i
				
			; ]
		; ][
			; dst-row-width: src-row-width
			
		; ]
		
		
		
		; min-width: min-width2
		; width: width2
	; ]
; ]

; ;@@ move these out of layout
; roll: function [xy [pair!]] [
; ]
; unroll: function [xy [pair!]] [
; ]

; #debug [
	; valid-indent?: function [indent [block!]] [
		; all [
			; find [none! integer!] type?/word indent/first
			; find [none! integer!] type?/word indent/rest
		; ]
	; ]
; ]

initial paragraph/locate-child
; locate-child: function [
	; "Find a child closest to XY and return corresponding row and child pointers and offsets"
	; space [object!] xy [pair!]
; ][
	; rows:   space/frame/rows
	; margin: space/frame/margin
	; xy:     xy - margin
	; ;@@ use locate instead maybe?
	; for-each [prow: row-offset row-scale clip-start clip-end row] rows [
		; last-row: prow
		; xy': xscale xy 1 / row-scale				;-- correct xy/x for scaling if it's applied
		; row-xy: xy' - row-offset
		; if row-xy/y < clip-end/y [					;-- last line always accepts xy
			; row-xy: clip row-xy clip-start clip-end			;-- contain xy within row, so it doesn't get into hidden child areas
			; for-each [pchild: child child-offset _] row [
				; last-child: pchild
				; child-xy: row-xy - child-offset
				; if child-xy/x < child/size/x [break]
			; ]
			; break
		; ]
		; unless empty? row [last-child: skip tail row -3]	;-- if for-each terminates, last child in a row is "closest" to xy
	; ]
	; if last-child [
		; child-xy: row-xy - last-child/2
		; reduce [last-row row-xy last-child child-xy]
	; ]
; ]

working rich-content before I moved it to a new paragraph API
; xscale: :rich-paragraph-ctx/xscale

; locate-point: function [space [object!] xy [pair!]] [
	; xy: xy - space/frame/margin
	; if set [child: child-xy:] rich-paragraph-ctx/locate-child space xy [
		; child:  row/1
		; #assert [find/same space/decoded/ranges child]
		; crange: pick find/same space/decoded/ranges child -1
		; either crange/1 + 1 = crange/2 [
			; index: crange/2
			; caret: pick crange child-xy/x < (child/size/x / 2)
		; ][
			; index: crange/1     + offset-to-char  child/layout child-xy
			; caret: crange/1 - 1 + offset-to-caret child/layout child-xy
		; ]
		; reduce [child child-xy index caret]			;@@ what to return?
	; ]
; ]

; xy-to-caret: function [space [object!] xy [pair!]] [
	; last locate-point space xy
; ]

; caret-to-row: function [space [object!] caret [integer!] (caret >= 0) side [word!] (find [left right] side)] [
	; if empty? space/frame/rows [return none]
	; caret: caret + pick [0.5 -0.5] side = 'right	;-- right caret sticks to the right item
	; row-ranges: fill-row-ranges space
	; row: 1
	; foreach [irow range] row-ranges [
		; if caret < range/1 [if side = 'right [break]]		;-- this improves UX when crossing over 'break'
		; row: irow
		; if caret < range/2 [break]
	; ]
	; ;; returns row number - to cycle across row range to draw multiline selection (or none if no rows)
	; ;; some rows may only include a linebreak (ignored here), so visible row number <> real row number
	; row
; ]

; row-to-box: function [space [object!] row-number [integer!] (row-number >= 1)] [
	; set [row-offset: row-scale: clip-start: clip-end: row:] skip space/frame/rows row-number - 1 * 5
	; mrg: space/margin * 1x1
	; xy1: mrg + row-offset + (xscale clip-start row-scale)
	; xy2: xy1 + (xscale clip-end - clip-start row-scale)
	; reduce [xy1 xy2]
; ]

; ;@@ height returned should be not that of the row, but that of the highest adjacent item!!!
; caret-to-box: function [space [object!] caret [integer!] side [word!] (find [left right] side)] [
	; mrg: space/margin * 1x1
	; ;@@ if no rows - no row heights - no caret height, so what to return? margin + 0x0-0x0?
	; unless irow: caret-to-row space caret side [return reduce [mrg mrg]]
	; prow: skip space/frame/rows irow - 1 * 5
	; set [row-offset: row-scale: clip-start: clip-end: row:] prow
	
	; #assert [not empty? row]
	; caret': caret + pick [0.5 -0.5] side = 'right	;-- right caret sticks to the right item
	; pitem: row
	; for-each [p: item item-offset _] row [
		; range: pick find/same space/decoded/ranges item -1	;@@ maybe reorder these ranges for select usage
		; if caret' < range/1 [if side = 'left [break]]		;@@ can't use break/return in for-each :(
		; pitem: p
		; if caret' < range/2 [break]
	; ]
		
	; set [item: item-offset: _:] pitem
	; caret: clip caret range/1 range/2						;-- skip empty ranges that don't land on items
	; x: case [
		; caret = range/1 [item-offset/x]						;-- item height may not equal row height, so it's ignored
		; caret = range/2 [item-offset/x + item/size/x]
		; 'within [item-offset/x + first caret-to-offset item/layout (caret - range/1 + 1)]
	; ]
	; xy1: mrg + row-offset + xscale x by 0 row-scale
	; xy1/x: clip xy1/x mrg/x space/size/x - mrg/x			;-- contain caret within the paragraph (trailing spaces)
	; xy2: xy1 + (0 by clip-end/y)
	; ?? [x caret range xy1 xy2 clip-start clip-end]
	; reduce [xy1 xy2]
; ]

; non-white!: negate charset " ^-^/^M"

; ;@@ should these be cached? they depend on canvas, can't be put into space/ranges
; fill-row-ranges: function [space [object!]] [
	; ranges: clear []
	; caret-right: 0
	; for-each [/irow row-offset row-scale clip-start clip-end row] space/frame/rows [
		; ;; empty rows (and those with a linebreak) are excluded, since we don't want zero-sized caret
		; if any [
			; empty? row
			; all [3 = length? row  row/1/type = 'break]
		; ] [continue]
		
		; ;; leftmost caret
		; set [item: item-offset: _:] row
		; #assert [									;-- clipping margin should land on the first item
			; item-offset/x <= clip-start/x
			; clip-start/x < (item-offset/x + item/size/x)
		; ]
		; item-range: pick find/same space/decoded/ranges item -1
		; either item-range/2 - item-range/1 <= 1 [
			; ;@@ I don't do this, but user could provide breakpoints for a custom space so it gets split
			; ;@@ in this case I guess I should just consider the whole space a separator and not include it in the ranges
			; ;@@ I'm lazy to bother with this case for now, to hell with it
			; ;; current algorithm treats 'single-index' space as belonging to only one row
			; caret-left: item-range/1
		; ][
			; clipx: clip-start/x - item-offset/x
			; caret-left: item-range/1 - 1 + offset-to-caret item/layout clipx by 0
		; ]
		
		; ;; rightmost caret
		; set [item: item-offset: _:] skip tail row -3
		; #assert [									;-- clipping margin should land on the first item
			; item-offset/x <= clip-end/x
			; clip-end/x <= (item-offset/x + item/size/x)
		; ]
		; item-range: pick find/same space/decoded/ranges item -1
		; either item-range/2 - item-range/1 <= 1 [	;@@ same concern here as above
			; caret-right: item-range/2
		; ][
			; text:  item/layout/text
			; clipx: clip-end/x - item-offset/x
			; index: offset-to-caret item/layout clipx by 0
			; index: index? any [
				; find at text index non-white!
				; tail text
			; ]
			; caret-right: item-range/1 - 1 + index
		; ]
		
		; repend ranges [irow  caret-left by caret-right]
	; ]
	; copy ranges
; ]

; metrics: context [
	; measure: function [space [object!] plan [block!]] [
		; do with self plan
	; ]
	; length: function [/local s] with :measure [
		; ;@@ measure source or content? should be in sync but what is faster?
		; ;@@ or cache it once source is processed and return? what if invalidated?
		; len: 0
		; parse space/source [any [
			; set-word! skip | word! | refinement!
		; |	set s string! (len: len + length? s)
		; |	[char! | object!] (len: len + 1)
		; ]]
		; len
	; ]
	; point-to-caret: function [xy [pair!]] with :measure [
		; set [_: _: index: offset:] ~/locate-point space xy
		; side: pick [right left] offset < index
		; compose [offset: (offset) side: (side)]
	; ]
	; caret-to-box: function [offset [integer!] side [word!]] with :measure [
		; ~/caret-to-box space offset side
	; ]
; ]

; ;; these are just `copy`ed, since it's 5-10x faster than full `make-space`
; linebreak-prototype: make-space 'break [#assert [cache = none]]	;-- otherwise /cached facet should be `clone`d
; text-prototype:      make-space 'text []
; link-prototype:      make-space 'link []

; ;@@ should source support image! in it's content? url! ? anything else?
; on-source-change: function [
	; space [object!] word [word!] source [block!]
	; /local range attr value char string obj2
; ][
	; if unset? :space/decoded [exit]					;-- not initialized yet
	; set [items: attrs:] rich/source/deserialize source
	; space/decoded/items: items						;@@ use multiset here
	; space/decoded/attrs: attrs
	; set [content: ranges:] rich/source/to-spaces items attrs
	; space/decoded/ranges: ranges
	; space/content: content
	; invalidate space
; ]

; ;; can be styled but cannot be accessed (and in fact shared)
; ;; because there's a selection per every row - can be many in one rich-content
; selection-prototype: make-space 'rectangle [
	; type: 'selection
	; cache: none										;-- this way I can avoid cloning /cached facet
; ]

; draw-box: function [xy1 [pair!] xy2 [pair!]] [
	; selection: copy selection-prototype
	; quietly selection/size: xy2 - xy1
	; compose/only [translate (xy1) (render selection)]
; ]

; draw-selection: function [space [object!]] [
	; if any [
		; not sel: space/selected
		; empty? space/decoded/items
	; ] [return []]
	; if sel/1 > sel/2 [sel: reverse sel]
	; ;@@ this calls fill-row-ranges so many times that it must be super slow
	; lrow: caret-to-row space sel/1 'left  1
	; rrow: caret-to-row space sel/2 'right 1
	; set [lcar1: lcar2:] caret-to-box space sel/1 'left
	; set [rcar1: rcar2:] caret-to-box space sel/2 'right
	; ?? [sel lrow rrow lcar1 lcar2 rcar1 rcar2]
	; #assert [lrow <= rrow]
	; either lrow = rrow [
		; draw-box lcar1 rcar2
	; ][
		; collect [
			; set [lrow1: lrow2:] row-to-box space lrow
			; keep draw-box lcar1 lrow2
			; for irow lrow + 1 rrow - 1 [
				; set [row1: row2:] row-to-box space irow
				; if row1/y < row2/y [				;-- ignore empty lines
					; keep draw-box row1 row2
				; ]
			; ] 
			; set [rrow1: rrow2:] row-to-box space rrow
			; keep draw-box rrow1 rcar2
		; ]
	; ]
; ]

; draw-caret: function [space [object!]] [
	; unless caret: space/caret [return []]
	; box: space/measure [caret-to-box caret/offset caret/side]
	; quietly caret/size: box/2 - box/1 + (caret/width by 0)
	; invalidate/only caret
	; drawn: render caret
	; compose/only [translate (box/1) (drawn)]
; ]
	
; draw: function [space [object!] canvas: infxinf [pair! none!]] [	;-- adds selection and caret
	; drawn: space/rich-paragraph-draw/on canvas
	; if space/selected [
		; sdrawn: draw-selection space
		; drawn: reduce [sdrawn drawn]
	; ]
	; if space/caret [
		; cdrawn: draw-caret space
		; drawn: reduce ['push drawn cdrawn]
	; ] 
	; drawn
; ]

; clone: function [space [object!]] [		
	; clone: clone-space space [margin spacing align baseline weight color font indent]
	; ;; clone objects in the /source, /content will be regenerated automatically:
	; clone/source: map-each [item [object!]] space/source [
		; when select item 'clone (item/clone)
	; ]
	; clone
; ]
	
; ;@@ can this be unified with metrics?
; edit: context [
	; edit: function [target [object!] plan [block!] /local changed?] [
		; also do with self plan
			; if changed? [							;-- regens content & decoded
				; target/source: rich/source/serialize target/decoded/items target/decoded/attrs
			; ]
	; ]
	; copy: remove: insert: mark: none
; ]
; edit/copy: function [range [pair!] /keep /text] with :edit/edit [
	; if range/2 < range/1 [range: reverse range]
	; range: clip range 0 length? target/decoded/items		;@@ workaround for #5263 here as well
	; attrs: rich/attributes/copy target/decoded/attrs range
	; items: copy/part target/decoded/items range + 1
	; if keep [
		; target/decoded/attrs: attrs
		; target/decoded/items: items
		; set 'changed? yes
	; ]
	; either text [
		; to string! map-each/drop item items [
			; case [
				; char? :item [item]
				; all [space? :item  select item 'edit] [
					; item/edit [copy/text]
				; ]
				; 'else [continue]
			; ]
		; ]
	; ][
		; reduce [items attrs]
	; ]
; ]
; edit/remove: function [range [pair!]] with :edit/edit [
	; if range/2 < range/1 [range: reverse range]
	; range: clip range 0 length? target/decoded/items
	; target/decoded/attrs: rich/attributes/remove target/decoded/attrs range
	; remove/part (skip target/decoded/items range/1) (range/2 - range/1)
	; set 'changed? yes
; ]
; edit/insert: function [
	; offset [integer!]
	; items [object! (space? items) string! block!]
	; /with attrs: #() [map!]
; ] with :edit/edit [
	; offset: clip offset 0 length? target/decoded/items
	; case [
		; object? items [
			; attrs: items/decoded/attrs
			; items: items/decoded/items
		; ]
		; string? items [items: explode items]
	; ]
	; range: offset + (0x1 * length? items)
	; target/decoded/attrs: rich/attributes/insert target/decoded/attrs range attrs
	; insert skip target/decoded/items offset items
	; ?? offset ?? items ?? target/decoded/items
	; set 'changed? yes
; ]
; edit/mark: function [
	; range [pair!]
	; attr  [word!]
	; value "If falsey, attribute is cleared"
; ] with :edit/edit [
	; either :value [
		; #assert [(max range/1 range/2) <= length? target/decoded/items]
		; rich/attributes/mark  target/decoded/attrs attr :value range on
	; ][
		; rich/attributes/clear target/decoded/attrs attr range
	; ]
	; set 'changed? yes
; ]

	
; ;; unlike rich-paragraph, this one is text-aware, so has font and color facets exposed for styling
; declare-template 'rich-content/rich-paragraph [
	; ;; data flow: source -> breakpoints & (content -> items) -> make-layout
	; source:      []		#type [block!] :on-source-change			;-- holds high-level dialected data
	; color:       none												;-- color & font defaults are accounted for in style
	; font:        none
	; selected:    none	#type =? [pair! none!] :invalidates-look	;-- current selection (set programmatically - use event handlers)
	
	; ;; caret disabled by default, can be set to a caret space
	; caret:       none	#type [object! (space? caret) none!] :invalidates	
	
	; ;; user may override this to carry attributes (bold, italic, color, font, command, etc) to a space from the /source
	; ;@@ need to think more on this one
	; apply-attributes: func [space [object!] attrs [map!]] [space]	#type [function!]
	
	; ;@@ measure [length] can just use decoded/items now
	; measure: func [plan [block!]] [~/metrics/measure self plan]		#type [function!]
	; edit:    func [plan [block!]] [~/edit/edit       self plan]		#type [function!]
	; clone: does [~/clone self]
	
	; decoded: context [								;-- internal data, generated on source change
		; ;; items is the list of all things caret can skip: chars and spaces
		; items:  []
		; ;; attrs describes attribute mapping onto items: #(name [value mask ...] ...) 
		; attrs:  #()									;-- okay to have literal map (that's not copied) - will be overridden
		; ;; ranges preserve info about what spaces were 'single' in the source, and what spaces were created from text
		; ;; so caret can skip the single ones but dive into the created ones
		; ranges: []
	; ] #type [object!]
	
	; rich-paragraph-draw: :draw	#type [function!]
	; draw: func [/on canvas [pair!]] [~/draw self canvas]
; ]
 
binary-based source format, saved before I try string format
; rich: context [	;@@ how to name it?
	; ~: self												;-- allows to combine 'ranges' context with 'ranges' word
	
	; ranges: context [
		; to-rtd-pair: function [
			; "Convert source range into RTD range"
			; range [pair!]
		; ][
			; range/1 + 1 by (range/2 - range/1)
		; ]
	
		; from-rtd-pair: function [
			; "Convert RTD range into source range"
			; range [pair!]
		; ][
			; range/1 - 1 by (range/2 + range/1 - 1)
		; ]
		
		; #assert [2x5 = to-rtd-pair   1x6]
		; #assert [1x6 = from-rtd-pair 2x5]
	; ]
		
		
	; ;; externalization avoids name collision for common names like insert, copy, etc
	; masks: context [
		; from-range:
		; to-ranges:
		; normalize:
		; pick:
		; shift:
		; clip:
		; include:
		; exclude:
		; remove:
			; none
		; empty: #{}
	; ]
	
	; masks/from-range: function [range [pair!]] [
		; if range/2 < range/1 [range: reverse range]
		; range: max 0 range
		; #assert [range/2 < infxinf/x]
		; either positive? range/2 [
			; to #{} charset when range/2 <> range/1 (
				; reduce [range/1 '- range/2 - 1]
			; )
		; ][
			; copy #{}
		; ]
	; ]
	; #assert [
		; #{}       = masks/from-range -50x-100
		; #{}       = masks/from-range 0x0
		; #{FFFF}   = masks/from-range 0x16
		; #{7FFFC0} = masks/from-range 1x18
		; #{0FFC}   = masks/from-range 4x14
	; ]
	
	; zero!:          charset [0]
	; nonzero!:       complement zero!
	; nonzero-digit!: complement charset "0"
	
	; masks/to-ranges: function [mask [binary!]] [
		; parse mask [any zero! mask:]					;-- optimization: skip leading zeroes
		; ranges: clear []
		; unless empty? mask [
			; base: 8 * skip? mask
			; mask: enbase/base mask 2
			; parse mask [any [
				; any #"0" opt [s: some #"1" e: (
					; append ranges base + as-pair skip? s skip? e
				; )]
			; ]]
		; ]
		; copy ranges
	; ]
	; #assert [
		; [0x16]     = masks/to-ranges #{FFFF}
		; [1x18]     = masks/to-ranges #{7FFFC0}
		; [1x8 9x18] = masks/to-ranges #{7F7FC0}
	; ]
	
	; masks/normalize: function [mask [binary!]] [
		; trim/tail mask									;@@ workaround for bitset weirdness - auto trim the tail
	; ]
	; #assert [#{FF80} = masks/normalize #{FF800000}]
	
	; masks/pick: function [mask [binary!] index [integer!]] [
		; pick to bitset! mask index - 1
	; ]
	
	; masks/shift: function [mask [binary!] offset [integer!]] [
		; if zero? offset [return copy mask]
		; mask: enbase/base mask 2
		; either offset < 0 [
			; remove/part mask negate offset
		; ][
			; insert/dup mask #"0" offset
		; ]
		; append/dup mask #"0" (negate length? mask) and 7	;@@ stupid debase only accepts length divisible by 8
		; masks/normalize debase/base mask 2
	; ]
	; #assert [
		; #{7FFF80} = masks/shift #{FFFF}    1
		; #{FFFF}   = masks/shift #{7FFF80} -1
	; ]
	
	; masks/clip: function [mask [binary!] range [pair!]] [
		; masks/normalize mask and masks/from-range min range 8 * length? mask
	; ]
	; #assert [
		; #{0FFC}   = masks/clip #{FFFFF0} 4x14
		; #{0FFFF0} = masks/clip #{FFFFF0} 4 by infxinf/x
	; ]
	
	; masks/include: function [mask [binary!] other [pair! binary!]] [
		; if pair? other [other: masks/from-range other]
		; mask or other									;-- both are expected to be normalized already
	; ]
	; masks/exclude: function [mask [binary!] other [pair! binary!]] [
		; if pair? other [other: masks/from-range min other 8 * length? mask]
		; append/dup other #{00} (length? mask) - length? other
		; masks/normalize mask and complement copy other
	; ]
	; #assert [
		; #{0FFC}      = masks/include #{}       4x14
		; #{FFFFF0}    = masks/include #{F003F0} 4x14
		; #{FFFFF0}    = masks/include #{F00FF0} #{0FF0}
		; #{FFFFFF}    = masks/include #{F0}     #{0FFFFF}
		
		; #{F003F0}    = masks/exclude #{FFFFF0} 4x14
		; #{FFF0}      = masks/exclude #{FFFFF0} 12 by infxinf/x
		; #{F00FF0}    = masks/exclude #{FFFFF0} #{0FF0}
		; #{F0}        = masks/exclude #{FFFFF0} #{0FFFFF}
		; 2#{10101000} = masks/exclude 2#{11111100} 2#{01010100}
	; ]
	
	; masks/remove: function [mask [binary!] range [pair!]] [
		; if zero? span? range [return copy mask]
		; mask: enbase/base mask 2
		; remove/part skip mask range/1 range/2 - range/1 
		; append/dup mask #"0" (negate length? mask) and 7	;@@ stupid debase only accepts length divisible by 8
		; masks/normalize debase/base mask 2
	; ]
	; #assert [#{FFC0} = masks/remove #{FFFFF0} 4x14]
	
	
	
	; values: context [
		; normalize:
		; map-each:
		; copy:
		; remove:
		; exclude:
		; clip:
		; shift:
		; union:
		; insert:
			; none
	; ]
	
	; values/normalize: function [
		; "Returns a copy of values list without intersections and empty ranges"
		; vlist [block!] "Latter values take priority"
	; ][
		; vlist: skip tail copy vlist -2
		; coverage: copy vlist/2							;-- maintaining coverage allows it to be O(number of values)
		; while [not head? vlist] [						;@@ use for-each/reverse
			; vlist: skip vlist -2
			; vlist/2: masks/exclude vlist/2 coverage
			; unless head? vlist [coverage: coverage or vlist/2]
			; if empty? vlist/2 [remove/part vlist 2]		;-- empty? works because masks/exclude trims it
		; ]
		; vlist
	; ]
	; #assert [
		; [1 2#{10101000} 2 2#{01010100}]                = values/normalize [1 2#{11111100} 2 2#{01010100}]
		; [1 2#{11000000} 2 2#{00011000} 3 2#{00000011}] = values/normalize [1 2#{11000000} 2 2#{00011000} 3 2#{00000011}]
	; ]
	
	; values/map-each: function [							;@@ use normal map-each when it's native
		; "Map value list into another one, transforming masks"
		; spec [block!] "[value mask]" vlist [block!] code [block!] "Should return a new mask"
	; ][
		; result: clear copy vlist
		; foreach (spec) vlist [repend result [get/any spec/1 do code]]
		; result 
	; ]
	
	; values/copy: function [vlist [block!] /local value mask] [	;-- copy/deep would break sameness whereas this won't
		; values/map-each [value mask] vlist [copy mask]
	; ]
	
	; values/remove: function [vlist [block!] range [pair!] /local value mask] [
		; values/normalize values/map-each [value mask] vlist [masks/remove mask range]
	; ]
	
	; values/exclude: function [vlist [block!] range [pair!] /local value mask] [
		; values/normalize values/map-each [value mask] vlist [masks/exclude mask range]
	; ]
	
	; values/clip: function [vlist [block!] range [pair!] /local value mask] [
		; values/normalize values/map-each [value mask] vlist [masks/clip mask range] 
	; ]
	
	; values/shift: function [vlist [block!] offset [integer!] /local value mask] [
		; values/map-each [value mask] vlist [masks/shift mask offset]
	; ]
	
	; values/union: function [vlist1 [block!] vlist2 [block!]] [
		; vlist1: copy vlist1
		; foreach [value mask2] vlist2 [
			; either pos: find/only/same/skip vlist1 :value 2 [
				; pos/2: pos/2 or mask2
			; ][
				; repend vlist1 [:value copy mask2]
			; ]
		; ]
		; values/normalize vlist1
	; ]
	
	; ;; without 'range' (pair) length of 'other' is unknown
	; values/insert: function [vlist [block!] range [pair!] other [block!]] [
		; part1: values/clip vlist 0 by range/1
		; part2: values/shift
			; values/clip vlist range/1 by infxinf/x
			; range/2 - range/1
		; other: values/shift other range/1
		; vlist: values/union part1 part2
		; either empty? other [vlist][values/union vlist other]
	; ]
	; #assert [[1 #{A00B}] = values/insert [1 #{AB}] 4x12 []]
	
	; {
		; attrs format: #(
			; name [
				; value1 [range range ...]				;-- ranges sorted (by start then end)
				; value2 [range range ...]				;-- value is 'true' for words, anything else for set-words
				; ...
			; ]
			; ...
		; )
	; }
	; attributes: context [
		; to-rtd-flag:
		; make-rtd-flags:
		; mark:		;@@ or 'set'?
		; clear:
		; pick:
		; map-each:
		; clip:
		; copy:
		; remove:
		; shift:
		; union:
		; insert:
			; none
	; ]
	
	; attributes/to-rtd-flag: function [attr [word!] value [tuple! logic! string! integer!]] [
		; switch attr [
			; bold italic underline strike [attr]
			; color size font [value]
			; backdrop [compose [backdrop (value)]]
		; ]
	; ]
	; #assert [[backdrop 10.20.30] = attributes/to-rtd-flag 'backdrop 10.20.30]
		
	; rtd-attrs: make hash! [bold italic underline strike color backdrop size font]
	; attributes/make-rtd-flags: function [
		; "Make an RTD flags block out of given attributes"
		; attrs [map!] limits [pair!]
	; ][
		; length: limits/2 - limits/1
		; flags: clear []
		; foreach [attr values] attrs [
			; unless find rtd-attrs attr [continue]
			; foreach [value mask] values [
				; foreach range masks/to-ranges mask [	;@@ use map-each
					; range: clip 0 length range - limits/1
					; if zero? span? range [continue]
					; pair: ranges/to-rtd-pair range
					; flag: attributes/to-rtd-flag to word! attr value
					; append append flags pair flag
				; ]
			; ]
		; ]
		; copy flags
	; ]
	; #assert [
		; [1x8  bold] = attributes/make-rtd-flags #(bold [#[true] #{0FFFF0}]) 4x12
		; [5x8  bold] = attributes/make-rtd-flags #(bold [#[true] #{0FFFF0}]) 0x12
		; [5x16 bold] = attributes/make-rtd-flags #(bold [#[true] #{0FFFF0}]) 0x20
	; ]
	
	; ;@@ modify or not? currently it's a mess
	
	; ;@@ maybe move range before attr in the spec?
	; attributes/mark: function ["modifies" attrs [map!] attr [word!] value range [pair!] state [logic!]] [
		; values: any [attrs/:attr  attrs/:attr: make [] 2]
		; unless pos: find/same/only/skip values :value 2 [
			; repend pos: tail values [:value copy masks/empty]
		; ]
		; pos/2: either state [masks/include pos/2 range][masks/exclude pos/2 range]
		; attrs/:attr: ~/values/normalize values
		; attrs
	; ]
	; #assert [
		; #(bold [#[true] #{0FF0}]) = attributes/mark #(bold [#[true] #{}])     'bold on 4x12 on
		; #(bold [#[true] #{0FF0}]) = attributes/mark #(bold [#[true] #{0000}]) 'bold on 4x12 on
		; #(bold [#[true] #{F00F}]) = attributes/mark #(bold [#[true] #{FFFF}]) 'bold on 4x12 off
		; #(x [1 2#{01100110} 2 2#{00011000}]) = attributes/mark #(x [1 2#{01111110}]) 'x 2 3x5 on
		; #(x [1 2#{01100000} 2 2#{00001100} 3 2#{00000001}]) = attributes/mark #(x [1 2#{01100000} 2 2#{00001100}]) 'x 3 7x8 on
	; ]
	
	; ;; unlike /mark, clears all values in the range
	; attributes/clear: function ["modifies" attrs [map!] attr [word!] range [pair!]] [
		; if values: attrs/:attr [
			; values: ~/values/exclude values range
			; either empty? values [remove/key attrs attr][attrs/:attr: values]
		; ]
		; attrs
	; ]
	; #assert [#(bold [#[true] #{F001}]) = attributes/clear #(bold [#[true] #{FFF1}]) 'bold 4x12]
	
	; ;; problem with this one is not having a way to determine if attr is `none` or absent
	; ;; but I haven't designed attributes to carry 'none' value anyway
	; attributes/pick: function [attrs [map!] attr [word!] index [integer!]] [
		; if values: attrs/:attr [
			; foreach [value mask] values [
				; if masks/pick mask index [return :value]
			; ]
		; ]
		; none
	; ]
	; #assert [
		; on =  attributes/pick #(bold [#[true] #{F001}]) 'bold 1
		; on =  attributes/pick #(bold [#[true] #{F001}]) 'bold 4
		; on =  attributes/pick #(bold [#[true] #{F001}]) 'bold 16
		; none? attributes/pick #(bold [#[true] #{F001}]) 'bold 0
		; none? attributes/pick #(bold [#[true] #{F001}]) 'bold 5
	; ]
	
	; attributes/map-each: function [spec [block!] "[attr values]" attrs [map!] code [block!]] [
		; make map! map-each/eval (spec) attrs compose/only [		;-- have to compose for code to be bound to the spec
			; when not empty? values: do (code) (spec)
		; ]
	; ]
	
	; attributes/normalize: function [attrs [map!]] [
		; attributes/map-each [attr values] attrs [~/values/normalize values]
	; ]
	; attributes/clip: function [attrs [map!] range [pair!]] [
		; attributes/map-each [attr values] attrs [~/values/clip values range]
	; ]
	; #assert [#(bold [#[true] #{0F}]) = attributes/clip #(bold [#[true] #{0FF0}]) 4x8]
	
	; attributes/copy: function [attrs [map!] range [pair!]] [
		; attributes/shift attributes/clip attrs range negate range/1
	; ]
	
	; attributes/remove: function [attrs [map!] range [pair!]] [
		; attributes/map-each [attr values] attrs [~/values/remove values range]
	; ]
	; #assert [#(bold [#[true] #{0FF0}]) = attributes/remove #(bold [#[true] #{0FFF}]) 4x8]
	
	; attributes/shift: function [attrs [map!] offset [integer!]] [
		; attributes/map-each [attr values] attrs [~/values/shift values offset]
	; ]
	; #assert [
		; #(bold [#[true] #{000FF0}]) = attributes/shift #(bold [#[true] #{0FF0}])  8
		; #(bold [#[true] #{F0}    ]) = attributes/shift #(bold [#[true] #{0FF0}]) -8
	; ]

	; attributes/union: function [attrs [map!] other [map!]] [
		; names: union keys-of attrs keys-of other
		; result: make map! length? names
		; foreach name names [
			; result/:name: case [
				; not attrs/:name [values/copy other/:name]
				; not other/:name [values/copy attrs/:name]
				; 'both-have-it [values/union attrs/:name other/:name]
			; ]
		; ]
		; result
	; ]
	; #assert [#(bold [#[true] #{F00F}]) = attributes/union #(bold [#[true] #{000F}]) #(bold [#[true] #{F0}])]

	; ;; without 'range' (pair) length of 'other' is unknown
	; attributes/insert: function [attrs [map!] range [pair!] other [map!]] [
		; attrs: attributes/map-each [attr values] attrs [
			; ~/values/insert values range []
		; ]
		; other: attributes/clip attributes/shift other range/1 range
		; attributes/union attrs other
	; ]
	; #assert [#(bold [#[true] #{CABF}]) = attributes/insert #(bold [#[true] #{CF}]) 4x12 #(bold [#[true] #{ABD0}])]

	; source: context [
		; ;@@ need to make modularity somehow, later
		; datatypes: make map! reduce [
			; string! object [
				
			; ]
		; ]
		
		; deserialize: function [
			; "Split source into [items attributes]"
			; source [block!]
			; /local attr value item
		; ][
			; items:   clear copy source					;@@ should items be just chars and objects? other types support, e.g. image?
			; attrs:   make #() 10
			; pending: make #() 10
			; offset:  0
			; parse source [any [
				; set attr [
					; word! (value: on)
				; |	set-word! p: (value: do/next p 'p) :p	;-- reduce words (color names) to their values
				; ] (
					; attr:  to word! attr
					; stack: any [pending/:attr  pending/:attr: make [] 4]
					; repend stack [offset :value]
				; )
			; |	set attr refinement! (							;-- attributes work stack-like and do not close automatically
					; attr:  to word! attr
					; unless empty? stack: pending/:attr [		;-- extra closings are silently ignored
						; value: take/last stack
						; start: take/last stack
						; attributes/mark attrs attr :value start by offset on
					; ]
				; )
			; |	set item string! (								;@@ make it a module
					; parse item [collect after items keep pick to end]	;-- explodes the string
					; offset: offset + length? item
				; )
			; |	set item skip (
					; append/only items item
					; offset: offset + 1
				; )
			; ]]
			; foreach [attr stack] pending [						;-- auto-close unclosed ranges
				; foreach [start value] stack [
					; attributes/mark attrs to word! attr :value start by offset on
				; ]
			; ]
			; attrs: attributes/normalize attrs
			; reduce [items attrs]
		; ]
		
		; serialize: function [
			; "Create a source block out of items and attributes"
			; items [block!] attrs [map!]
			; /local part
		; ][
			; queue: clear []
			; foreach [attr values] attrs [
				; values: ~/values/normalize values
				; foreach [value mask] values [
					; opening: either true = :value [to word! attr][reduce [to set-word! attr :value]]
					; closing: to refinement! attr
					; foreach range masks/to-ranges mask [
						; ;; order is important: close then open, that's why I add 0.1
						; ;; e.g. to avoid output like `color: 1 "x" color: 2 /color "x" /color`
						; ;; when it should have been  `color: 1 "x" /color color: 2 "x" /color`
						; repend queue [range/1 + 0.1 opening range/2 closing]
					; ]
				; ]
			; ]
			; sort/stable/skip queue 2
			; result: clear []
			; foreach [offset marker] queue [
				; append/part result items items: skip head items to integer! offset
				; append result marker
			; ]
			; append result items
			; parse result [any [							;-- unify chars into strings
				; change copy part some char! (to string! part)
			; |	skip
			; ]]
			; copy result
		; ]
		
		; #assert [
			; ["x"] = serialize [#"x"] #()
			; ["12" bold "3456" /bold "7"] == serialize [#"1" #"2" #"3" #"4" #"5" #"6" #"7"] #(bold [#[true] #{3C}])
			; ["12" bold underline "3" /bold /underline] = serialize [#"1" #"2" #"3"] #(bold [#[true] #{20}] underline [#[true] #{20}])
			; ["1" x: 1 "2" /x x: 2 "3" /x "4"] = serialize [#"1" #"2" #"3" #"4"] #(x [1 #{40} 2 #{20}])
		; ]
		
		; ;@@ leverage prototypes for this
		; to-spaces: function [
			; "Transform decoded source into a list of spaces, return [content ranges]"
			; items [block!] attrs [map!]
		; ][
			; ;@@ should I clip attrs to items/length?
			; ;; collect all /command change offsets
			; commands: clear []
			; ;@@ how can I possibly generalize this all? perhaps all attributes except text ones should become spans?
			; offset: 0
			; if attrs/command [
				; foreach [value mask] attrs/command [
					; ranges: masks/to-ranges mask
					; foreach range ranges [repend commands [range :value]]
				; ]
				; filled: sort/skip commands 2
				; commands: clear []
				; foreach [range value] filled [
					; repend commands [
						; offset by range/1 none
						; range :value
					; ]
					; offset: range/2
				; ]
			; ]
			; repend commands [offset by length? items none]
			
			; ;; split items into spans at /command change offsets - to generate clickables
			; spans: clear []
			; foreach [range value] commands [
				; list: copy/part items range + 1
				; repend spans ['command :value range/1 list]
			; ]
			
			; ;@@ maybe do this within the upper loop? to avoid sublist allocations
			; content: clear []
			; ranges:  clear []							;-- range spans of items that caret can dive into
			; foreach [attr value offset items] spans [
				; spaces: clear []
				; ;@@ or trim them? or silently split into multiple paragraphs (hard)?
				; #assert [not find items #"^/"  "line breaks are not allowed inside paragraph text"]
				; parse items [any [
					; s: some char! e: (
						; append spaces obj: make-space 'text []
						; append/part obj/text s e
						; limits: offset + as-pair skip? s skip? e
						; obj/flags: attributes/make-rtd-flags attrs limits
						; repend ranges [obj limits]
					; )
				; |	set obj object! (
						; append spaces obj 
						; repend ranges [obj  offset + 0x1 + skip? s]
					; )
				; |	end
				; |	(ERROR "Unsupported data in the source: (mold/part s 40)")
				; ]]
				; either :value [
					; append content obj: make-space 'clickable [
						; content: make-space 'list [
							; quietly axis:   'x
							; quietly margin: 0x0
						; ]
					; ]
					; quietly obj/content/spacing: space/spacing	@@ need rich-content for this, or spacing info
					; quietly obj/content/content: copy spaces
					; quietly obj/command: value
					; limits: offset by length? items
					; repend ranges [
						; obj limits
						; obj/content limits
					; ]
				; ][
					; append content spaces
				; ]
			; ]
			; reduce [copy content make hash! ranges]
		; ]
	; ]
; ]

sided paragraph selection design - too complicated
; normalize-selection: function [selection [object!]] [
	; r: copy selection
	; if r/start/offset > r/end/offset [swap in r 'start in r 'end]
	; r 
; ]
	
; select: function [
	; doc [object!]
	; range [pair!]
	; side1 [word!] (find [left right] side1)
	; side2 [word!] (find [left right] side2)
; ][
	; sel: any [
		; doc/selected								;-- reuse the old object if possible
		; make classy-object! selection!
	; ]
	; if range/2 < range/1 [							;-- automatically order selection bounds
		; range: reverse range
		; swap 'side1 'side2
	; ]
	; sel/range:  range
	; sel/sides:  reduce [side1 side2]
	; sel/parent: doc
	; doc/selected: sel								;-- trigger the on-change updates
; ]

; selection!: declare-class 'selection [
	; parent: none			#type [object! none!]	;-- for auto invalidation
	; range:  0x0				#type [pair!]
	; sides:  [right left]	#type [block!] (parse sides [2 ['left | 'right]])
; ]

; on-selected-change: function [space [object!] word [word!] value [object! none!]] [
	; either value [ 
		; pair: value/range
		; #assert [pair/1 <= pair/2]
	; ][
		; pair: -1x-1
	; ] 
	; print ["mapping" pair]
	; map-selection space pair
; ]

initial attempt at up/down keys in document
; offset: space/caret/offset
; set [para1: pofs1: p1len:] doc-ctx/caret->paragraph doc offset
; prow: rich-content-ctx/caret->row para1 pofs1 space/caret/side
; cbox: rich-content-ctx/caret->box-2D para1 pofs1 space/caret/side
; either event/key = 'up [
	; either prow = 1 [
		; para2: pick (find/same doc/content para1) -1
		; if para2 [
			; pofs2: rich-content-ctx/xy->caret para2 cbox/1/x by para2/size/y - 0x1
			; p2len: para2/measure [length]
			; offset: offset - pofs1 - 1 - p2len + pofs2
		; ]
	; ][
		; pofs1': rich-content-ctx/xy->caret para1 cbox/1 - 0x1
		; ;; 'row above' may not succeed if items spans more than one line
		; ;; in this case simplest thing is to skip either row or item
		; pofs1': min pofs1 - 1 pofs1'
		; #assert [pofs1' >= 0]
		; offset: offset + (pofs1' - pofs1)
	; ]
; ][
	; ;@@ abstract it from frame access!
	; either prow = para1/frame/nrows [
		; para2: select/same doc/content para1
		; if para2 [
			; pofs2: rich-content-ctx/xy->caret para2 cbox/1/x by 0
			; offset: offset - pofs1 + p1len + 1 + pofs2
		; ]
	; ][
		; ;@@ might not work with nonzero row intervals! - add interval too
		; pofs1': rich-content-ctx/xy->caret para1 cbox/2 + 0x1
		; ;; 'row above' may not succeed if items spans more than one line
		; ;; in this case simplest thing is to skip either row or item
		; pofs1': max pofs1 + 1 pofs1'
		; #assert [pofs1' <= p1len]
		; offset: offset + (pofs1' - pofs1)
	; ]
; ]
; space/caret/offset: offset
; pwidth: para1/frame/size-2D/x

edit keys before I switch them from DSL to function model
; key->plan: none
; context [
	; near-moves: #(
		; left       [by -1]
		; right      [by  1]
		; backspace  [by -1]
		; delete     [by  1]
		; home       head
		; end        tail
		; up         up
		; down       down
	; )
	; far-moves:  #(
		; left      prev-word
		; right     next-word
		; backspace prev-word
		; delete    next-word
		; home      far-head
		; end       far-tail
		; up        up
		; down      down
	; )

	; set 'key->plan function [
		; "Turn keyboard event into an edit plan"
		; event    [event! object!]
		; selected [pair! none!] "Current selection state"
	; ][
		; key: event/key
		; either printable?: all [
			; char? key
			; key >= #" "
			; not event/ctrl?
		; ][
			; compose [
				; remove selected
				; insert (form key)
			; ]
		; ][
			; if key = #"^H" [key: 'backspace]
			; removal?: find [delete backspace] key
			; distance: select either event/ctrl? [far-moves][near-moves] key
			; action:   case [removal? ['remove] event/shift? ['select] 'else ['move]]
			; if all [removal? selected] [distance: 'selected]
			; switch/default key [
				; left right home end up down delete backspace [compose [(action) (distance)]]
				; #"A" [[select all]]
				; #"C" [[copy selected]]
				; #"X" [[copy selected  remove selected]]
				; #"V" [[remove selected  paste]]
				; #"Z" [pick [[redo] [undo]] event/shift?]
			; ] [[]]										;-- not supported yet key
		; ]
	; ]
; ]

field's edit (dialected, before switching to functions)
; edit: function [field [object!] plan [block!] /local n p] [
	; len: length? text: field/text
	; pos: skip text co: field/caret/offset
	; sel: field/selected
	
	; parse/case plan [any [plan:
		; ['undo (undo field) | 'redo (redo field)] (
			; pos: skip text co: field/caret/offset
			; len: length? text: field/text
		; )
		
		; ;@@ special case may be needed for NxN selection (should it become `none`?) need more usage data
	; |	'select [(n: none)
			; 'none (sel: none)
		; |	'all  (sel: 0 by co: len)
		; |	'head (n: negate co)
		; |	'tail (n: len - co)
		; |	'prev-word (n: (find-prev-word field co) - co)
		; |	'next-word (n: (find-next-word field co) - co)
		; |	'to set n integer! (n: n - co)
		; |	'by set n integer!
		; |	set p pair! (sel: p  co: p/1)
		; ] (
			; if n [									;-- this only works if caret is at selection edge
				; other: case [
					; not sel    [co]
					; co = sel/1 [sel/2]
					; co = sel/2 [sel/1]
					; 'else      [co]					;-- shouldn't happen, but just in case
				; ]
				; co: clip 0 len co + n
				; sel: (min co other) by (max co other)
			; ]
			; field/caret/offset: co
			; field/selected: sel
		; )
		
	; |	'copy [
			; set p pair! 
		; |	'selected (p: sel)
		; ] (if p [write-clipboard copy/part text p + 1])
		
	; |	'move [
			; 'head (co: 0)
		; |	'tail (co: len)
		; |	'prev-word (co: find-prev-word field co)
		; |	'next-word (co: find-next-word field co)
		; |	'sel-bgn   (if sel [co: sel/1])
		; |	'sel-end   (if sel [co: sel/2])
		; |	'to set co integer!
		; |	'by set n  integer! (co: co + n)
		; ] (
			; pos: skip text field/caret/offset: co: clip 0 len co
			; field/selected: sel: none				;-- `select` should be used to keep selection
		; )
		
	; |	[	'insert [set s string!]
		; |	'paste (s: read-clipboard) if (string? s)
		; ] (
			; unless empty? s [
				; field/caret/offset: co: skip? pos: insert pos s
				; len: length? text
				; mark-history field
			; ]
		; )
		
	; |	'remove [
			; 'prev-word (n: (find-prev-word field co) - co)
		; |	'next-word (n: (find-next-word field co) - co)
		; |	'selected  (n: 0  if sel [
				; n: sel/2 - co: sel/1
				; sel: field/selected: none
			; ])
		; |	set n integer!
		; ] (
			; if n < 0 [								;-- reverse negative removal
				; co: co - n: abs n
				; if co < 0 [n: n + co  co: 0]		;-- don't let it go past the head
			; ]
			; n: min n len - co						;-- don't let it go past the tail
			; if n <> 0 [
				; field/caret/offset: co
				; remove/part pos: skip text co n
				; len: length? text
				; mark-history field
			; ]
		; )
	; |	end
	; |	(ERROR "Unexpected edit command at: (mold/flat/part plan 50)")
	; |	skip										;-- some edit commands may not be supported by the field (e.g. up/down)
	; ]]
; ]

drop-button style experiment, rather problematic to make because of all the facet mappings, and because of no real popups
; drop-button: [
	; below: when select self 'color [push [pen off fill-pen (color) box 0x0 (size)]]
; ]
; ;@@ how to organize it?
; ;@@ popup UI needs improvements: touch-sized buttons, scrollbars and wheel scrolling, automatic limitation of scrollable size
; ;@@ also on-change event
; declare-template 'drop-button/list [
	; axis: 'x
	; spaces: object [
		; box:    make-space 'data-clickable [type: 'face]		;@@ how to name the type for styling consistency?
		; button: make-space 'data-clickable [type: 'side-button data: "⏷"]	;-- don't want 'button' style to apply to it
	; ]
	; content: reduce [spaces/box spaces/button]
	; command: []		#mirror-into spaces/box/command
	; data:    none	#mirror-into spaces/box/data
	; font:    none	#mirror-into [spaces/box/font spaces/button/font]
; ]
; define-handlers [
	; drop-button: [
		; face: [
		; ]
		; side-button: [
			; on-down [space path event] [
				; offset: -1x-1 + face-to-window event/offset event/face
				; menu: lay-out-menu items: [
					; "1" (print "1")
					; "2" (print "2")
					; "3" (print "3")
					; "Font" (print "hehe found it")
					; "hello" (print "HELL")
				; ]
				; drop-button: space/parent
				; picked: 1 + half any [skip? find items drop-button/data  0]
				; face: make-popup event/window 1
				; face/rate:  10										;-- reduced timer pressure
				; face/space: menu
				; face/size:  none									;-- to make render set face/size
				; face/draw:  render face
				; ?? menu/content
				; picked-geom: pick menu/content/map picked * 2
				; offset: offset - picked-geom/offset - (picked-geom/size / 2)
				; show-popup event/window 1 offset face
			; ]
		; ]
	; ]
; ]

; ;; this should automatically invalidate the parent, since child facet change will lead to it
; #macro [#mirror-into [path! | into [some path!]]] func [[manual] s e /local paths target] [
	; either path? target: e/-1 [
		; paths: reduce [to set-path! compose [space (to block! target)]]
	; ][
		; paths: target
		; forall paths [paths/1: to set-path! compose [space (to block! paths/1)]]
	; ]
	; remove/part s e
	; insert s compose/deep [#on-change [space word value] [(paths) :value]]
	; s
; ]

first feeble attempts at grouping edits
; ;; this func simplifies undo/redo code a bit
; make-actions: function [doc [object!] rem [block!] ins [block!] eval [block!]] [
	; edit: reduce [doc/selected doc/caret/offset rem]
	; do eval
	; repend edit [ins doc/caret/offset doc/selected]
	; compose/only/deep [
		; [document/atomic-edit (doc) (edit) (false)]
		; [document/atomic-edit (doc) (edit) (true)]	;-- edit block is shared, so only has to be grouped once when grouping
	; ]
; ]
	
; ;; action format: [selection offset [removed] [inserted] offset selection]
; ;; so it combines removal with insertion, and is reversible, and contains offset & selection at both ends
; ;; can be (easily) grouped if:
; ;; - both actions have only [insert] and end-offset2 = start-offset1
; ;; - both actions have only [remove] and end-offset2 = start-offset1
; group-actions: function [action1 [block!] "modified" action2 [block!] /local obj obj2 data1 data2 fwd] [
	; if all [
		; parse action1 ['document/atomic-edit set obj  object! set data1 block! set fwd logic!]
		; parse action2 ['document/atomic-edit set obj2 object! set data2 block! fwd]		;-- tests if direction matches
		; obj =? obj2									;-- cannot test sameness within parse
		; set [sel1-: ofs1-: rem1: ins1: ofs1+: sel1+:] data1
		; set [sel2-: ofs2-: rem2: ins2: ofs2+: sel2+:] data2
		; ofs2- = ofs1+
		; i: case [									;-- index of ins/rem block to modify
			; all [empty? rem1 empty? rem2] [4]		;@@ TODO: more grouping cases possible with more complex logic
			; all [empty? ins1 empty? ins2] [3]
			; all [empty? ins1 empty? rem2] [4]
		; ]
	; ][
		; #assert [not empty? data2/:i]
		; either empty? data1/:i [
			; append data1/:i data2/:i
		; ][
			; pos: either ofs2+ >= ofs2- [infxinf/x][0]
			; rich/decoded/insert! data1/:i pos data2/:i
		; ]
		; data1/5: data2/5							;-- copy selection & offset over
		; data1/6: data2/6
		; action1
	; ]												;-- none if can't group - didn't modify
; ]

obsolete document edit actions
; ;; unlike group-actions this is intended for grouping big enough changes, not single chars
; actions/group: function [
	; "Evaluate code and group resulting events on the timeline"
	; code [block!]
; ] with :actions/edit [
	; do update
	; begin: doc/timeline/mark
	; do code
	; end:   doc/timeline/mark
	; #assert [0 < offset? begin end]					;-- not intended for grouping undos
	; set [_: left: right:] doc/timeline/unwind
	; while [not same? begin doc/timeline/mark] [
		; set [_: left': right':] doc/timeline/unwind
		; append left  left'
		; insert right right'
	; ]
	; doc/timeline/put doc left right
; ]

; actions/paint: function [
	; "Paint given range with an attribute set (only first item's attribute is used)"
	; range [pair!] attrs [map!]
; ] with :actions/edit [
	; slice: copy orig: document/copy doc range
	; slice/2: rich/attributes/extend attrs length? slice/1
	; record-in-timeline doc [remove (range) insert (range) (orig)] [remove (range) insert (range) (slice)]
; ]

; actions/break: function [
	; "Break paragraph at current caret offset"
; ] with :actions/edit [
	; actions/insert "^/"
; ]

; document/atomic-edit: function [doc [object!] edit [block!] forward? [logic!]] [	;-- used by undo/redo
	; unless forward? [edit: reverse copy edit]
	; set [sel-: ofs-: rem: ins: ofs+: sel+:] edit
	; ofs: min ofs- ofs+								;-- if offset reduces during action, this is where it starts
	; if len: length? rem/1 [document/remove doc 0 by len + ofs]
	; if len: length? ins/1 [document/insert doc ofs ins]
	; doc/selected:     sel+
	; doc/caret/offset: ofs+							;@@ should I restore the side too?
; ]

; ;; easy attribute constructor
; make-attrs: function [attrs [block!] "Key/value pairs of attribute name & value"] [
	; make map! map-each/eval [name value] attrs [[
		; name compose/deep/only [values: [(:value)] mask: (copy "^A")]
	; ]]
; ]
	
; link-attrs: make-attrs compose/deep [
	; color (hex-to-rgb #35F)							;@@ I shouldn't hardcode the color like this
	; underline (on)
; ]

working string mask based source format, before I flattened it
; ;; this context proceeds from lowest level (ranges) to highest level (source) below
; rich: context [											;@@ what would be a better name?
	
	; ranges: context [
		; to-rtd-pair: function [
			; "Convert source range into RTD range"
			; range [pair!]
		; ][
			; range/1 + 1 by (range/2 - range/1)
		; ]
	
		; from-rtd-pair: function [
			; "Convert RTD range into source range"
			; range [pair!]
		; ][
			; range/1 - 1 by (range/2 + range/1 - 1)
		; ]
		
		; #assert [2x5 = to-rtd-pair   1x6]
		; #assert [1x6 = from-rtd-pair 2x5]
	; ]
		
	; zero!:    charset "^@"								;-- charset is about 10x faster than using a char
	; nonzero!: complement zero!
	
	; mask-to-ranges: function [values [block!] mask [string!] /local c] [
		; ranges: clear []
		; parse mask [
			; any [
				; any zero! s: set c nonzero! any c e: (
					; value: pick values to integer! c
					; append append ranges :value as-pair skip? s skip? e
				; )
			; ]
		; ]
		; copy ranges
	; ]
	
	; {
		; MEMO: mask length should always equal items length! otherwise would need to pass length separately anyway
		; attrs format: #(
			; name [										;-- attribute name
				; values: [value1 value2 ...]				;-- block of allowed values
				; mask:   "mask"							;-- string mapping items to values (zero char = no value)
			; ]
			; ...
		; )

		; I do not add #length into attrs as that would complicate foreach [attr data] loop
		; unfortunate result is that length has to be passed as argument together with attributes
		; ;@@ for-each loop could help this by filtering #length out
	; }
	
	; ;; external context allows me to use /copy word without shadowing the global one
	; attributes: context [
		; to-rtd-flag: make-rtd-flags: mark!: pick: copy: extend: remove!: insert!: none
	; ]
	
	; attributes/to-rtd-flag: function [attr [word!] value [tuple! logic! string! integer!]] [
		; switch attr [
			; bold italic underline strike [attr]
			; color size font [value]
			; backdrop [compose [backdrop (value)]]
		; ]
	; ]
	; #assert [[backdrop 10.20.30] = attributes/to-rtd-flag 'backdrop 10.20.30]
		
	; rtd-attrs: make hash! [bold italic underline strike color backdrop size font]
	; attributes/make-rtd-flags: function [
		; "Make an RTD flags block out of given attributes"
		; attrs [map!] limits [pair!] "segment to extract"
	; ][
		; flags:  clear []
		; length: span? limits
		; foreach [attr data] attrs [
			; unless find rtd-attrs attr [continue]		;-- attribute not supported by RTD
			; set [_: values: _: mask:] data
			; foreach [value range] mask-to-ranges values mask [	;@@ use map-each
				; range: clip 0 length range - limits/1
				; if zero? span? range [continue]
				; pair: ranges/to-rtd-pair range
				; flag: attributes/to-rtd-flag to word! attr value
				; append append flags pair flag
			; ]
		; ]
		; copy flags
	; ]
	; #assert [
		; [1x8  bold] = attributes/make-rtd-flags #(bold [values: [#[true]] mask: "^@^@^@^@^A^A^A^A^A^A^A^A^A^A^A^A^A^A^A^A^@^@^@^@"]) 4x12
		; [5x8  bold] = attributes/make-rtd-flags #(bold [values: [#[true]] mask: "^@^@^@^@^A^A^A^A^A^A^A^A^A^A^A^A^A^A^A^A^@^@^@^@"]) 0x12
		; [5x16 bold] = attributes/make-rtd-flags #(bold [values: [#[true]] mask: "^@^@^@^@^A^A^A^A^A^A^A^A^A^A^A^A^A^A^A^A^@^@^@^@"]) 0x20
	; ]
	
	; attributes/mark!: function [						;@@ maybe rename to set! ?
		; attrs  [map!]
		; length [integer!] (length >= 0) "target items size"		;-- required to insert missing attributes
		; range  [pair!]
		; attr   [word!]
		; value
	; ][
		; if zero? span: span? range [return attrs]
		; either not empty? data: attrs/:attr [			;-- existing attr
			; #assert [parse data [any-word! block! any-word! string!]]
			; set [_: values: _: mask:] data
			; #assert [length = length? mask]
			; char: #"^@"
			; if :value [
				; unless pos: find/only/case values :value [
					; append/only pos: tail values :value
				; ]
				; char: to char! index? pos
			; ]
			; change/dup (skip mask range/1) char span
		; ][												;-- new attr
			; if :value [									;-- not added if value is falsey
				; values: reduce [:value]
				; enlarge (mask: make {} length) length #"^@"
				; change/dup (skip mask range/1) #"^A" span
				; attrs/:attr: compose/only [values: (values) mask: (mask)]
			; ]
		; ]
		; attrs
	; ]
	; #assert [
		; #(x [values: [1] mask: "^@^@^@^@^A^A^A^A^A^A^A^A"  ]) = attributes/mark! #() 12 4x12 'x 1
		; #(x [values: [1] mask: "^@^@^@^@^A^A^A^A^A^A^A^A^@"]) = attributes/mark! #() 13 4x12 'x 1
		; #(x [values: [1] mask: "^@^@^A^A^A^A^@^@"          ]) = attributes/mark! #(x [values: [1] mask: "^@^@^@^@^@^@^@^@"]) 8 2x6 'x 1
		; #(x [values: [1] mask: "^A^A^@^@^@^@^A^A"          ]) = attributes/mark! #(x [values: [1] mask: "^A^A^A^A^A^A^A^A"]) 8 2x6 'x none
	; ]
	
	; ;; unlike /mark, clears all attributes in the range
	; attributes/clear!: function [attrs [map!] range [pair!]] [
		; foreach [name data] attrs [
			; change/dup skip data/mask range/1 #"^@" span? range
		; ]
		; attrs
	; ]
	
	; attributes/pick: function [attrs [map!] attr [word!] index [integer!]] [
		; all [
			; set [_: values: _: mask:] attrs/:attr
			; i: mask/:index
			; pick values to integer! i
		; ]
	; ]
	; #assert [
		; on =  attributes/pick #(bold [values: [#[true]] mask: {^A^A^@^@^A}]) 'bold 1
		; on =  attributes/pick #(bold [values: [#[true]] mask: {^A^A^@^@^A}]) 'bold 2
		; on =  attributes/pick #(bold [values: [#[true]] mask: {^A^A^@^@^A}]) 'bold 5
		; none? attributes/pick #(bold [values: [#[true]] mask: {^A^A^@^@^A}]) 'bold 0
		; none? attributes/pick #(bold [values: [#[true]] mask: {^A^A^@^@^A}]) 'bold 3
	; ]
	
	; attributes/copy: function [attrs [map!] range [pair!] (range/2 >= range/1)] [
		; slice: copy/deep attrs							;-- this doesn't copy the strings but they will be replaced anyway
		; foreach [attr data] slice [
			; data/mask: copy/part data/mask range + 1
		; ]
		; ;@@ should this clean up unused attribute values? probably not worth it
		; slice
	; ]
	
	; ;; copies first attribute slot until 'length' slots are occupied
	; attributes/extend: function [attrs [map!] length [integer!]] [
		; slice: copy/deep attrs							;-- this doesn't copy the strings but they will be replaced anyway
		; foreach [attr data] slice [
			; char: any [data/mask/1 #"^@"]
			; data/mask: make {} length
			; append/dup data/mask char length
		; ]
		; slice
	; ]
	
	; attributes/remove!: function [attrs [map!] range [pair!] (range/2 >= range/1)] [
		; if 0 <> span: span? range [
			; foreach [attr data] attrs [
				; remove/part skip data/mask range/1 span
			; ]
		; ]
		; ;@@ should this clean up unused attribute values? probably not worth it
		; attrs
	; ]
	
	; attributes/insert!: function [
		; attrs   [map!]
		; length  [integer!] (length >= 0) "target items size"	;-- required to insert missing attributes
		; offset  [integer!]
		; other   [map!]
		; length2 [integer!] (length2 >= 0) "inserted items size"	;-- required in case `other` is empty :/
	; ][
		; #assert [length >= length2  "target items are smaller than inserted slice!"]
		; offset: clip offset 0 length - length2
		; ;; insert empty regions into `attrs` - needed for attributes that aren't in `other`
		; foreach [attr data1] attrs [
			; insert/dup skip data1/mask offset #"^@" length2
		; ]
		; ;; merge `other` into `attrs`
		; foreach [attr data2] other [
			; ;; if attr is absent from the target, may just copy it over
			; unless data1: attrs/:attr [
				; attrs/:attr: data1: copy/deep data2
				; insert/dup data1/mask #"^@" offset
				; enlarge data1/mask length #"^@"
				; continue
			; ]
			; ;; otherwise, have to join values and remap the old mask
			; values1: make hash! data1/values
			; values2: append clear [] data2/values
			; forall values2 [							;@@ use map-each
				; values2/1: to char! index? any [
					; find/only/case        values1 :values2/1
					; back insert/only tail values1 :values2/1
				; ]
			; ]
			; insert values2 #"^@"						;-- null always maps to itself
			; mask2: data2/mask
			; forall mask2 [								;@@ use map-each
				; mask2/1: pick values2 1 + to integer! mask2/1
			; ]
			; data1/values: to [] values1
			; change (skip data1/mask offset) mask2		;-- mask2 now has values1-compatible indices
		; ]
		; attrs
	; ]
	; #assert [
		; #(x [values: [1]   mask: {^@^A^@^@^A^@}]) =       attributes/insert! #(x [values: [1] mask: {^@^A^A^@}]) 6 2 #() 2
		; #(x [values: [1 2] mask: {^@^A^@^A^B^A^@^A^@}]) = attributes/insert! #(x [values: [1] mask: {^@^A^A^@}]) 9 2 #(x [values: [2 1] mask: {^@^B^A^B^@}]) 5
		; #(x [values: [1]   mask: {^@^A^A^@^@^@}]) =       attributes/insert! #(x [values: [1] mask: {^@^A^A^@}]) 6 2000000000 #(x [values: [1] mask: {^@^@}]) 2
	; ]
	
	; ;@@ need to make modularity somehow, later
	; datatypes: make map! reduce [
		; string! object [
		; ]
	; ]
	
	; decoded: context [copy: remove!: insert!: normalize!: format: to-spaces: none]
	
	; decoded/copy: function [
		; "Copy a slice of decoded source"
		; source [block!] "[items attrs] block to copy from" (parse source [block! map!])
		; range  [pair!]  "head x tail"
	; ][
		; range: clip range 0 length? source/1			;@@ workaround for #5263 here as well
		; if range/1 > range/2 [range: reverse range]
		; reduce [
			; copy/part source/1 range + 1
			; attributes/copy source/2 range
		; ]
	; ]
	
	; decoded/remove!: function [
		; "Remove a range from the decoded source"
		; source [block!] "[items attrs] block" (parse source [block! map!])
		; range  [pair!]  "head x tail"
	; ][
		; range: clip range 0 length? source/1
		; if range/1 > range/2 [range: reverse range]
		; remove/part skip source/1 range/1 span? range
		; attributes/remove! source/2 range
		; #debug [
			; ilen: length? source/1
			; foreach [attr data] source/2 [
				; #assert [ilen = length? data/mask]
			; ]
		; ]
		; source
	; ]
	
	; decoded/insert!: function [
		; "Insert a slice into the decoded source"
		; source [block!] "[items attrs] block" (parse source [block! map!])
		; offset [integer!]
		; slice  [block!] "[items attrs] block" (parse slice [block! map!])
	; ][
		; #print "inserting (mold slice/1)/(mold/flat slice/2) into (mold source/1) at (offset)^/attrs=(mold source/2)"
		; insert skip source/1 offset slice/1
		; attributes/insert! source/2 (length? source/1) offset slice/2 (length? slice/1)
		; #print "=> (mold source/1) ^/attrs=(mold source/2)"
		; source
	; ]
	
	; decoded/normalize!: function [
		; "Clean up empty attributes from decoded data"
		; source [block!] "[items attrs] block" (parse source [block! map!])
	; ][
		; len: length? source/1
		; foreach [attr data] source/2 [
			; #assert [len = length? data/mask]
			; unless find/case data/mask nonzero! [
				; remove/key source/2 attr
			; ]
		; ]
		; source
	; ]

	; decoded/format: function [
		; "Convert decoded source into plain text"
		; source [block!] "[items attrs] block" (parse source [block! map!])
	; ][
		; result: make {} length? items: source/1
		; foreach item items [							;@@ use map-each
			; case [
				; char?  :item [append result item]
				; space? :item [if in item 'format [append result item/format]]
			; ]
		; ]
		; result
	; ]
	
	; ;@@ leverage prototypes for this
	; decoded/to-spaces: function [
		; "Transform decoded source into a list of spaces (for use in rich-content), return [content ranges]"
		; source [block!] "[items attrs] block" (parse source [block! map!])
	; ][
		; ;@@ should I clip attrs to items/length?
		; content: clear []
		; ranges:  clear []								;-- range spans of items that caret can dive into
		; set [items: attrs:] source
		; ;@@ or trim linefeed? or silently split into multiple paragraphs (hard)?
		; #assert [not find items #"^/"  "line breaks are not allowed inside paragraph text"]
		; parse items [any [
			; [	s: some char! e: (
					; append content obj: make-space 'text []
					; append/part obj/text s e
					; range: as-pair skip? s skip? e
					; obj/flags: attributes/make-rtd-flags attrs range
				; )
			; |	set obj object! (
					; append content obj
					; range: 0x1 + skip? s
				; )
			; ] (repend ranges [obj range])
		; |	end
		; |	(ERROR "Unsupported data in the source: (mold/part s 40)")
		; ]]
		; reduce [copy content  make hash! ranges]
	; ]
		
	; source: context [deserialize: serialize: none]
	
	; source/deserialize: function [
		; "Split source into [items attributes]"
		; source [block!]
		; /local attr value item
	; ][
		; items:   clear []							;@@ should items be just chars and objects? other types support, e.g. image?
		; attrs:   clear #()
		; queue:   clear []
		; pending: clear #()
		; ;; first need to build items list: each attr mask will have to have the same length
		; parse source [any [
			; set attr [
				; word! (value: on)
			; |	set-word! p: (value: do/next p 'p) :p	;-- reduce words (color names) to their values
			; ] (
				; attr:  to word! attr
				; stack: any [pending/:attr  pending/:attr: make [] 4]
				; repend stack [length? items :value]
			; )
		; |	set attr refinement! (						;-- attributes work stack-like and do not close automatically
				; attr:  to word! attr
				; unless empty? stack: pending/:attr [	;-- extra closings are silently ignored
					; value: take/last stack
					; start: take/last stack
					; repend queue [attr (start by length? items) :value]
				; ]
			; )
		; |	set item string! (explode/into item items)	;@@ make it a module
		; |	set item skip    (append/only items item)
		; ]]
		; length: length? items							;-- length is fixed now
		; ;; auto-close unclosed ranges
		; foreach [attr stack] pending [
			; foreach [start value] stack [
				; repend queue [to word! attr (start by length? items) :value]
			; ]
		; ]
		; ;; mark attribute ranges
		; foreach [attr range value] queue [
			; attributes/mark! attrs length range attr :value
		; ]
		; reduce [copy items copy attrs]
	; ]
	
	; source/serialize: function [
		; "Create a source block out of items and attributes"
		; items [block!] attrs [map!]
		; /local part
	; ][
		; queue: clear []
		; foreach [attr data] attrs [
			; set [_: values: _: mask:] data
			; closing: to refinement! attr
			; foreach [value range] mask-to-ranges values mask [
				; opening: either true = :value [to word! attr][reduce [to set-word! attr :value]]
				; ;; order is important: close then open, that's why I add 0.1
				; ;; e.g. to avoid output like `color: 1 "x" color: 2 /color "x" /color`
				; ;; when it should have been  `color: 1 "x" /color color: 2 "x" /color`
				; repend queue [range/1 + 0.1 opening range/2 closing]
			; ]
		; ]
		; sort/stable/skip queue 2
		
		; result: clear []								;-- flush the queue
		; foreach [offset marker] queue [
			; append/part result items items: skip head items to integer! offset
			; append result marker
		; ]
		; append result items
		
		; parse result [any [								;-- unify chars into strings
			; change copy part some char! (to string! part)
		; |	skip
		; ]]
		; copy result
	; ]
	
	; #assert [
		; ["x"] = source/serialize [#"x"] #()
		; ["12" bold "3456" /bold "7"] = source/serialize [#"1" #"2" #"3" #"4" #"5" #"6" #"7"] #(bold [values: [#[true]] mask: "^@^@^A^A^A^A"])
		; ["12" bold underline "3" /bold /underline] = source/serialize [#"1" #"2" #"3"] #(bold [values: [#[true]] mask: "^@^@^A^@"] underline [values: [#[true]] mask: "^@^@^A^A"])
		; ["1" x: 1 "2" /x x: 2 "3" /x "4"] = source/serialize [#"1" #"2" #"3" #"4"] #(x [values: [1 2] mask: "^@^A^B"])
	; ]
; ]

zip of order n without scalars
; zip: function [
	; "Interleave a list of series of equal length"
	; list [block!]
; ][
	; case [
		; tail?   list [copy []]
		; single? list [copy :list/1]
		; 'else [
			; r: make :list/1 (w: length? list) * h: length? :list/1
			; repeat y h [repeat x w [append/only r :list/:y/:x]]
		; ]
	; ]
; ]

zip of order n with scalars, unfinished, but looks inefficient 
; zip: function [
	; "Interleave a list of series of equal length, or scalars"
	; list [block!] (10 >= length? list)
	; /local x
; ][
	; case [
		; tail?   list [copy []]
		; single? list [copy :list/1]
		; 'else [
			; type: either series? :list/1 [:list/1][block!]
			; list: parse copy list [any [
				; set x series! (len: length? x)
			; |	change only set x skip (
					; buf: 
					; append/dup
				; )
			; ]]
			; result: make type multiply length? list length? :list/1
			; spec: [a: b: c: d: e: f: g: h: i: j:]
			; foreach
			; repeat y h [repeat x w [append/only r :list/:y/:x]]
		; ]
	; ]
; ]

unused/obsolete document parts
; ;; replaces all attributes in the range with first attribute in attrs
; document/paint: function [doc [object!] range [pair!] attrs [map!]] [
	; if any [empty? attrs  zero? span? range] [exit]
	; foreach [para: prange:] doc/map-range/relative range [	;@@ need edit func for this?
		; length: para/measure [length]
		; slice: rich/attributes/extend attrs span: span? prange
		; rich/attributes/remove! para/data/attrs prange
		; rich/attributes/insert! para/data/attrs length prange/1 slice span
		; para/data: para/data
	; ]
; ]

experiments in make alternative - safe-make2 wins by 10-15% margin and has no word leakage risk
still 3x slower than make compose/only
; safe-make: none
; safe-make2: function [proto [object!] spec [block!] /local e] [
	; parse spec: copy spec [any [
		; any set-word!
		; not end s: (set/any 'v do/next s 'e)
		; :e remove s insert only (:v)
	; ]]
	; construct/only/with spec proto
; ]

; context [
	; not-set-word!: exclude any-type! make typeset! [set-word!]
	
	; set 'safe-make4 function [proto [object!] spec [block!] /local w] [
		; obj: copy proto
		; parse spec [any thru [change set w set-word! (bind w obj)]]
		; do spec
		; obj
	; ]
	
	; set 'safe-make3 function [proto [object!] spec [block!] /local w] [
		; also obj: copy proto
		; parse spec [any [								;-- binds only set-words to the object
			; end (do spec)
		; |	some change set w set-word! (bind w obj)
		; |	some not-set-word!
		; ]]
	; ]
	
	; set 'safe-make function [proto [object!] spec [block!] /local w] [
		; obj: copy proto
		; forall spec [if set-word? :spec/1 [spec/1: bind spec/1 obj]]
		; do spec
		; obj
	; ]
; ]
